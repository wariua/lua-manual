<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>루아 5.3 참조 매뉴얼</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../lua.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../manual.css">
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=utf-8">
</HEAD>

<BODY>

<H1>
<A HREF="../../home.html"><IMG SRC="../images/logo.gif" ALT="Lua"></A>
루아 5.3 참조 매뉴얼
</H1>

<P>
저자: Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes
<BR>
번역: wariua

<P>
<SMALL>
Copyright &copy; 2015&ndash;2017 Lua.org, PUC-Rio.
Freely available under the terms of the
<a href="../../license.html">Lua license</a>.
</SMALL>

<DIV CLASS="menubar">
<A HREF="contents.html#contents">차례</A>
&middot;
<A HREF="contents.html#index">색인</A>
&middot;
<A HREF="../">다른 버전</A>
</DIV>

<!-- ====================================================================== -->
<p>

<!-- $Id: manual.of,v 1.167 2017/01/09 15:18:11 roberto Exp $ -->




<h1>1 &ndash; <a name="1">소개</a></h1>

<p>
루아(Lua)는 강력하고 효율적이며 가벼운 내장형 스크립트 언어이다.
절차적 프로그래밍, 객체 지향 프로그래밍, 함수형 프로그래밍,
데이터 주도 프로그래밍, 그리고 데이터 기술을 지원한다.


<p>
루아에서는 단순한 절차적 문법이 연관 배열과 확장식 의미론을
기반으로 한 데이터 기술 요소와 결합된다.
루아는 동적 타입이고,
레지스터 기반 가상 머신으로 바이트코드를 해석해서 실행하며,
점진적 쓰레기 수집으로 메모리를 자동 관리한다.
그래서 설정, 스크립트, 빠른 프로토타입 만들기에 이상적이다.


<p>
루아는 라이브러리로 구현되어 있으며, 표준 C와 C++의
공통 부분집합인 <em>순수 C</em>로 작성되어 있다.
루아 배포판에는 <code>lua</code>라는 호스트 프로그램이
포함되어 있는데, 루아 라이브러리를 이용해
완전한 단독형 루아 인터프리터를 제공한다.
이를 대화식 사용이나 배치 처리에 쓸 수 있다.
루아는 강력하고 가벼운 내장형 스크립트 언어로,
또 강력하지만 가볍고 효율적인 단독 언어로도
쓸 수 있게 만들어졌다.


<p>
확장형 언어이기에 루아에는 "main" 프로그램 개념이 없다.
<em>감싸는 프로그램</em> 내지 <em>호스트</em>라 부르는
호스트 클라이언트에 <em>내장</em>되어 동작한다.
(많은 경우 이 호스트는 단독형 <code>lua</code> 프로그램이다.)
호스트 프로그램에서는 함수를 호출해서 루아 코드 조각을 실행할 수 있고,
루아 변수를 읽고 쓸 수 있으며,
루아 코드에서 호출할 C 함수를 등록할 수 있다.
C 함수 사용을 통해 광범위한 분야에 대처할 수 있도록
루아를 강화할 수 있으며, 그래서 문법적 틀을 공유하는
맞춤형 프로그래밍 언어를 만들 수 있다.


<p>
루아는 자유 소프트웨어이며
라이선스에서 선언하는 것처럼
항상 그렇듯 어떤 보증도 없이 제공된다.
이 매뉴얼에서 다루는 구현체를
루아의 공식 웹 사이트인 <code>www.lua.org</code>
에서 얻을 수 있다.


<p>
여느 참조 매뉴얼과 마찬가지로
이 문서는 많은 부분 건조하다.
루아 설계 배경의 결정들에 대한
논의는 루아 웹 사이트에 있는
기술 논문들을 보라.
루아 프로그래밍에 대한 자세한
소개는 Roberto의 책
<em>Programming in Lua</em>를 보라.



<h1>2 &ndash; <a name="2">기본 개념</a></h1>

<p>
이 절에선 언어의 기본 개념들을 설명한다.



<h2>2.1 &ndash; <a name="2.1">값과 타입</a></h2>

<p>
루아는 <em>동적 타입 언어</em>이다.
즉, 변수에는 타입이 없고 값에만 타입이 있다.
언어 안에 타입 정의라는 것이 없다.
모든 값들이 각자의 타입을 가지고 있다.


<p>
루아에서 모든 값들은 <em>일급 값</em>이다.
즉, 모든 값들을 변수에 저장하고,
다른 함수에 인자로 전달하고, 결과로 반환할 수 있다.


<p>
루아에는 여덟 가지 기본 타입이 있다.
<em>nil</em>, <em>boolean</em>, <em>number</em>,
<em>string</em>, <em>function</em>, <em>userdata</em>,
<em>thread</em>, <em>table</em>이다.
<em>nil</em> 타입에는 값이 <b>nil</b> 하나만 있는데,
그 값의 주된 특징은 다른 어떤 값과도 다르다는 점이다.
일반적으로 이 값으로 유용한 값이 없음을 나타낸다.
<em>boolean</em> 타입에는 <b>false</b>와 <b>true</b>라는
두 값이 있다.
<b>nil</b>과 <b>false</b>는 조건을 거짓으로 만든다.
그 외 다른 값들은 참으로 만든다.
<em>number</em> 타입은 정수와 실수(부동소수점수)
모두를 나타낸다.
<em>string</em> 타입은 불변 바이트 열을 나타낸다.

루아는 8비트에 완전하다.
즉, 문자열에 어떤 8비트 값도 담을 수 있으며
0('<code>\0</code>')을 포함시킬 수도 있다.
루아는 또한 인코딩에 불가지론적이다.
즉, 문자열 내용물에 대해 어떤 가정도 하지 않는다.


<p>
<em>number</em> 타입에는 두 가지 내부 표현,
즉 두 가지 서브타입이 있는데,
하나는 <em>integer</em>이고 다른 하나는 <em>float</em>이다.
루아에는 각 표현을 언제 쓰는가에 대한 명확한 규칙이 있지만
필요에 따라 둘 간에 자동으로 변환을 하기도 한다. (<a href="#3.4.3">3.4.3절</a> 참고.)
따라서 프로그래머가
정수와 부동소수점 간 차이를 대강 무시하기로 할 수도 있고
각 수의 표현을 완전히 통제하기로 할 수도 있다.
표준 루아에서는 64비트 정수와 배정밀도(64비트) 부동소수점수를 쓴다.
하지만 32비트 정수 및/또는 단정밀도(32비트) 부동소수점수를 쓰도록
루아를 컴파일 할 수도 있다.
정수와 부동소수점수 모두에 32비트를 쓰는 방식은
특히 작은 머신과 임베디드 시스템에서 매력적이다.
(<code>luaconf.h</code> 파일의 <code>LUA_32BITS</code> 매크로 참고.)


<p>
루아에서는 루아로 작성된 함수와 C로 작성된 함수를 호출(및 조작)할 수 있다.
(<a href="#3.4.10">3.4.10절</a> 참고.)
둘 모두 <em>function</em> 타입으로 나타낸다.


<p>
<em>userdata</em> 타입은 임의의 C 데이터를 루아 변수에 저장할 수
있도록 하기 위한 것이다.
userdata 값은 날것 그대로의 메모리 블록을 나타낸다.
userdata에는 두 종류가 있는데,
<em>full userdata</em>는
객체 메모리 블록을 루아에서 관리하는 것이고,
<em>light userdata</em>는
그냥 C 포인터 값이다.
루아에서 userdata에는 할당과 동일성 검사를 제외하고
어떤 연산도 미리 정의되어 있지 않다.
<em>메타테이블</em>을 사용하면 프로그래머가
full userdata 값에 대한 연산을 정의할 수 있다.
(<a href="#2.4">2.4절</a> 참고.)
루아 내에서는 userdata 값을 생성하거나 변경할 수 없으며
C API를 통해서만 가능하다.
이는 호스트 프로그램 소유 데이터의 무결성을 보장하기 위해서이다.


<p>
<em>thread</em> 타입은 독립적인 실행 스레드를 나타내며
코루틴을 구현하는 데 쓴다. (<a href="#2.6">2.6절</a> 참고.)
루아 스레드는 운영 체제 스레드와는 상관없다.
루아는 자체 스레드를 지원하지 않는 경우를 포함한
모든 시스템에서 코루틴을 지원한다.


<p>
<em>table</em> 타입은 연관 배열을 구현한 것이다.
즉, 인덱스로 정수만이 아니라 <b>nil</b>과 NaN을 제외한
모든 루아 값을 사용할 수 있는 배열이다.
(<em>NaN(Not a Number)</em>는 <code>0/0</code>처럼
정의되어 있지 않거나 표현 불가능한 수치 결과를 나타내는 데
쓰는 특별한 값이다.)
테이블이 <em>혼성</em>일 수 있다.
즉, (<b>nil</b>은 빼고) 모든 타입의 값들을 담을 수 있다.
값이 <b>nil</b>인 키는 테이블에 포함되는 것으로 보지 않는다.
역으로, 테이블에 포함되어 있지 않은 키에는 모두
<b>nil</b> 값이 연계되어 있는 것이다.


<p>
테이블은 루아에서 유일한 데이터 구조화 장치이다.
테이블을 이용해 평범한 배열이나 리스트, 심볼 테이블,
집합, 레코드, 그래프, 트리 등을 표현할 수 있다.
루아에서 레코드를 표현할 때는 필드 이름을 인덱스로 사용한다.
언어에서 <code>a["name"]</code>에 대한 문법적 양념으로
<code>a.name</code>을 제공하여 그 표현 방식을 지원한다.
루아에는 테이블을 만들 수 있는 편리한 여러 방법들이 있다.
(<a href="#3.4.9">3.4.9절</a> 참고.)


<p>
인덱스에서처럼
테이블 필드 값에 어떤 타입도 가능하다.
특히 함수가 일급 값이기 때문에
함수를 테이블 필드에 담을 수 있다.
그래서 테이블이 <em>메소드</em>를 가질 수도 있다.
(<a href="#3.4.11">3.4.11절</a> 참고.)


<p>
테이블 색인에서는 언어의 raw 동일 정의를 따른다.
<code>a[i]</code>와 <code>a[j]</code>라는 식이 있을 때,
<code>i</code>와 <code>j</code>가 raw 동일(즉 메타메소드 빼고 동일)이면,
그리고 그 경우에만 두 식이 같은 테이블 항목을 나타낸다.
특별히 정수 값을 가진 부동소수점수는 대응하는 정수와 동일하다.
(가령 <code>1.0 == 1</code>이다.)
모호함을 피하기 위해
키로 정수 값 부동소수점수를 쓰면
대응하는 정수로 변환시킨다.
예를 들어 <code>a[2.0] = true</code>라고 작성하면
테이블에 들어가는 실제 키는 정수 <code>2</code>가 된다.
(한편으로,
2와 "<code>2</code>"는 서로 다른 루아 값이므로
각기 다른 테이블 항목을 나타낸다.)


<p>
테이블, 함수, 스레드, (full) userdata 값은 <em>객체</em>이다.
변수가 이 값을 실제로 <em>담는</em> 게 아니라
<em>참조</em>할 뿐이다.
할당, 매개변수 전달, 함수 반환을 하면
언제나 그 값의 참조를 조작하는 것이며,
그 연산들에 어떤 종류의 복사도 포함되지 않는다.


<p>
라이브러리 함수 <a href="#pdf-type"><code>type</code></a>이
주어진 값의 타입을 나타내는 문자열을 반환한다.
(<a href="#6.1">6.1절</a> 참고.)





<h2>2.2 &ndash; <a name="2.2">환경과 전역 환경</a></h2>

<p>
<a href="#3.2">3.2절</a>과 <a href="#3.3.3">3.3.3절</a>에서 논의하겠지만
유휴 이름 (즉 어느 선언에도 결속되지 않은 이름)
<code>var</code>에 대한 참조는
<code>_ENV.var</code>로 구문 변환된다.
그리고 <code>_ENV</code>라는 외부 지역 변수의 유효 범위 안에서
모든 청크를 컴파일 하므로 (<a href="#3.3.3">3.3.3절</a> 참고)
<code>_ENV</code> 자체는 청크 안에서 절대 유휴 이름일 수 없다.


<p>
이런 외부 <code>_ENV</code> 변수의 존재와 유휴 이름 변환에도 불구하고
<code>_ENV</code>는 완벽히 정상적인 이름이다.
특히 그 이름으로 새 변수와 매개변수를 정의할 수 있다.
유휴 이름에 대한 각 참조에서는
루아의 일반적인 가시성 규칙에 따라서
그 프로그램 위치에서 보이는 <code>_ENV</code>를 사용한다.
(<a href="#3.5">3.5절</a> 참고.)


<p>
<code>_ENV</code>의 값으로 쓰는 테이블을 모두 <em>환경(environment)</em>이라고 부른다.


<p>
루아에서는 <em>전역 환경</em>이라는 특별한 환경을 둔다.
C 레지스트리의 특수 인덱스에 그 값을 유지한다. (<a href="#4.5">4.5절</a> 참고.)
그리고 같은 값으로 전역 변수 <a href="#pdf-_G"><code>_G</code></a>를 초기화한다.
(<a href="#pdf-_G"><code>_G</code></a>는 내부적으로 절대 쓰지 않는다.)


<p>
루아에서 청크를 적재할 때
그 <code>_ENV</code> upvalue의 기본값은 전역 환경이다.
(<a href="#pdf-load"><code>load</code></a> 참고.)
따라서 기본적으로 루아 코드의 유휴 이름들은
전역 환경 내 항목들을 가리킨다.
(그래서 <em>전역 변수</em>라고도 한다.)
더불어 모든 표준 라이브러리들이 전역 환경 내에 적재되고
그 함수들 일부가 그 환경 위에서 동작한다.
<a href="#pdf-load"><code>load</code></a>를 (또는 <a href="#pdf-loadfile"><code>loadfile</code></a>을) 이용해
다른 환경으로 청크를 적재할 수 있다.
(C에서는 청크를 적재한 다음 그 첫 번째 upvalue의
값을 바꿔야 한다.)





<h2>2.3 &ndash; <a name="2.3">오류 처리</a></h2>

<p>
루아는 내장식 확장 언어이므로
모든 루아 동작은 호스트 프로그램의 C 코드가
루아 라이브러리의 함수를 호출하는 것으로 시작한다.
(단독형 루아를 사용할 때는
<code>lua</code> 응용이 호스트 프로그램이다.)
루아 청크를 컴파일 하거나 실행하는 도중에
오류가 발생하면
제어가 호스트로 되돌아간다.
거기서 (오류 메시지 찍기 같은)
적절한 대처를 할 수 있다.


<p>
루아 코드에서 <a href="#pdf-error"><code>error</code></a> 함수를
호출해서 명시적으로 오류를 만들어 낼 수 있다.
루아 내에서 오류를 잡아야 하는 경우에는
<a href="#pdf-pcall"><code>pcall</code></a>이나 <a href="#pdf-xpcall"><code>xpcall</code></a>을 사용해서
원하는 함수를 <em>보호 모드</em>로 호출할 수 있다.


<p>
오류가 있을 때마다
그 오류에 대한 정보를 담은
<em>오류 객체</em>가 (<em>오류 메시지</em>라고도 함)
전파된다.
루아 자체에서는 오류 객체가 문자열인 오류만 생성하지만
프로그램들에선 어떤 오류 객체 값으로도
오류를 생성할 수 있다.
그런 오류 객체를 처리하는 것은 그 루아 프로그램 내지 호스트의 몫이다.


<p>
<a href="#pdf-xpcall"><code>xpcall</code></a>이나 <a href="#lua_pcall"><code>lua_pcall</code></a>을 사용할 때
오류 시 호출될
<em>메시지 핸들러</em>를 줄 수 있다.
그 함수는 원본 오류 객체로 호출되어
새 오류 객체를 반환한다.
오류 때문에 스택이 풀리기 전에 호출되므로
오류에 대한 더 많은 정보를 모을 수 있다.
예를 들어 스택을 조사하거나 스택 트레이스백을 만들 수 있다.
이 메시지 핸들러 자체도 보호 호출의 보호를 받으며,
그래서 메시지 핸들러 내에서 오류가 발생하면
다시 메시지 핸들러를 부르게 된다.
그 고리가 너무 길게 이어지면
루아에서 끊고서 적절한 메시지를 반환한다.
(정규 런타임 오류들에만 메시지 핸들러가 호출된다.
메모리 할당 오류나 종료자 실행 중의 오류에는
호출되지 않는다.)





<h2>2.4 &ndash; <a name="2.4">메타테이블과 메타메소드</a></h2>

<p>
루아의 모든 값에는 <em>메타테이블(metatable)</em>이 있을 수 있다.
<em>메타테이블</em>은 평범한 루아 테이블이며
몇몇 특별한 연산들에서 기반 값의 동작을 규정한다.
메타테이블의 개별 필드를 설정해서
그 값에 대한 연산들의 동작에서 여러 측면을 바꿀 수 있다.
예를 들어 수가 아닌 값이 덧셈의 피연산자일 때
루아에서는 그 값의 메타테이블에서
"<code>__add</code>" 필드에 함수가 있는지 확인한다.
있으면 루아가 그 함수를 호출해서 덧셈을 수행한다.


<p>
메타테이블의 각 이벤트에 대한 키는
이벤트 이름 앞에 밑줄 두 개가 붙은 문자열이다.
그 키에 대응하는 값을 <em>메타메소드(metamethod)</em>라고 한다.
앞의 예에서 키는 "<code>__add</code>"이고
메타메소드는 덧셈 수행 함수이다.


<p>
<a href="#pdf-getmetatable"><code>getmetatable</code></a> 함수를 이용해
원하는 값의 메타테이블을 질의할 수 있다.
루아에서 raw 접근을 이용해 메타테이블 내의 메타메소드를 질의한다. (<a href="#pdf-rawget"><code>rawget</code></a> 참고.)
따라서 객체 <code>o</code>에서 이벤트 <code>ev</code>에 대한 메타메소드를
얻으려 할 때 루아에서 하는 것은 다음 코드와 동등하다.

<pre>
     rawget(getmetatable(<em>o</em>) or {}, "__<em>ev</em>")
</pre>

<p>
<a href="#pdf-setmetatable"><code>setmetatable</code></a> 함수를 이용해
테이블의 메타테이블을 교체할 수 있다.
루아 코드에서는 (debug 라이브러리 사용을 제외하면 (<a href="#6.10">6.10절</a> 참고))
다른 타입들의 메타테이블을 바꿀 수 없다.
그러려면 C API를 사용해야 한다.


<p>
테이블과 full userdata에는 개별적으로 메타테이블이 있다.
(단, 여러 테이블 및 userdata가 메타테이블을 공유할 수도 있다.)
다른 타입 값들은 타입별로 하나씩 있는 메타테이블을 공유한다.
즉, number 전체에 메타테이블 하나가 있고,
string 전체에 하나가 있고, 하는 식이다.
기본적으로는 값에 메타테이블이 없다.
하지만 string 라이브러리에서는 string 타입에 메타테이블을 설정한다. (<a href="#6.4">6.4절</a> 참고.)


<p>
메타테이블은 객체가 산술 연산, 비트 연산,
순서 비교, 접합, 길이 연산, 호출, 인덱스 사용에서
어떻게 동작할지를 제어한다.
또 userdata나 테이블이 쓰레기 수집 될 때
호출되는 함수를 메타테이블에 정의할 수도 있다.
(<a href="#2.5">2.5절</a> 참고.)


<p>
단항 연산자(반수, 길이, 비트 NOT)에서는
두 번째 피연산자를 첫 번째와 같은 더미 값으로 채워서
메타메소드를 계산하고 호출한다.
이 추가 피연산자는
(그 연산자들이 이항 연산자처럼 동작하게 만들어서)
루아의 내부 동작을 단순하게 만들기 위한 것이며
향후 버전에서 제거될 수도 있다.
(대부분의 용도에서 이 추가 피연산자는 별 상관이 없다.)


<p>
메타테이블로 제어하는 이벤트들의 자세한 목록이 다음에 있다.
해당 키로 각 연산을 식별한다.



<ul>

<li><b><code>__add</code>: </b>
덧셈 (<code>+</code>) 연산.
덧셈의 어느 피연산자라도 수가 아니면
(수로 강제할 수 있는 문자열도 아니면)
루아에서 메타메소드 호출을 시도하게 된다.
먼저 첫 번째 피연산자를 (유효하더라도) 확인한다.
그 피연산자에서 <code>__add</code>에 대한 메타메소드를
정의하고 있지 않으면 두 번째 피연산자를 확인한다.
메타메소드를 찾을 수 있으면
루아에서 두 피연산자를 인자로 해서
그 메타메소드를 호출하며
(한 개 값으로 조정된) 호출 결과가
연산 결과가 된다.
그렇지 않으면 오류를 제기한다.
</li>

<li><b><code>__sub</code>: </b>
뺄셈 (<code>-</code>) 연산.
덧셈 연산과 유사하게 동작.
</li>

<li><b><code>__mul</code>: </b>
곱셈 (<code>*</code>) 연산.
덧셈 연산과 유사하게 동작.
</li>

<li><b><code>__div</code>: </b>
나눗셈 (<code>/</code>) 연산.
덧셈 연산과 유사하게 동작.
</li>

<li><b><code>__mod</code>: </b>
모듈로 (<code>%</code>) 연산.
덧셈 연산과 유사하게 동작.
</li>

<li><b><code>__pow</code>: </b>
누승 (<code>^</code>) 연산.
덧셈 연산과 유사하게 동작.
</li>

<li><b><code>__unm</code>: </b>
반수 (단항 <code>-</code>) 연산.
덧셈 연산과 유사하게 동작.
</li>

<li><b><code>__idiv</code>: </b>
내림 나눗셈 (<code>//</code>) 연산.
덧셈 연산과 유사하게 동작.
</li>

<li><b><code>__band</code>: </b>
비트 AND (<code>&amp;</code>) 연산.
덧셈 연산과 유사하게 동작하되,
정수도 아니고 정수로 강제 가능한 (<a href="#3.4.3">3.4.3절</a> 참고) 값도 아닌
피연산자가 하나라도 있으면
루아에서 메타메소드를 시도하게 된다.
</li>

<li><b><code>__bor</code>: </b>
비트 OR (<code>|</code>) 연산.
비트 AND 연산과 유사하게 동작.
</li>

<li><b><code>__bxor</code>: </b>
비트 배타적 OR (이항 <code>~</code>) 연산.
비트 AND 연산과 유사하게 동작.
</li>

<li><b><code>__bnot</code>: </b>
비트 NOT (단항 <code>~</code>) 연산.
비트 AND 연산과 유사하게 동작.
</li>

<li><b><code>__shl</code>: </b>
비트 왼쪽 시프트 (<code>&lt;&lt;</code>) 연산.
비트 AND 연산과 유사하게 동작.
</li>

<li><b><code>__shr</code>: </b>
비트 오른쪽 시프트 (<code>&gt;&gt;</code>) 연산.
비트 AND 연산과 유사하게 동작.
</li>

<li><b><code>__concat</code>: </b>
접합 (<code>..</code>) 연산.
덧셈 연산과 유사하게 동작하되,
문자열도 아니고 (항상 문자열로 강제하는) 수도 아닌
피연산자가 하나라도 있으면
루아에서 메타메소드를 시도하게 된다.
</li>

<li><b><code>__len</code>: </b>
길이 (<code>#</code>) 연산.
객체가 문자열이 아니면
루아에서 메타메소드를 시도하게 된다.
메타메소드가 있으면
객체를 인자로 해서 호출하며
호출 결과가 (언제나 한 개 값으로 조정돼서)
연산 결과가 된다.
메타메소드가 없지만 객체가 테이블인 경우에는
루아에서 테이블 길이 연산을 사용한다. (<a href="#3.4.7">3.4.7절</a> 참고.)
그 외 경우에는 루아가 오류를 제기한다.
</li>

<li><b><code>__eq</code>: </b>
같음 (<code>==</code>) 연산.
덧셈 연산과 유사하게 동작하되,
비교하려는 두 값이 모두 테이블이거나 모두 userdata이고
단순 비교로는 같지 않을 때만
루아에서 메타메소드를 시도하게 된다.
호출 결과가 항상 불리언으로 변환된다.
</li>

<li><b><code>__lt</code>: </b>
작음 (<code>&lt;</code>) 연산.
덧셈 연산과 유사하게 동작하되,
비교하려는 두 값이
모두 수인 것도 아니고 모두 문자열인 것도 아닐 때만
루아에서 메타메소드를 시도하게 된다.
호출 결과가 항상 불리언으로 변환된다.
</li>

<li><b><code>__le</code>: </b>
작거나 같음 (<code>&lt;=</code>) 연산.
다른 연산들과 달리
작거나 같음 연산에서는 두 가지 이벤트를 사용할 수 있다.
먼저 루아에서는 작음 연산과 같은 방식으로
두 피연산자 모두에서 <code>__le</code> 메타메소드를 찾는다.
그런 메타메소드를 찾을 수 없는 경우에는
<code>a &lt;= b</code>가 <code>not (b &lt; a)</code>와 동등하다고 가정하고
<code>__lt</code> 메타메소드를 시도하게 된다.
다른 비교 연산자들처럼
결과가 항상 불리언이다.
(이렇게 <code>__lt</code> 이벤트를 쓰는 방식은 향후 버전에서 제거될 수 있다.
또한 진짜 <code>__le</code> 메타메소드보다 느리다.)
</li>

<li><b><code>__index</code>: </b>
인덱스 접근 <code>table[key]</code>.
<code>table</code>이 테이블이 아니거나
<code>table</code> 내에 <code>key</code>가 없을 때
이 이벤트가 일어난다.
<code>table</code>에서 메타메소드를 찾는다.


<p>
이름에도 불구하고
이 이벤트에 대한 메타메소드는 함수일 수도 있고 테이블일 수도 있다.
함수인 경우
<code>table</code>과 <code>key</code>를 인자로 해서 호출하며
호출 결과가
(한 개 값으로 조정돼서)
연산 결과가 된다.
테이블인 경우
그 테이블에 <code>key</code>를 인덱스로 쓴 결과가 최종 결과이다.
(이 인덱스 사용은 raw가 아니라 정규 방식이며,
따라서 또 다른 메타메소드가 유발될 수 있다.)
</li>

<li><b><code>__newindex</code>: </b>
인덱스 할당 <code>table[key] = value</code>.
index 이벤트에서처럼
<code>table</code>이 테이블이 아니거나
<code>table</code> 내에 <code>key</code>가 없을 때
이 이벤트가 일어난다.
<code>table</code>에서 메타메소드를 찾는다.


<p>
index에서처럼
이 이벤트에 대한 메타메소드는 함수일 수도 있고 테이블일 수도 있다.
함수인 경우
<code>table</code>, <code>key</code>, <code>value</code>를 인자로 해서 호출한다.
테이블인 경우
같은 키와 값으로 그 테이블에 인덱스 할당을 한다.
(이 할당은 raw가 아니라 정규 방식이며,
따라서 또 다른 메타메소드가 유발될 수 있다.)


<p>
<code>__newindex</code> 메타메소드가 있을 때에는
루아가 절대 단순 할당을 수행하지 않는다.
(필요하면
메타메소드 자체에서 <a href="#pdf-rawset"><code>rawset</code></a>을 호출해서
직접 할당을 할 수 있다.)
</li>

<li><b><code>__call</code>: </b>
호출 연산 <code>func(args)</code>.
루아에서 함수 아닌 값을 호출하려 할 때에
(즉 <code>func</code>가 함수가 아닐 때)
이 이벤트가 일어난다.
<code>func</code>에서 메타메소드를 찾는다.
존재하는 경우
<code>func</code>를 첫 번째 인자로 하고
이어서 원래 호출의 인자들(<code>args</code>)이 오게 해서
메타메소드를 호출한다.
호출 결과 모두가 연산 결과가 된다.
(복수 결과를 허용하는 유일한 메타메소드이다.)
</li>

</ul>

<p>
테이블을 어떤 객체의 메타테이블로 설정하기 전에
필요한 모든 메타메소드들을 추가해 두는 게 좋다.
특히 <code>__gc</code> 메타메소드는 이 순서를 따를 때만
제대로 동작한다. (<a href="#2.5.1">2.5.1절</a> 참고.)


<p>
메타테이블도 정규 테이블이기 때문에
위에 규정한 이벤트 이름들만이 아니라
임의의 필드를 담을 수 있다.
표준 라이브러리의 일부 함수들은
(가령 <a href="#pdf-tostring"><code>tostring</code></a>)
메타테이블의 다른 필드들을 자체 용도에 이용한다.





<h2>2.5 &ndash; <a name="2.5">쓰레기 수집</a></h2>

<p>
루아는 자동 메모리 관리를 수행한다.
즉, 새 객체를 위해 메모리를 할당하는 것이나
그 객체가 더는 필요 없을 때 해제하는 것에 대해
신경 쓸 필요가 없다.
루아에서 <em>쓰레기 수집기</em>를 실행해
<em>죽은 객체</em>를
(즉 루아에서 더 이상 접근할 수 없는 객체를)
모두 수집하는 방식으로 메모리를 자동 관리한다.
문자열, 테이블, userdata, 함수, 스레드, 내부 구조 등,
루아에서 사용하는 모든 메모리가 자동 관리 대상이다.


<p>
루아에서는 점진적 mark-and-sweep 수집기를 구현하고 있다.
쓰레기 수집 사이클을 제어하는 두 가지 수치가 있는데,
<em>쓰레기 수집 휴지 시간</em>과
<em>쓰레기 수집 단계 승수</em>이다.
둘 다 백분률 단위이다.
(가령 100 값이 내부적으로 1 값을 뜻한다.)


<p>
쓰레기 수집 휴지 시간은
수집기가 얼마나 오래 대기했다가 새 주기를 시작할지 제어한다.
값이 크면 수집기가 덜 적극적이 된다.
100보다 작은 값은 수집기가 기다리지 않고
새 주기를 시작한다는 뜻이다.
200 값은 총 사용 메모리가 두 배가 될 때까지
수집기가 기다렸다가 새 주기를 시작한다는 뜻이다.


<p>
쓰레기 수집 단계 승수는
메모리 할당에 대한 수집기의 상대 속도를 제어한다.
값이 크면 수집기가 더 적극적이 되며
또 각 점진 단계가 더 커진다.
100보다 작은 값은 사용하지 않는 게 좋다.
수집기가 너무 느려지며
수집기가 한 주기를 절대 마치지 못하게 될 수 있기 때문이다.
기본은 200인데,
메모리 할당 속도의 "두 배"로 수집기가 돈다는 뜻이다.


<p>
단계 승수를 아주 큰 수로
(프로그램에서 사용할 수 있는 최대 바이트 수의 10% 이상으로)
설정하면
수집기가 stop-the-world 수집기처럼 동작한다.
거기서 휴지 시간을 200으로 설정하면
루아 이전 버전들처럼 수집기가 동작하게 된다.
즉, 루아의 메모리 사용량이 두 배가 될 때마다
전체 수집을 한다.


<p>
C에서 <a href="#lua_gc"><code>lua_gc</code></a>를 호출하거나
루아에서 <a href="#pdf-collectgarbage"><code>collectgarbage</code></a>를 호출해서
이 수치들을 바꿀 수 있다.
그 함수들을 사용하면 수집기를 직접 제어할 (가령 멈추거나 재시작할) 수도 있다.



<h3>2.5.1 &ndash; <a name="2.5.1">쓰레기 수집 메타메소드</a></h3>

<p>
테이블에, 그리고 C API로는 full userdata에도
쓰레기 수집 메타메소드를 설정할 수 있다.
(<a href="#2.4">2.4절</a> 참고.)
이 메타메소드들을 <em>종료자(finalizer)</em>라고 한다.
종료자를 이용하면 루아의 쓰레기 수집을
(파일이나 네트워크 내지 데이터베이스 연결 닫기,
자체 메모리 해제 같은)
외부 자원 관리에 연계할 수 있다.


<p>
수집 때 마무리 작업이 필요한 객체(테이블이나 userdata)에는
마무리를 하라는 <em>표시</em>를 해 주어야 한다.

객체에 메타테이블을 설정할 때 마무리 표시를 하게 되는데
그 메타테이블에 문자열 "<code>__gc</code>"가 인덱스인
필드가 있어야 한다.
참고로 <code>__gc</code> 필드 없이 메타테이블을 설정하고서
나중에 메타테이블에 그 필드를 만들어도
객체에 마무리 표시가 되지 않는다.


<p>
표시가 붙은 객체가 쓰레기가 될 때에는
쓰레기 수집기가 즉시 수집하지 않는다.
대신 루아에서 어떤 목록에 그 객체를 넣어 둔다.
그리고 수집 후에 그 목록을 살펴본다.
목록의 각 객체마다
객체의 <code>__gc</code> 메타메소드를 확인한다.
함수이면
그 객체를 단일 인자로 해서 호출한다.
메타메소드가 함수가 아니면
그냥 무시한다.


<p>
각 쓰레기 수집 사이클 마지막에서
그 주기에 수집한 객체들에 대해
마무리 표시를 한 것과 반대 순서로
객체의 종료자를 호출한다.
즉, 처음 호출되는 종료자는
프로그램에서 마지막으로 표시한 객체에 연계된 종료자이다.
종료자 실행은 정규 코드 실행 중의 어느 시점에서든
이뤄질 수 있다.


<p>
수집 중인 객체를 종료자에서 계속 사용해야 하기 때문에
그 객체를 (그리고 그 객체를 통해서만 접근 가능한 다른 객체들을)
루아에서 <em>부활</em>시켜야 한다.
일반적으로 이 부활은 일시적이며
다음 쓰레기 수집 주기에 그 객체 메모리가 해제된다.
하지만 종료자에서 그 객체를 어떤 전역 위치에 (가령 전역 변수에)
저장한다면 부활이 영구적이 된다.
그리고 종료자에서 마무리 중인 객체에 다시 마무리 표시를 하면
그 객체가 도달 불가능하게 되는 다음번 주기에 종료자가 다시 호출된다.
어느 경우이든,
객체가 도달 불가능이고 마무리 표시가 되어 있지 않은
GC 주기에서만 객체 메모리가 해제된다.


<p>
상태를 닫을 때 (<a href="#lua_close"><code>lua_close</code></a> 참고)
루아에서는 마무리 표시가 된 모든 객체들의 종료자를
표시 반대 순서로 호출한다.
그 단계에서 어느 종료자가 객체에 수집 표시를 해도
그 표시에 아무 효과가 없다.





<h3>2.5.2 &ndash; <a name="2.5.2">약한 테이블</a></h3>

<p>
<em>약한 테이블</em>이란
<em>약한 참조</em>가 원소인 테이블이다.
약한 참조는 쓰레기 수집 시 무시된다.
다시 말해
어느 객체에 대한 참조가 약한 참조뿐이면
쓰레기 수집기가 그 객체를 수집하게 된다.


<p>
약한 테이블은 키가 약하거나 값이 약할 수도 있고,
둘 모두 약할 수도 있다.
값이 약한 테이블은 값이 수집되는 것은 허용하지만
키가 수집되는 것은 막는다.
키와 값 모두 약한 테이블은
키와 값 모두의 수집을 허용한다.
어느 경우이든 키나 값이 수집되면
그 쌍이 통째로 테이블에서 제거된다.
테이블 메타테이블의 <code>__mode</code> 필드로
테이블의 약함 방식을 제어한다.
<code>__mode</code> 필드가 문자 '<code>k</code>'를 담은 문자열이면
그 테이블의 키가 약하다.
<code>__mode</code>가 '<code>v</code>'를 담고 있으면
그 테이블의 값이 약하다.


<p>
약한 키와 강한 값의 테이블을
<em>하루살이 테이블</em>이라고도 한다.
하루살이 테이블에서는
키가 도달 가능한 경우에만 그 값이 도달 가능하다고 본다.
특히 어느 키에 대한 유일한 참조가 그 값을 통한 것이면
그 쌍을 제거한다.


<p>
테이블의 약함 방식을 변경한 효과가
다음 수집 주기에서야 나타날 수도 있다.
특히 강한 방식으로 바꾸는 경우에
변경 효과가 나타나기 전까지는
루아에서 그 테이블의 일부 항목들을 수집할 수도 있다.


<p>
명시적 생성을 하는 객체들만
약한 테이블에서 제거된다.
수나 경량 C 함수 같은 값들은
쓰레기 수집 대상이 아니고,
따라서 (연계된 값이 수집되지 않는 한)
약한 테이블에서 제거되지 않는다.
문자열은 쓰레기 수집의 대상이지만
명시적 생성을 하지 않으며,
따라서 약한 테이블에서 제거되지 않는다.


<p>
부활한 객체는
(즉 마무리 중인 객체와
마무리 중인 객체를 통해서만 접근 가능한 객체는)
약한 테이블에서 특별한 방식으로 동작한다.
약한 값에서 제거될 때는 종료자 실행 전에 제거되지만
약한 키에서 제거될 때는 종료자 실행 후에
그 객체가 실제로 해제되는 다음 주기에서야 제거된다.
이런 동작 덕분에 종료자에서 약한 테이블을 통해
객체와 연관된 자산들에 접근할 수 있다.


<p>
어느 수집 주기에 부활한 객체들 중에 약한 테이블이 있는 경우
다음 주기까지 그 테이블이 제대로 사라지지 않을 수도 있다.







<h2>2.6 &ndash; <a name="2.6">코루틴</a></h2>

<p>
루아는 <em>협력적 멀티스레딩</em>이라고도 하는
코루틴을 지원한다.
루아에서 코루틴은 독립적 실행 스레드를 나타낸다.
하지만 멀티스레드 시스템의 스레드와 달리
코루틴은 명시적인 양보 함수 호출을 통해서만
실행을 멈춘다.


<p>
<a href="#pdf-coroutine.create"><code>coroutine.create</code></a>를 호출해서 코루틴을 만든다.
유일한 인자가 함수이고 그게 코루틴의 메인 함수이다.
<code>create</code> 함수는 새 코루틴을 만들어서
핸들(<em>thread</em> 타입 객체)을 반환하기만 한다.
즉, 코루틴을 시작하지는 않는다.


<p>
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>을 호출해서 코루틴을 실행한다.
<a href="#pdf-coroutine.create"><code>coroutine.create</code></a>가 반환한 스레드를
첫 번째 인자로 해서
처음으로 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>을 호출할 때
코루틴이 자기 메인 함수를 호출하며 실행을 시작한다.
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>으로 전달한 추가 인자들이
그 함수의 인자로 전달된다.
코루틴이 실행을 시작하고 나면
종료하거나 <em>양보(yield)</em>할 때까지 돈다.


<p>
코루틴은 두 가지 방식으로 실행을 끝마칠 수 있다.
메인 함수가 (명시적으로, 또는 마지막 인스트럭션 후에 암묵적으로) 반환할 때
정상적으로 종료하거나,
보호 안 된 오류가 있을 때 비정상적으로 종료한다.
정상 종료하는 경우
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>이 <b>true</b>에 더해서
코루틴 메인 함수가 반환한 값들이 있으면 함께 반환한다.
오류 시 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>이 <b>false</b>에 더해서
오류 객체를 반환한다.


<p>
<a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>를 호출해서 코루틴이 양보를 한다.
코루틴이 양보하면
대응하는 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>이 즉시 반환한다.
중첩된 함수 호출 내에서
(즉 메인 함수 안이 아니라 메인 함수에서 직간접으로 호출한 함수 안에서)
양보가 이뤄질 때도 마찬가지이다.
양보하는 경우 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>이 <b>true</b>에 더해서
<a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>에 전달한 값들이 있으면 함께 반환한다.
같은 코루틴을 다음에 재개할 때는
양보했던 지점에서 실행이 이어지며,
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>으로 추가 전달한 인자들이 있으면
<a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a> 호출이 반환한다.


<p>
<a href="#pdf-coroutine.create"><code>coroutine.create</code></a>처럼
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a> 함수도 코루틴을 만든다.
하지만 코루틴 자체를 반환하는 것이 아니라
함수를 반환하며, 그 함수 호출 시 코루틴이 재개된다.
그 함수로 전달한 인자들이 있으면
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 추가 인자가 된다.
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a>은 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>이 반환한 값들을
첫 번째 값(불리언 오류 코드)만 빼고
전부 반환한다.
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>과 달리
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a>은 오류를 잡지 않는다.
즉, 오류가 생기면 호출자에게 전파된다.


<p>
코루틴의 동작 방식에 대한 예로
다음 코드를 살펴보자.

<pre>
     function foo (a)
       print("foo", a)
       return coroutine.yield(2*a)
     end
     
     co = coroutine.create(function (a,b)
           print("co-body", a, b)
           local r = foo(a+1)
           print("co-body", r)
           local r, s = coroutine.yield(a+b, a-b)
           print("co-body", r, s)
           return b, "end"
     end)
     
     print("main", coroutine.resume(co, 1, 10))
     print("main", coroutine.resume(co, "r"))
     print("main", coroutine.resume(co, "x", "y"))
     print("main", coroutine.resume(co, "x", "y"))
</pre><p>
실행하면 다음 출력이 나온다.

<pre>
     co-body 1       10
     foo     2
     main    true    4
     co-body r
     main    true    11      -9
     co-body x       y
     main    true    10      end
     main    false   cannot resume dead coroutine
</pre>

<p>
C API를 통해서도 코루틴을 생성하고 조작할 수 있다.
함수 <a href="#lua_newthread"><code>lua_newthread</code></a>, <a href="#lua_resume"><code>lua_resume</code></a>,
<a href="#lua_yield"><code>lua_yield</code></a>를 보라.





<h1>3 &ndash; <a name="3">언어</a></h1>

<p>
이 절에서는 루아의 어휘, 문법, 의미론을 기술한다.
다시 말해
어떤 토큰들이 유효한지,
그 토큰들을 어떻게 결합할 수 있는지,
그리고 그 조합이 무엇을 뜻하는지 설명한다.


<p>
흔히 하듯 확장 BNF 표기법을 이용해 언어 구성 요소들을 설명할 것이다.
{<em>a</em>}는 <em>a</em>가 0개나 그보다 많이 있다는 뜻이고
[<em>a</em>]는 <em>a</em>가 선택적이라는 뜻이다.
비말단 심볼은 글꼴 꾸밈 없이 표시하며,
키워드는 <b>kword</b>처럼 표시하고
다른 말단 심볼들은 &lsquo;<b>=</b>&rsquo;처럼 표시한다.
루아의 전체 문법을 이 매뉴얼 끝의 <a href="#9">9절</a>에서 볼 수 있다.



<h2>3.1 &ndash; <a name="3.1">어휘 규정</a></h2>

<p>
루아는 자유 형식 언어이다.
이름 및 키워드 간 구분자일 때를 제외하면
어휘 요소(토큰)들 사이의
(개행 포함) 공백과 주석을 무시한다.


<p>
루아에서 <em>이름</em>(<em>식별자</em>라고도 함)은
글자, 숫자, 밑줄로 된 어떤 열도 가능하되,
숫자로 시작할 수 없고
예약 단어가 아니어야 한다.
변수, 테이블 필드, 레이블을 지칭하는 데 식별자를 쓴다.


<p>
다음 <em>키워드</em>는 예약되어 있어서
이름으로 쓸 수 없다.


<pre>
     and       break     do        else      elseif    end
     false     for       function  goto      if        in
     local     nil       not       or        repeat    return
     then      true      until     while
</pre>

<p>
루아는 대소문자를 구별하는 언어이다.
그래서 <code>and</code>는 예약 단어지만
<code>And</code>와 <code>AND</code>는 그와 다른 유효한 이름이다.
관행 상
밑줄로 시작하고 이어서 한 개 이상의 대문자가 오는
(<a href="#pdf-_VERSION"><code>_VERSION</code></a> 같은) 이름을
프로그램에서 만들지 않는 게 좋다.


<p>
다음이 나머지 토큰들을 나타낸다.

<pre>
     +     -     *     /     %     ^     #
     &amp;     ~     |     &lt;&lt;    &gt;&gt;    //
     ==    ~=    &lt;=    &gt;=    &lt;     &gt;     =
     (     )     {     }     [     ]     ::
     ;     :     ,     .     ..    ...
</pre>

<p>
짝이 맞는 작은따옴표나 큰따옴표로 감싸서
<em>짧은 리터럴 문자열</em>을 만들 수 있다.
그 문자열에
'<code>\a</code>' (벨),
'<code>\b</code>' (백스페이스),
'<code>\f</code>' (폼 피드),
'<code>\n</code>' (개행),
'<code>\r</code>' (캐리지 리턴),
'<code>\t</code>' (수평 탭),
'<code>\v</code>' (수직 탭),
'<code>\\</code>' (백슬래시),
'<code>\"</code>' (큰따옴표),
'<code>\'</code>' (작은따옴표)
같은 C 스타일 이스케이프 열이 포함될 수 있다.
백슬래시 다음에 행 바꿈이 오면
문자열 내에서 개행이 된다.
이스케이프 열 '<code>\z</code>'는
행 바꿈을 포함해서
이어지는 공백 문자 구간을 건너뛰게 한다.
긴 리터럴 문자열을
내용에 개행이나 공백을 더하지 않으면서
여러 행으로 쪼개고 들여 쓰는 데
유용하게 이용할 수 있다.
짧은 리터럴 문자열에는
이스케이프 안 된 줄 바꿈이나
유효한 이스케이프 열이 아닌 이스케이프가 포함될 수 없다.


<p>
짧은 리터럴 문자열 내 임의 바이트를
숫자 값으로
(0 포함)
지정할 수 있다.
이스케이프 열 <code>\x<em>XX</em></code>를 쓰는데,
여기서 <em>XX</em>는 정확히 두 개의 16진수 열이다.
또는 이스케이프 열 <code>\<em>ddd</em></code>를 쓰는데,
여기서 <em>ddd</em>는 세 개까지의 10진수 열이다.
(참고로 10진 이스케이프 열에 이어서 숫자가 오는 경우에는
정확히 세 개 숫자로 표현해야 한다.)


<p>
이스케이프 열 <code>\u{<em>XXX</em>}</code>를 이용해
UTF-8 인코딩 한 유니코드 문자를
리터럴 문자열에 집어넣을 수 있다.
(감싸는 중괄호가 필수이다.)
여기서 <em>XXX</em>는 문자 코드 포인트를 나타내는
한 개 이상의 16진수 열이다.


<p>
<em>긴 괄호</em>로 감싸는 긴 형식을 이용해
리터럴 문자열을 정의할 수도 있다.
먼저 <em><em>n</em>단계 여는 긴 괄호</em>를 정의하면,
여는 대괄호 다음에 등호 <em>n</em>개가 오고
다시 여는 대괄호가 오는 것이다.
그래서 0단계인 여는 긴 괄호는 <code>[[</code>라고 쓰고
1단계인 여는 긴 괄호는 <code>[=[</code>로 쓰는 식이다.
<em>닫는 긴 괄호</em>도 비슷하게 정의한다.
예를 들어 4단계인 닫는 긴 괄호는 <code>]====]</code>로 쓴다.
<em>긴 리터럴</em>은 임의 단계의 여는 긴 괄호로 시작하고
같은 단계의 닫는 긴 괄호로 끝난다.
같은 단계의 닫는 괄호를 제외한 어떤 텍스트도 담을 수 있다.
이 괄호 형태로 된 리터럴은 여러 행에 걸쳐 있을 수 있고,
그 안에서 어떤 이스케이프 열도 해석하지 않으며,
다른 단계의 긴 괄호를 무시한다.
그리고 모든 종류의 행 종료 열(캐리지 리턴, 개행,
캐리지 리턴 다음 개행, 개행 다음 캐리지 리턴)이
그냥 개행으로 변환된다.


<p>
편의를 위해
여는 긴 괄호 바로 다음에 개행이 올 때는
그 개행을 문자열에 포함시키지 않는다.
예를 들어 ASCII를 쓰는
('<code>a</code>'를 97로, 개행을 10으로,
'<code>1</code>'을 49로 코딩 하는)
시스템에서
아래 다섯 가지 리터럴 문자열은 같은 문자열을 나타낸다.

<pre>
     a = 'alo\n123"'
     a = "alo\n123\""
     a = '\97lo\10\04923"'
     a = [[alo
     123"]]
     a = [==[
     alo
     123"]==]
</pre>

<p>
명확히 위 규칙들에 해당되지 않는
리터럴 문자열 내 바이트는 그대로 표현된다.
하지만 루아가 텍스트 모드로 파일을 열어서 파싱 하므로
일부 제어 문자가
시스템 파일 함수에서 문제가 될 수도 있다.
따라서 비텍스트 데이터를 표현할 때는
비텍스트 문자에 대한 명확한 이스케이프 열을 담은
따옴표 리터럴을 쓰는 것이 안전하다.


<p>
<em>숫자 상수</em>(즉 <em>숫자</em>)를
선택적으로 소수 부분이나
'<code>e</code>' 내지 '<code>E</code>' 글자로 표시한
10진수 지수와 함께 쓸 수 있다.
<code>0x</code>나 <code>0X</code>로 시작하는
16진 상수도 받는다.
16진 상수에서도 선택적으로 소수 부분이나
'<code>p</code>' 내지 '<code>P</code>' 글자로 표시한
2진 지수를 받는다.
소수점이나 지수가 있는 숫자 상수는
부동소수점수를 나타낸다.
그렇지 않고
값이 정수 범위에 맞으면
정수를 나타낸다.
다음은 유효한 정수 상수의 예이다.

<pre>
     3   345   0xff   0xBEBADA
</pre><p>
다음은 유효한 부동소수점수 상수의 예이다.

<pre>
     3.0     3.1416     314.16e-2     0.31416E1     34e1
     0x0.1E  0xA23p-4   0X1.921FB54442D18P+1
</pre>

<p>
문자열 밖 어디서든 하이픈 두 개(<code>--</code>)로
<em>주석</em>이 시작된다.
<code>--</code> 바로 다음 텍스트가 여는 긴 괄호가 아니면
그 주석은 <em>짧은 주석</em>이고
그 행 끝까지 이어진다.
맞으면 <em>긴 주석</em>이고
대응하는 닫는 긴 괄호까지 이어진다.
긴 주석은 코드를 임시로 비활성화하는 데 자주 쓴다.





<h2>3.2 &ndash; <a name="3.2">변수</a></h2>

<p>
변수는 값을 저장하는 장소이다.
루아에는 세 가지 종류의 변수가 있는데,
전역 변수, 지역 변수, 그리고 테이블 필드이다.


<p>
한 이름이 전역 변수나 지역 변수를
(또는 지역 변수의 한 종류인 함수의 형식 매개변수를)
나타낼 수 있다.

<pre>
	var ::= Name
</pre><p>
Name은 <a href="#3.1">3.1절</a>에 정의된 식별자를 나타낸다.


<p>
명시적으로 지역으로 선언하지 않는 한 (<a href="#3.3.7">3.3.7절</a> 참고)
변수 이름은 전역으로 상정한다.
지역 변수의 유효 범위는 <em>문법적(lexical)</em>이다.
그리고 지역 변수의 유효 범위 내에 정의된 함수에서
그 변수에 자유롭게 접근할 수 있다.
(<a href="#3.5">3.5절</a> 참고.)


<p>
첫 할당을 하기 전에 변수의 값은 <b>nil</b>이다.


<p>
테이블 인덱스 접근에는 대괄호를 사용한다.

<pre>
	var ::= prefixexp &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo;
</pre><p>
메타테이블을 통해 테이블 필드 접근의 의미를 바꿀 수 있다.
인덱스 된 변수에 대한 접근 <code>t[i]</code>는
<code>gettable_event(t,i)</code> 호출과 동등하다.
(<code>gettable_event</code> 함수에 대한 완전한 설명은
<a href="#2.4">2.4절</a>을 보라.
이 함수는 루아에서 정의되어 있거나 호출 가능하지 않다.
설명을 위한 것일 뿐이다.)


<p>
<code>var.Name</code> 구문은
<code>var["Name"]</code>에 대한 문법적 양념일 뿐이다.

<pre>
	var ::= prefixexp &lsquo;<b>.</b>&rsquo; Name
</pre>

<p>
전역 변수 <code>x</code>에 대한 접근은
<code>_ENV.x</code>와 동등하다.
청크를 컴파일 하는 방식 때문에
<code>_ENV</code>는 절대 전역 이름이 아니다.
(<a href="#2.2">2.2절</a> 참고.)





<h2>3.3 &ndash; <a name="3.3">문</a></h2>

<p>
루아에서는 파스칼이나 C와 유사한
거의 관행적인 문들을 지원한다.
할당, 제어 구조, 함수 호출,
변수 선언 등을 포함한다.



<h3>3.3.1 &ndash; <a name="3.3.1">블록</a></h3>

<p>
블록은 순차적으로 실행되는
문들의 목록이다.

<pre>
	block ::= {stat}
</pre><p>
루아에는 <em>빈 문</em>이 있어서
세미콜론으로 문들을 분리할 수 있으며
블록을 세미콜론으로 시작하거나
세미콜론 두 개를 연달아 쓸 수도 있다.

<pre>
	stat ::= &lsquo;<b>;</b>&rsquo;
</pre>

<p>
함수 호출과 할당이
열린 괄호로 시작할 수 있는데,
이 점이 루아 문법에서 모호함을 만든다.
다음 코드 조각을 보자.

<pre>
     a = b + c
     (print or io.write)('done')
</pre><p>
문법적으로 이를 두 가지로 볼 수 있다.

<pre>
     a = b + c(print or io.write)('done')
     
     a = b + c; (print or io.write)('done')
</pre><p>
현행 파서에서는 이런 경우를
항상 첫 번째 방식으로 보아서
열린 괄호를 호출 인자들의 시작으로 해석한다.
이런 모호함을 피하기 위한 좋은 습관은
괄호로 시작하는 문 앞에
항상 세미콜론을 붙이는 것이다.

<pre>
     ;(print or io.write)('done')
</pre>

<p>
블록 끝에 명시적으로 표시를 하면 문 하나를 만들어 낼 수 있다.

<pre>
	stat ::= <b>do</b> block <b>end</b>
</pre><p>
명시적 블록은
변수 선언의 유효 범위를 제어하는 데 유용하다.
때로는
다른 블록 중간에 <b>return</b> 문을 추가하는 데
쓰기도 한다.
(<a href="#3.3.4">3.3.4절</a> 참고.)





<h3>3.3.2 &ndash; <a name="3.3.2">청크</a></h3>

<p>
루아의 컴파일 단위를 <em>청크(chunk)</em>라고 부른다.
문법적으로
청크는 그냥 블록이다.

<pre>
	chunk ::= block
</pre>

<p>
루아에서는 청크를
인자가 가변인 이름 없는 함수의 몸체인 것으로 다룬다.
(<a href="#3.4.11">3.4.11절</a> 참고.)
그렇기에 청크에서 지역 변수를 정의할 수 있고,
인자를 받고 값을 반환할 수 있다.
그리고 그 익명 함수가
<code>_ENV</code>라는 외부 지역 변수의 유효 범위 내에
있는 것으로 해서 컴파일 한다.
그래서 그 함수에는 언제나 유일한 upvalue로 <code>_ENV</code>가 있다.
(<a href="#2.2">2.2절</a> 참고.)
그 변수를 쓰지 않을 때에도 그렇다.


<p>
파일이나 호스트 프로그램 내 문자열에 청크를 저장할 수 있다.
실행을 위해
루아는 먼저 청크를 <em>적재</em>하는데,
청크의 코드를 가상 머신 인스트럭션으로 사전 컴파일 한다.
그러고서 컴파일 된 코드를
가상 머신 인터프리터로 실행한다.


<p>
청크를 바이너리 형태로 사전 컴파일 해 둘 수도 있다.
자세한 내용은 <code>luac</code> 프로그램과 <a href="#pdf-string.dump"><code>string.dump</code></a> 함수를 보라.
소스 형태 프로그램과 컴파일 형태 프로그램은 서로 대체 가능하다.
루아가 파일 종류를 자동으로 탐지해서 그에 맞게 동작한다.
(<a href="#pdf-load"><code>load</code></a> 참고.)





<h3>3.3.3 &ndash; <a name="3.3.3">할당</a></h3>

<p>
루아에서는 다중 할당이 가능하다.
그래서 할당 문법에서
왼쪽에 변수 목록이 오고
오른쪽에 식 목록이 온다.
두 목록 모두 쉼표로 항목을 구분한다.

<pre>
	stat ::= varlist &lsquo;<b>=</b>&rsquo; explist
	varlist ::= var {&lsquo;<b>,</b>&rsquo; var}
	explist ::= exp {&lsquo;<b>,</b>&rsquo; exp}
</pre><p>
식은 <a href="#3.4">3.4절</a>에서 논의한다.


<p>
할당을 하기 전에
변수 목록 길이에 맞춰 값 목록을 <em>조정</em>한다.
값이 필요한 것보다 많으면
남는 값들을 버린다.
값이 필요한 것보다 적으면
필요한 만큼 <b>nil</b>로 채워서 목록을 확장한다.
식 목록이 함수 호출로 끝나는 경우에는
그 호출이 반환한 모든 값들을
(호출에 괄호 쳐진 경우는 예외. <a href="#3.4">3.4절</a> 참고)
값 목록에 넣은 후
조정한다.


<p>
할당 문에서는 먼저 모든 식들을 평가하고
그 다음에야 할당을 수행한다.
그래서 다음 코드가 있을 때,

<pre>
     i = 3
     i, a[i] = i+1, 20
</pre><p>
<code>a[3]</code>이 20으로 설정되고 <code>a[4]</code>는 영향을 받지 않는다.
<code>a[i]</code> 안의 <code>i</code>를 (3으로) 평가한 다음에
4로 할당하기 때문이다.
마찬가지로 다음 행은

<pre>
     x, y = y, x
</pre><p>
<code>x</code>와 <code>y</code>의 값을 교환한다. 그리고 다음은

<pre>
     x, y, z = y, z, x
</pre><p>
<code>x</code>, <code>y</code>, <code>z</code>의 값을 순환식으로 치환한다.


<p>
전역 변수와 테이블 필드에 대한 할당의 의미를
메타테이블을 통해 바꿀 수 있다.
인덱스 된 변수에 대한 할당 <code>t[i] = val</code>은
<code>settable_event(t,i,val)</code>와 동등하다.
(<code>settable_event</code> 함수에 대한 완전한 설명은
<a href="#2.4">2.4절</a>을 보라.
이 함수는 루아에서 정의되어 있거나 호출 가능하지 않다.
설명을 위한 것일 뿐이다.)


<p>
전역 이름에 대한 할당 <code>x = val</code>은
할당 <code>_ENV.x = val</code>과 동등하다.
(<a href="#2.2">2.2절</a> 참고.)





<h3>3.3.4 &ndash; <a name="3.3.4">제어 구조</a></h3><p>
제어 구조 <b>if</b>, <b>while</b>, <b>repeat</b>의
문법은 익숙한 형태이고 의미도 많이 쓰는 대로이다.




<pre>
	stat ::= <b>while</b> exp <b>do</b> block <b>end</b>
	stat ::= <b>repeat</b> block <b>until</b> exp
	stat ::= <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b>
</pre><p>
루아에는 두 가지 종류의 <b>for</b> 문도 있다. (<a href="#3.3.5">3.3.5절</a> 참고.)


<p>
제어 구조의 조건 식은
어떤 값이든 반환할 수 있다.
<b>false</b>와 <b>nil</b>은 거짓으로 본다.
<b>nil</b>과 <b>false</b> 외의 모든 값은 참으로 본다.
(특히 수 0과 빈 문자열도 참이다.)


<p>
<b>repeat</b>&ndash;<b>until</b> 루프에서
내부 블록은 <b>until</b> 키워드에서 끝나는 것이 아니라
조건 식 다음에서 끝난다.
따라서 루프 블록 내에 선언된 지역 변수를
조건에서 참조할 수 있다.


<p>
<b>goto</b> 문은 레이블로 프로그램 제어를 옮긴다.
구문 처리 상의 이유로
루아에서는 레이블도 문으로 본다.



<pre>
	stat ::= <b>goto</b> Name
	stat ::= label
	label ::= &lsquo;<b>::</b>&rsquo; Name &lsquo;<b>::</b>&rsquo;
</pre>

<p>
레이블이 정의된 블록 전체에서 그 레이블이 보인다.
단, 같은 이름 레이블을 정의한 중첩 블록 안에서나
중첩 함수 안에서는 보이지 않는다.
지역 변수의 유효 범위 내로 들어가는 것만 아니면
보이는 모든 레이블로 goto 점프 할 수 있다.


<p>
아무 동작도 수행하지 않는
레이블과 빈 문을 <em>void 문</em>이라고 한다.


<p>
<b>break</b> 문은
<b>while</b>, <b>repeat</b>, <b>for</b> 루프의 실행을 끝내고
루프 다음의 문으로 건너뛴다.


<pre>
	stat ::= <b>break</b>
</pre><p>
<b>break</b>는 가장 안쪽 루프를 끝낸다.


<p>
<b>return</b> 문을 이용해
함수나 (익명 함수인) 청크에서 값을 반환한다.

함수에서 값을 여러 개 반환할 수 있으며,
그래서 <b>return</b> 문의 문법은 다음과 같다.

<pre>
	stat ::= <b>return</b> [explist] [&lsquo;<b>;</b>&rsquo;]
</pre>

<p>
<b>return</b> 문은
블록 마지막 문으로만 쓸 수 있다.
꼭 블록 중간에서 <b>return</b> 해야겠다면
<code>do return end</code>처럼
명확한 내부 블록을 사용할 수 있다.
그렇게 하면 <b>return</b>이 (안쪽) 블록의 마지막 문이 된다.





<h3>3.3.5 &ndash; <a name="3.3.5">for 문</a></h3>

<p>

<b>for</b> 문에는 수열형과 일반형, 두 가지 형태가 있다.


<p>
수열형 <b>for</b> 루프는
제어 변수가 등차수열을 거치는 동안
코드 블록을 반복한다.
문법은 다음과 같다.

<pre>
	stat ::= <b>for</b> Name &lsquo;<b>=</b>&rsquo; exp &lsquo;<b>,</b>&rsquo; exp [&lsquo;<b>,</b>&rsquo; exp] <b>do</b> block <b>end</b>
</pre><p>
<em>name</em>이 첫 번째 <em>exp</em> 값으로 시작해서
세 번째 <em>exp</em>씩 진행해서 두 번째 <em>exp</em>를 지날 때까지
<em>block</em>을 반복한다.
더 엄밀하게는 다음 <b>for</b> 문이

<pre>
     for v = <em>e1</em>, <em>e2</em>, <em>e3</em> do <em>block</em> end
</pre><p>
다음 코드와 동등하다.

<pre>
     do
       local <em>var</em>, <em>limit</em>, <em>step</em> = tonumber(<em>e1</em>), tonumber(<em>e2</em>), tonumber(<em>e3</em>)
       if not (<em>var</em> and <em>limit</em> and <em>step</em>) then error() end
       <em>var</em> = <em>var</em> - <em>step</em>
       while true do
         <em>var</em> = <em>var</em> + <em>step</em>
         if (<em>step</em> &gt;= 0 and <em>var</em> &gt; <em>limit</em>) or (<em>step</em> &lt; 0 and <em>var</em> &lt; <em>limit</em>) then
           break
         end
         local v = <em>var</em>
         <em>block</em>
       end
     end
</pre>

<p>
다음에 유의해야 한다.

<ul>

<li>
세 가지 제어 식 모두 단 한 번,
루프 시작 전에 평가한다.
모두 수를 내놓아야 한다.
</li>

<li>
<code><em>var</em></code>, <code><em>limit</em></code>, <code><em>step</em></code>은 보이지 않는 변수이다.
여기 나온 이름은 설명을 위한 것이다.
</li>

<li>
세 번째 식(step)이 없으면
step을 1로 한다.
</li>

<li>
<b>break</b>나 <b>goto</b>를 써서 <b>for</b> 루프를 빠져나갈 수 있다.
</li>

<li>
루프 변수 <code>v</code>는 루프 몸체에 지역인 변수이다.
루프 다음에 그 값이 필요하면
루프에서 나가기 전에 다른 변수에 할당하면 된다.
</li>

</ul>

<p>
일반형 <b>for</b> 문은 <em>반복자(iterator)</em>라는
함수를 기반으로 동작한다.
각 반복마다 반복자 함수를 호출해서 새 값을 만들어 내며,
그 새 값이 <b>nil</b>이면 멈춘다.
일반형 <b>for</b> 루프의 문법은 다음과 같다.

<pre>
	stat ::= <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b>
	namelist ::= Name {&lsquo;<b>,</b>&rsquo; Name}
</pre><p>
다음 <b>for</b> 문이

<pre>
     for <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> in <em>explist</em> do <em>block</em> end
</pre><p>
다음 코드와 동등하다.

<pre>
     do
       local <em>f</em>, <em>s</em>, <em>var</em> = <em>explist</em>
       while true do
         local <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> = <em>f</em>(<em>s</em>, <em>var</em>)
         if <em>var_1</em> == nil then break end
         <em>var</em> = <em>var_1</em>
         <em>block</em>
       end
     end
</pre><p>
다음에 유의해야 한다.

<ul>

<li>
<code><em>explist</em></code>를 단 한 번 평가한다.
그 결과는 <em>반복자</em> 함수,
<em>상태</em>,
그리고 <em>반복자 변수</em>의 초기값이다.
</li>

<li>
<code><em>f</em></code>, <code><em>s</em></code>, <code><em>var</em></code>은 보이지 않는 변수이다.
여기의 이름은 설명을 위한 것이다.
</li>

<li>
<b>break</b>를 써서 <b>for</b> 루프를 빠져나갈 수 있다.
</li>

<li>
루프 변수 <code><em>var_i</em></code>는 루프에 지역인 변수이다.
<b>for</b>가 끝난 후에 그 값을 쓸 수 없다.
그 값이 필요하면
루프에서 나가기 전에 다른 변수에 할당하면 된다.
</li>

</ul>




<h3>3.3.6 &ndash; <a name="3.3.6">함수 호출 문</a></h3><p>
부대 효과를 위해
함수 호출을 문으로 실행할 수 있다.

<pre>
	stat ::= functioncall
</pre><p>
이 경우 반환되는 값은 모두 버린다.
함수 호출을 <a href="#3.4.10">3.4.10절</a>에서 설명한다.





<h3>3.3.7 &ndash; <a name="3.3.7">지역 선언</a></h3><p>
블록 내 어디에서도 지역 변수를 선언할 수 있다.
선언에 초기 할당을 포함시킬 수 있다.

<pre>
	stat ::= <b>local</b> namelist [&lsquo;<b>=</b>&rsquo; explist]
</pre><p>
초기 할당이 있으면 의미론이
다중 할당과 같다. (<a href="#3.3.3">3.3.3절</a> 참고.)
그렇지 않으면 모든 변수가 <b>nil</b>로 초기화된다.


<p>
청크도 블록이므로 (<a href="#3.3.2">3.3.2절</a> 참고)
청크 안 명시적 블록 밖에서 지역 변수를 선언할 수 있다.


<p>
지역 변수 가시성 규칙을 <a href="#3.5">3.5절</a>에서 설명한다.







<h2>3.4 &ndash; <a name="3.4">식</a></h2>

<p>
루아의 기본 식은 다음과 같다.

<pre>
	exp ::= prefixexp
	exp ::= <b>nil</b> | <b>false</b> | <b>true</b>
	exp ::= Numeral
	exp ::= LiteralString
	exp ::= functiondef
	exp ::= tableconstructor
	exp ::= &lsquo;<b>...</b>&rsquo;
	exp ::= exp binop exp
	exp ::= unop exp
	prefixexp ::= var | functioncall | &lsquo;<b>(</b>&rsquo; exp &lsquo;<b>)</b>&rsquo;
</pre>

<p>
숫자와 리터럴 문자열을 <a href="#3.1">3.1절</a>에서 설명한다.
변수를 <a href="#3.2">3.2절</a>에서 설명한다.
함수 정의를 <a href="#3.4.11">3.4.11절</a>에서 설명한다.
함수 호출을 <a href="#3.4.10">3.4.10절</a>에서 설명한다.
테이블 생성자를 <a href="#3.4.9">3.4.9절</a>에서 설명한다.
점 세 개('<code>...</code>')로 표시하는 vararg 식은
vararg 함수 바로 안에서만 사용할 수 있다.
<a href="#3.4.11">3.4.11절</a>에서 설명한다.


<p>
이항 연산자는 산술 연산자(<a href="#3.4.1">3.4.1절</a>),
비트 연산자(<a href="#3.4.2">3.4.2절</a>),
관계 연산자(<a href="#3.4.4">3.4.4절</a>),
논리 연산자(<a href="#3.4.5">3.4.5절</a>),
접합 연산자(<a href="#3.4.6">3.4.6절</a>)로 이뤄진다.
단항 연산자는 단항 마이너스(<a href="#3.4.1">3.4.1절</a>),
단항 비트 NOT(<a href="#3.4.2">3.4.2절</a>),
단항 논리 <b>not</b>(<a href="#3.4.5">3.4.5절</a>),
단항 <em>길이 연산자</em>(<a href="#3.4.7">3.4.7절</a>)로 이뤄진다.


<p>
함수 호출과 vararg 식 모두 결과가 여러 값일 수 있다.
함수 호출을 문으로 쓰는 경우에는 (<a href="#3.3.6">3.3.6절</a> 참고)
그 반환 목록을 0개 항목으로 조정한다.
즉 반환된 값을 모두 폐기한다.
식 목록의 마지막 (또는 유일한) 항목으로 쓸 때는
(식을 괄호로 감싼 경우가 아니면)
어떤 조정도 하지 않는다.
그 외 모든 경우에서 루아는
첫 번째 값을 빼고 모두 폐기해서,
또는 값이 없으면 <b>nil</b>을 하나 추가해서
결과 목록을 1개 항목으로 조정한다.


<p>
몇 가지 예를 들면 다음과 같다.

<pre>
     f()                -- 결과 0개로 조정
     g(f(), x)          -- f()를 결과 1개로 조정
     g(x, f())          -- x에 더해 f()의 결과 모두를 g가 받음
     a,b,c = f(), x     -- f()를 결과 1개로 조정 (c는 nil을 받음)
     a,b = ...          -- a는 첫 번째 vararg 매개변수를 받고
                        -- b는 두 번째를 받음 (대응하는 vararg
                        -- 매개변수가 없으면 a와 b 모두 nil을
                        -- 받을 수 있음)
     
     a,b,c = x, f()     -- f()를 결과 2개로 조정
     a,b,c = f()        -- f()를 결과 3개로 조정
     return f()         -- f()의 결과 모두를 반환
     return ...         -- 받은 vararg 매개변수 모두를 반환
     return x,y,f()     -- x, y, 그리고 f()의 결과 모두를 반환
     {f()}              -- f()의 결과 모두로 리스트 생성
     {...}              -- vararg 매개변수 모두로 리스트 생성
     {f(), nil}         -- f()를 결과 1개로 조정
</pre>

<p>
괄호로 감싼 식은 항상 결과가 한 개 값이다.
즉, <code>(f(x,y,z))</code>는
<code>f</code>가 여러 값을 반환한다 해도
항상 한 개 값이다.
(<code>(f(x,y,z))</code>의 값은 <code>f</code>가 반환하는 첫 번째 값이다.
<code>f</code>가 아무 값도 반환하지 않으면 <b>nil</b>이다.)



<h3>3.4.1 &ndash; <a name="3.4.1">산술 연산자</a></h3><p>
루아에서 다음 산술 연산자를 지원한다.

<ul>
<li><b><code>+</code>: </b>덧셈</li>
<li><b><code>-</code>: </b>뺄셈</li>
<li><b><code>*</code>: </b>곱셈</li>
<li><b><code>/</code>: </b>실수 나눗셈</li>
<li><b><code>//</code>: </b>내림 나눗셈</li>
<li><b><code>%</code>: </b>모듈로</li>
<li><b><code>^</code>: </b>누승</li>
<li><b><code>-</code>: </b>단항 마이너스</li>
</ul>

<p>
누승과 실수 나눗셈을 제외하고
산술 연산의 동작 방식은 동일하다.
두 피연산자 모두 정수이면
정수 연산을 수행하고 결과가 정수이다.
그렇지 않고 두 피연산자가 수이거나
수로 변환할 수 있는 문자열이면
(<a href="#3.4.3">3.4.3절</a> 참고)
부동소수점수로 변환한다.
일반적인 부동소수점 산술 규칙(보통 IEEE 754 표준)에 따라
연산을 수행하고 결과가 부동소수점수이다.


<p>
누승과 실수 나눗셈(<code>/</code>)은
피연산자를 항상 부동소수점수로 변환하며
결과가 항상 부동소수점수이다.
누승에서는 ISO C 함수 <code>pow</code>를 사용하여
정수 아닌 지수도 가능하다.


<p>
내림 나눗셈(<code>//</code>)은
몫을 음의 무한대 쪽으로 내리는 나눗셈이다.
즉 피연산자들로 나눗셈 한 값의 바닥(floor)이다.


<p>
모듈로는
몫을 음의 무한대 쪽으로 내리는 나눗셈(내림 나눗셈)의
나머지로 정의한다.


<p>
정수 산술에서 넘침이 발생하는 경우 모든 연산에서
일반적인 2의 보수 산술 규칙에 따라
값을 <em>되돌린다</em>.
(다시 말해
수학적 결과의 모듈로 <em>2<sup>64</sup></em>과 같은
표현 가능한 유일한 정수를 반환한다.)



<h3>3.4.2 &ndash; <a name="3.4.2">비트 연산자</a></h3><p>
루아에서 다음 비트 연산자를 지원한다.

<ul>
<li><b><code>&amp;</code>: </b>비트 AND</li>
<li><b><code>&#124;</code>: </b>비트 OR</li>
<li><b><code>~</code>: </b>비트 배타적 OR</li>
<li><b><code>&gt;&gt;</code>: </b>오른쪽 시프트</li>
<li><b><code>&lt;&lt;</code>: </b>왼쪽 시프트</li>
<li><b><code>~</code>: </b>단항 비트 NOT</li>
</ul>

<p>
모든 비트 연산은 피연산자를 정수로 변환하여
(<a href="#3.4.3">3.4.3절</a> 참고)
그 정수의 비트 전체를 조작하며
결과가 정수이다.


<p>
오른쪽 시프트와 왼쪽 시프트 모두 비는 비트를 0으로 채운다.
변위가 음수이면 반대 방향으로 시프트 한다.
변위의 절대값이 정수의 비트 수와 같거나 그보다 크면
(모든 비트가 시프트 되므로)
결과가 0이다.





<h3>3.4.3 &ndash; <a name="3.4.3">타입 강제와 변환</a></h3><p>
루아에서는 일부 타입과 표현들 간에
런타임 자동 변환을 어느 정도 제공한다.
비트 연산자는 항상 실수 피연산자를 정수로 변환한다.
누승과 실수 나눗셈은
항상 정수 피연산자를 실수로 변환한다.
다른 모든 산술 연산은 정수와 실수가 섞인 수들에 적용하면
정수 피연산자를 실수로 변환한다.
이를 <em>일반 규칙</em>이라고 한다.
C API에서도 필요에 따라 정수를 실수로, 또는
실수를 정수로 변환한다.
그리고 문자열 접합에서는 문자열과 더불어
수를 인자로 받는다.


<p>
또한 수를 기대하는 곳에서는
문자열을 수로 변환한다.


<p>
정수에서 실수로 변환 시
정수 값을 실수로 정확히 표현할 수 있으면
그 실수 표현이 결과이다.
그렇지 않으면
표현 가능한 가장 가까운 위나 아래의 값으로
변환한다.
이 변환은 절대 실패하지 않는다.


<p>
실수에서 정수로 변환할 때는
실수를 정수로 정확히 표현할 수 있는지
(즉 실수가 정수인 값을 가지고 있고
그 값이 정수 표현 범위 내에 있는지)
확인한다.
그렇다면 그 정수 표현이 결과이다.
아니면 변환에 실패한다.


<p>
문자열에서 수로 변환할 때는
먼저 문자열을 그 구문과 루아 단어 분석기(lexer) 규칙에 따라
정수나 실수로 변환한다.
(문자열에 앞뒤 공백과 부호가 있을 수 있다.)
그렇게 나온 수(실수 또는 정수)를
그 맥락(가령 변환을 강제하는 연산)에서 요구하는
타입(실수 또는 정수)으로 변환한다.


<p>
문자열에서 수로 변환 시
소수점으로 마침표와 더불어
현재 로캘의 표시도 받아들인다.
(하지만 루아 단어 분석기는 마침표만 받아들인다.)


<p>
수에서 문자열로 변환할 때는
사람이 읽을 수 있는 명세 안 된 형식을 사용한다.
수가 문자열로 변환되는 방식을 완전히 제어하려면
string 라이브러리의 <code>format</code> 함수를 사용하면 된다.
(<a href="#pdf-string.format"><code>string.format</code></a> 참고.)





<h3>3.4.4 &ndash; <a name="3.4.4">관계 연산자</a></h3><p>
루아에서 다음 관계 연산자를 지원한다.

<ul>
<li><b><code>==</code>: </b>같음</li>
<li><b><code>~=</code>: </b>같지 않음</li>
<li><b><code>&lt;</code>: </b>작음</li>
<li><b><code>&gt;</code>: </b>큼</li>
<li><b><code>&lt;=</code>: </b>작거나 같음</li>
<li><b><code>&gt;=</code>: </b>크거나 같음</li>
</ul><p>
이 연산자들은 항상 <b>false</b> 또는 <b>true</b>를 내놓는다.


<p>
같음(<code>==</code>)에서는 먼저 피연산자 타입을 비교한다.
타입이 다르면 결과가 <b>false</b>이다.
그렇지 않으면 피연산자들의 값을 비교한다.
문자열은 자명한 방식으로 비교한다.
수는 같은 수학적 값을 나타내는 경우에 서로 같다.


<p>
테이블, userdata, 스레드는
참조로 비교한다.
즉, 두 객체는 동일 객체인 경우에만 서로 같다고 본다.
그래서 새 객체(테이블, userdata, 스레드)를 만들 때마다
그 새 객체는 이전의 모든 객체와 다르게 된다.
클로저는 참조가 같으면 항상 같다.
탐지 가능한 차이(상이한 동작, 상이한 정의)가 있는 클로저는
항상 서로 다르다.


<p>
"eq" 메타메소드를 이용하면 루아에서 테이블과 userdata를 비교하는 방식을
바꿀 수 있다. (<a href="#2.4">2.4절</a> 참고.)


<p>
같음 비교에서는 문자열을 수로, 또는 반대로 변환하지 않는다.
따라서 <code>"0"==0</code>를 평가하면 <b>false</b>이고,
<code>t[0]</code>과 <code>t["0"]</code>은
서로 다른 테이블 항목을 나타낸다.


<p>
연산자 <code>~=</code>는 정확하게 같음(<code>==</code>)의 반대이다.


<p>
순서 연산자의 동작 방식은 이렇다.
두 인자 모두 수이면
(하위 타입과 상관없이)
수학적 값에 따라 비교한다.
그렇지 않고 두 인자 모두 문자열이면
현재 로캘에 따라 그 값을 비교한다.
그 외 경우에는 루아에서 메타메소드 "lt"나 "le" 호출을 시도한다.
(<a href="#2.4">2.4절</a> 참고.)
비교 식 <code>a &gt; b</code>는 <code>b &lt; a</code>로 바뀌고
<code>a &gt;= b</code>는 <code>b &lt;= a</code>로 바뀐다.


<p>
IEEE 754 표준에 따라
NaN은 (스스로를 포함한) 어느 값보다
작지도, 같지도, 크지도 않다.





<h3>3.4.5 &ndash; <a name="3.4.5">논리 연산자</a></h3><p>
루아의 논리 연산자는
<b>and</b>, <b>or</b>, <b>not</b>이다.
제어 구조와 마찬가지로 (<a href="#3.3.4">3.3.4절</a> 참고)
논리 연산자에서는 <b>false</b>와 <b>nil</b>을 거짓으로 여기고
그 외는 모두 참으로 여긴다.


<p>
부정 연산자 <b>not</b>은 항상 <b>false</b> 또는 <b>true</b>를 반환한다.
논리곱 연산자 <b>and</b>는
첫 번째 인자의 값이 <b>false</b>나 <b>nil</b>이면 그 인자를 반환한다.
그렇지 않으면 <b>and</b>가 두 번째 인자를 반환한다.
논리합 연산자 <b>or</b>는
첫 번째 인자의 값이 <b>nil</b> 및 <b>false</b>와 다르면 그 인자를 반환한다.
그렇지 않으면 <b>or</b>가 두 번째 인자를 반환한다.
<b>and</b>와 <b>or</b> 모두에서 단락 평가 방식을 쓴다.
즉, 필요한 경우에만 두 번째 피연산자를 평가한다.
몇 가지 예를 들면 다음과 같다.

<pre>
     10 or 20            --&gt; 10
     10 or error()       --&gt; 10
     nil or "a"          --&gt; "a"
     nil and 10          --&gt; nil
     false and error()   --&gt; false
     false and nil       --&gt; false
     false or nil        --&gt; nil
     10 and 20           --&gt; 20
</pre><p>
(이 매뉴얼에서
<code>--&gt;</code>는 앞에 있는 식의 결과를 나타낸다.)





<h3>3.4.6 &ndash; <a name="3.4.6">접합</a></h3><p>
루아의 문자열 접합 연산자는
점 두 개('<code>..</code>')로 표시한다.
두 피연산자 모두 문자열이나 수이면
<a href="#3.4.3">3.4.3절</a>에서 기술하는 규칙에 따라
문자열로 변환한다.
그렇지 않으면 메타메소드 <code>__concat</code>을 호출한다.
(<a href="#2.4">2.4절</a> 참고.)





<h3>3.4.7 &ndash; <a name="3.4.7">길이 연산자</a></h3>

<p>
길이 연산자는 단항 접두 연산자 <code>#</code>로 표시한다.


<p>
문자열의 길이는 문자열의 바이트 수이다.
(즉, 각 문자가 한 바이트일 때
일반적인 문자열 길이와 의미가 같다.)


<p>
테이블에 길이 연산자를 적용하면
그 테이블의 경계를 반환한다.
테이블 <code>t</code>의 <em>경계(border)</em>는
다음 조건을 충족시키는 임의 자연수이다.

<pre>
     (border == 0 or t[border] ~= nil) and t[border + 1] == nil
</pre><p>
다시 말해
테이블에서 경계는 바로 다음에 nil 값이 오는
nil 아닌 값의 (자연수) 인덱스이다.
(인덱스 1이 nil이면 0이다.)


<p>
경계가 딱 한 개인 테이블을 <em>열(sequence)</em>이라고 한다.
예를 들어 테이블 <code>{10, 20, 30, 40, 50}</code>에는
경계(5)가 하나뿐이므로 열이다.
테이블 <code>{10, 20, 30, nil, 50}</code>에는
경계(3과 5)가 둘이므로 열이 아니다.
테이블 <code>{nil, 20, 30, nil, nil, 60, nil}</code>에는
경계(0, 3, 6)가 셋이므로 역시 열이 아니다.
테이블 <code>{}</code>는
경계가 0인 열이다.
참고로 자연수 아닌 키는
테이블이 열인지 여부에 영향을 주지 않는다.


<p>
<code>t</code>가 열일 때
<code>#t</code>는 그 유일한 경계를 반환한다.
그 값은 열의 길이라는 직관적 개념에 대응한다.
<code>t</code>가 열이 아닐 때
<code>#t</code>는 그 경계들 중 아무 값이나 반환할 수 있다.
(정확히 어느 값인지는
테이블 내부의 세부 표현 방식에 따라 달라지는데,
그 역시 테이블을 어떻게 채웠는지와
수 아닌 키들의 메모리 주소에 따라 달라질 수 있다.)


<p>
테이블 길이 계산의
최악 실행 시간이 <em>O(log n)</em>라고 보장된다.
여기서 <em>n</em>은 테이블에서 가장 큰 자연수 키이다.


<p>
프로그램에서 메타메소드 <code>__len</code>을 통해
문자열을 제외한 모든 값의 길이 연산자 동작을 바꿀 수 있다.
(<a href="#2.4">2.4절</a> 참고.)





<h3>3.4.8 &ndash; <a name="3.4.8">우선순위</a></h3><p>
루아의 연산자 우선순위는 아래 표를 따른다.
우선도가 높아지는 순서이다.

<pre>
     or
     and
     &lt;     &gt;     &lt;=    &gt;=    ~=    ==
     |
     ~
     &amp;
     &lt;&lt;    &gt;&gt;
     ..
     +     -
     *     /     //    %
     단항 연산자 (not   #     -     ~)
     ^
</pre><p>
언제나처럼
괄호를 써서 식의 우선순위를 바꿀 수 있다.
접합('<code>..</code>') 및 누승('<code>^</code>') 연산자는
우측부터 결합이다.
다른 이항 연산자는 모두 좌측부터 결합이다.





<h3>3.4.9 &ndash; <a name="3.4.9">테이블 생성자</a></h3><p>
테이블 생성자는 테이블을 만드는 식이다.
생성자를 평가할 때마다 새 테이블이 생긴다.
생성자를 이용해 빈 테이블을 만들 수도 있고
테이블을 만들면서 일부 필드를 초기화할 수도 있다.
생성자의 일반 문법은 다음과 같다.

<pre>
	tableconstructor ::= &lsquo;<b>{</b>&rsquo; [fieldlist] &lsquo;<b>}</b>&rsquo;
	fieldlist ::= field {fieldsep field} [fieldsep]
	field ::= &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; &lsquo;<b>=</b>&rsquo; exp | Name &lsquo;<b>=</b>&rsquo; exp | exp
	fieldsep ::= &lsquo;<b>,</b>&rsquo; | &lsquo;<b>;</b>&rsquo;
</pre>

<p>
<code>[exp1] = exp2</code> 형태의 각 필드는 새 테이블에
키가 <code>exp1</code>이고 값이 <code>exp2</code>인 항목을 추가한다.
<code>name = exp</code> 형태의 필드는 <code>["name"] = exp</code>와 동등하다.
그리고 <code>exp</code> 형태의 필드는 <code>[i] = exp</code>와 동등한데,
여기서 <code>i</code>는 1부터 시작하는 연속된 정수이다.
다른 형태의 필드들은 이 수에 영향을 주지 않는다.
예를 들어 다음은

<pre>
     a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
</pre><p>
다음과 동등하다.

<pre>
     do
       local t = {}
       t[f(1)] = g
       t[1] = "x"         -- 1번째 exp
       t[2] = "y"         -- 2번째 exp
       t.x = 1            -- t["x"] = 1
       t[3] = f(x)        -- 3번째 exp
       t[30] = 23
       t[4] = 45          -- 4번째 exp
       a = t
     end
</pre>

<p>
생성자 내 할당 순서는 규정되어 있지 않다.
(그 순서가 의미 있는 경우는 반복되는 키가 있을 때뿐일 것이다.)


<p>
목록의 마지막 필드가 <code>exp</code> 형태이고
그 식이 함수 호출이나 vararg 식인 경우에는
그 식이 반환하는 모든 값들이 차례로 리스트에 들어간다.
(<a href="#3.4.10">3.4.10절</a> 참고.)


<p>
필드 목록 끝에 선택적으로 구분자가 올 수 있는데,
그래서 자동 생성 코드가 편해진다.





<h3>3.4.10 &ndash; <a name="3.4.10">함수 호출</a></h3><p>
루아에서 함수 호출의 문법은 다음과 같다.

<pre>
	functioncall ::= prefixexp args
</pre><p>
함수 호출에서는
먼저 prefixexp와 args를 평가한다.
prefixexp의 값이 <em>function</em> 타입이면
주어진 인자들로 그 함수를 호출한다.
그렇지 않으면 prefixexp의 "call" 메타메소드를 호출한다.
prefixexp의 값을 첫 번째 매개변수로 하고
이어서 원래의 호출 인자들이 온다.
(<a href="#2.4">2.4절</a> 참고.)


<p>
다음 형태를 이용해 "메소드" 호출을 할 수 있다.

<pre>
	functioncall ::= prefixexp &lsquo;<b>:</b>&rsquo; Name args
</pre><p>
호출 식 <code>v:name(<em>args</em>)</code>는
<code>v.name(v,<em>args</em>)</code>에 대한 문법적 양념이다.
단, <code>v</code>를 한 번만 평가한다.


<p>
인자 문법은 다음과 같다.

<pre>
	args ::= &lsquo;<b>(</b>&rsquo; [explist] &lsquo;<b>)</b>&rsquo;
	args ::= tableconstructor
	args ::= LiteralString
</pre><p>
모든 인자 식을 호출 전에 평가한다.
<code>f{<em>fields</em>}</code> 형태 호출은
<code>f({<em>fields</em>})</code>에 대한 문법적 양념이다.
즉, 인자 목록이 새 테이블 한 개다.
<code>f'<em>string</em>'</code> 형태 호출은
(또는 <code>f"<em>string</em>"</code>이나 <code>f[[<em>string</em>]]</code>)는)
<code>f('<em>string</em>')</code>에 대한 문법적 양념이다.
즉, 인자 목록이 리터럴 문자열 한 개다.


<p>
<code>return <em>functioncall</em></code> 형태의 호출을
<em>꼬리 호출</em>이라고 한다.
루아는 <em>진정(proper) 꼬리 호출</em>(<em>진정 꼬리 재귀</em>)을
구현한다.
꼬리 호출에서는
피호출 함수가 호출측 함수의 스택 항목을 재사용한다.
따라서 프로그램에서 실행 가능한
중첩된 꼬리 호출 횟수에 아무 제한이 없다.
하지만 꼬리 호출은 호출측 함수에 대한 디버그 정보를 모두 지워 버린다.
참고로 특정 구문에서만,
즉 <b>return</b>의 인자가 함수 호출 하나뿐일 때만
꼬리 호출이 일어난다.
피호출 함수의 반환 결과를 호출측 함수가 그대로 반환하게
하는 구문이다.
따라서 다음 예는 꼬리 호출이 아니다.

<pre>
     return (f(x))        -- 결과를 1개로 조정함
     return 2 * f(x)
     return x, f(x)       -- 결과에 추가함
     f(x); return         -- 결과를 버림
     return x or f(x)     -- 결과를 1개로 조정함
</pre>




<h3>3.4.11 &ndash; <a name="3.4.11">함수 정의</a></h3>

<p>
함수 정의 문법은 다음과 같다.

<pre>
	functiondef ::= <b>function</b> funcbody
	funcbody ::= &lsquo;<b>(</b>&rsquo; [parlist] &lsquo;<b>)</b>&rsquo; block <b>end</b>
</pre>

<p>
다음 문법적 양념은 함수 정의를 간편하게 만들어 준다.

<pre>
	stat ::= <b>function</b> funcname funcbody
	stat ::= <b>local</b> <b>function</b> Name funcbody
	funcname ::= Name {&lsquo;<b>.</b>&rsquo; Name} [&lsquo;<b>:</b>&rsquo; Name]
</pre><p>
다음 문은

<pre>
     function f () <em>body</em> end
</pre><p>
다음으로 바뀐다.

<pre>
     f = function () <em>body</em> end
</pre><p>
다음 문은

<pre>
     function t.a.b.c.f () <em>body</em> end
</pre><p>
다음으로 바뀐다.

<pre>
     t.a.b.c.f = function () <em>body</em> end
</pre><p>
다음 문은

<pre>
     local function f () <em>body</em> end
</pre><p>
다음으로 바뀐다.

<pre>
     local f; f = function () <em>body</em> end
</pre><p>
다음으로 바뀌는 것이 아니다.

<pre>
     local f = function () <em>body</em> end
</pre><p>
(함수 몸체에 <code>f</code>에 대한 참조가 있을 때만
차이가 생긴다.)


<p>
함수 정의는 실행 가능한 식이고
그 값은 <em>function</em> 타입이다.
루아에서 청크를 사전 컴파일 할 때
함수 몸체들도 모두 사전 컴파일 한다.
그러고 나서 루아에서 그 함수 정의를 실행할 때마다
함수를 <em>인스턴스화</em> (즉 <em>마무리(close)</em>) 한다.
그 함수 인스턴스가 (즉 <em>클로저(closure)</em>가)
식의 최종 값이다.


<p>
매개변수는 인자 값으로 초기화 된
지역 변수처럼 동작한다.

<pre>
	parlist ::= namelist [&lsquo;<b>,</b>&rsquo; &lsquo;<b>...</b>&rsquo;] | &lsquo;<b>...</b>&rsquo;
</pre><p>
함수 호출 시
인자 목록을 매개변수 목록 길이에 맞게 조정한다.
단, 매개변수 목록 끝에 점 세 개('<code>...</code>')가 있는
<em>vararg 함수</em>에서는 아니다.
vararg 함수에서는 인자 목록을 조정하지 않는다.
초과 인자를 모두 모아서
역시 점 세 개로 쓰는 <em>vararg 식</em>을 통해
함수에 제공한다.
그 식의 값은 실제 초과 인자 전체의 목록인데,
다중 결과 함수에서와 비슷하다.
vararg 식을 다른 식 내에서나
식 목록 중간에서 사용하는 경우에는
그 vararg 식의 반환 목록이 한 개 항목으로 조정된다.
식 목록의 마지막 항목으로 사용하는 경우에는
(그 마지막 식을 괄호로 감싸지 않는 한)
어떤 조정도 이뤄지지 않는다.


<p>
예를 들어 다음 정의가 있다고 하자.

<pre>
     function f(a, b) end
     function g(a, b, ...) end
     function r() return 1,2,3 end
</pre><p>
그러면 인자에서 매개변수로, 또 vararg 식으로 다음과 같이
사상된다.

<pre>
     호출             매개변수
     
     f(3)             a=3, b=nil
     f(3, 4)          a=3, b=4
     f(3, 4, 5)       a=3, b=4
     f(r(), 10)       a=1, b=10
     f(r())           a=1, b=2
     
     g(3)             a=3, b=nil, ... --&gt;  (nothing)
     g(3, 4)          a=3, b=4,   ... --&gt;  (nothing)
     g(3, 4, 5, 8)    a=3, b=4,   ... --&gt;  5  8
     g(5, r())        a=5, b=1,   ... --&gt;  2  3
</pre>

<p>
<b>return</b> 문을 이용해 결과를 반환한다. (<a href="#3.3.4">3.3.4절</a> 참고.)
제어가 <b>return</b> 문을 만나지 않고
함수 끝에 도달하는 경우에는
함수가 아무 결과도 반환하지 않는다.


<p>

함수가 반환할 수 있는 값 개수에 대해
시스템마다 다른 제한이 있다.
그 제한치가 1000보다 크다는 것이 보장된다.


<p>
<em>콜론</em> 문법을 이용해
<em>메소드</em>,
즉 암묵적인 추가 매개변수 <code>self</code>가 있는 함수를
정의한다.
그래서 다음 문은

<pre>
     function t.a.b.c:f (<em>params</em>) <em>body</em> end
</pre><p>
다음에 대한 문법적 양념이다.

<pre>
     t.a.b.c.f = function (self, <em>params</em>) <em>body</em> end
</pre>






<h2>3.5 &ndash; <a name="3.5">가시성 규칙</a></h2>

<p>

루아는 문법적(lexical) 스코프 사용 언어이다.
지역 변수의 유효 범위는 선언 다음의 첫 번째 문에서 시작해서
그 선언을 포함하는 가장 안쪽 블록의 void 아닌 마지막 문까지 이어진다.
다음 예를 보자.

<pre>
     x = 10                -- 전역 변수
     do                    -- 새 블록
       local x = x         -- 값 10으로 새 'x'
       print(x)            --&gt; 10
       x = x+1
       do                  -- 또 다른 블록
         local x = x+1     -- 또 다른 'x'
         print(x)          --&gt; 12
       end
       print(x)            --&gt; 11
     end
     print(x)              --&gt; 10  (전역 변수)
</pre>

<p>
<code>local x = x</code> 같은 선언을 보면,
아직은 선언하려는 새 <code>x</code>의 유효 범위 안이 아니므로
두 번째 <code>x</code>가 바깥 변수를 가리키게 된다.


<p>
문법적 스코프 규칙 때문에
지역 변수의 유효 범위 내에 정의된 함수에서
그 변수에 자유롭게 접근할 수 있다.
안쪽 함수에서 쓰는 지역 변수를
그 함수 안에서
<em>upvalue</em> 내지 <em>외부 지역 변수</em>라고 한다.


<p>
<b>local</b> 문을 실행할 때마다
새 지역 변수를 정의하게 된다.
다음 예를 보자.

<pre>
     a = {}
     local x = 20
     for i=1,10 do
       local y = 0
       a[i] = function () y=y+1; return x+y end
     end
</pre><p>
루프에서 클로저 열 개를
(즉 익명 함수 인스턴스 열 개를)
만든다.
모든 클로저가 같은 <code>x</code>를 공유하면서
각기 다른 <code>y</code> 변수를 사용한다.





<h1>4 &ndash; <a name="4">응용 프로그램 인터페이스</a></h1>

<p>

이 절에서는 루아의 C API를 설명한다.
호스트 프로그램에서 루아와 의사소통하는 데 이 C 함수들을 사용할 수 있다.
모든 API 함수와 관련 타입 및 상수들이
헤더 파일 <a name="pdf-lua.h"><code>lua.h</code></a>에 선언되어 있다.


<p>
API의 어느 항목이든
"함수"라는 용어를 쓸 때도 사실은 매크로일 수 있다.
따로 언급하지 않으면
그런 매크로들에서는 각 인자를 정확히 한 번만 사용하며
(언제나 루아 상태인 첫 번째 인자는 제외)
그래서 숨겨진 부대 효과를 전혀 만들어 내지 않는다.


<p>
여러 C 라이브러리들처럼
루아 API 함수에서도 인자의 유효성이나 무모순성을 검사하지 않는다.
하지만 매크로 <a name="pdf-LUA_USE_APICHECK"><code>LUA_USE_APICHECK</code></a>를 정의하고
루아를 컴파일 하면 이 동작 방식을 바꿀 수 있다.


<p>
루아 라이브러리는 완전하게 재진입 가능하다.
즉, 전역 변수가 전혀 없다.
필요한 정보는 모두 <em>루아 상태</em>라고 하는
동적 구조 안에 둔다.


<p>
각 루아 상태에는 한 개 이상의 스레드가 있는데,
각 스레드는 독립적인 협력적 실행 흐름에 대응한다.
<a href="#lua_State"><code>lua_State</code></a> 타입은 (그 이름과 달리) 스레드를 가리킨다.
(그 스레드를 통해서 스레드에 연계된 루아 상태를
간접적으로 가리키기도 한다.)


<p>
라이브러리의 모든 함수에 첫 번째 인자로 스레드 포인터를 주어야 한다.
단, 무에서부터 루아 상태를 만들어서
새 상태의 <em>주 스레드</em>에 대한 포인터를 반환하는
<a href="#lua_newstate"><code>lua_newstate</code></a>는 예외이다.



<h2>4.1 &ndash; <a name="4.1">스택</a></h2>

<p>
<em>가상 스택</em>을 이용해 루아와 C가 값을 주고받는다.
이 스택의 각 항목이 루아 값(<b>nil</b>, 수, 문자열 등)을 나타낸다.
API 함수에서는 건네받은 루아 상태 매개변수를 통해
이 스택에 접근할 수 있다.


<p>
루아에서 C를 호출할 때마다 피호출 함수가 새 스택을 받는다.
이 스택은 이전의 스택들과, 그리고 아직 동작 중인 C 함수의 스택들과 독립적이다.
처음에 이 스택은 C 함수를 위한 인자를 담는다.
C 함수에서 여기에 임시 루아 값을 저장할 수 있으며
호출자에게 반환할 결과를 여기 집어넣어야 한다.
(<a href="#lua_CFunction"><code>lua_CFunction</code></a> 참고.)


<p>
편의를 위해
API의 대다수 질의 연산에서는 스택 접근 규제를 엄격하게 하지 않는다.
<em>인덱스</em>를 이용하면
스택 내 어느 항목이든 참조할 수 있다.
양수 인덱스는 절대적 스택 위치를 나타내고
(1에서 시작),
음수 인덱스는 스택 상단을 기준으로 한 위치를 나타낸다.
구체적으로 스택에 <em>n</em>개 항목이 있을 때
인덱스 1은 첫 번째 항목을
(즉 스택에 가장 먼저 넣은 항목을) 나타내고
인덱스 <em>n</em>이 마지막 항목을 나타낸다.
인덱스 -1 역시 마지막 항목을
(즉 상단의 항목을) 나타내고
인덱스 <em>-n</em>이 첫 번째 항목을 나타낸다.





<h2>4.2 &ndash; <a name="4.2">스택 크기</a></h2>

<p>
루아 API를 다룰 때
무모순성을 보장할 책임은 사용자에게 있다.
특히 <em>스택 오버플로우 제어를 책임져야 한다</em>.
함수 <a href="#lua_checkstack"><code>lua_checkstack</code></a>을 사용해서
스택에 새 항목을 집어넣을 공간이 있도록 만들 수 있다.


<p>
루아에서 C를 부를 때는 항상
스택에 최소 <a name="pdf-LUA_MINSTACK"><code>LUA_MINSTACK</code></a>개의
추가 슬롯이 있도록 보장한다.
<code>LUA_MINSTACK</code>은 20으로 정의되어 있으며,
따라서 코드에서 루프를 돌며 스택에 항목을 넣는 경우가 아니면
일반적으로 스택 공간에 신경 쓸 필요가 없다.


<p>
결과 개수가 정해져 있지 않은 루아 함수를 호출할 때
(<a href="#lua_call"><code>lua_call</code></a> 참고)
스택에 전체 결과를 위한 공간이 있도록 루아가 보장하지만
그 이상의 공간은 보장하지 않는다.
따라서 그런 호출 후 스택에 뭔가를 집어넣기 전에는
<a href="#lua_checkstack"><code>lua_checkstack</code></a>을 써야 할 것이다.





<h2>4.3 &ndash; <a name="4.3">유효 인덱스와 허용 인덱스</a></h2>

<p>
API에서 스택 인덱스를 받는 함수는 모두
<em>유효 인덱스</em> 또는 <em>허용 인덱스</em>로만 동작한다.


<p>
<em>유효 인덱스</em>란 변경 가능한 루아 값을
저장하고 있는 위치를 가리키는 인덱스이다.
1번에서 스택 상단까지 인덱스(<code>1 &le; abs(index) &le; top</code>)와 더불어

스택에 있지 않지만
C 코드에서 접근 가능한 어떤 위치들을 나타내는
<em>가상 인덱스(pseudo-index)</em>로 이뤄진다.
레지스트리(<a href="#4.5">4.5절</a>)와
C 함수의 upvalue(<a href="#4.4">4.4절</a>)에
접근할 때 가상 인덱스를 쓴다.


<p>
명확한 변경 가능 위치가 필요한 것이 아니라
값이 필요할 뿐인 함수(가령 질의 함수)는
허용 인덱스로 호출할 수 있다.
<em>허용 인덱스</em>는 어떤 유효 인덱스일 수도 있고
스택에 할당된 공간 내의 스택 상단 너머
어떤 양수 인덱스일 수도 있다.
즉, 스택 크기까지의 인덱스이다.
(0은 절대 허용 인덱스가 아니다.)
따로 언급한 경우를 제외하고
API의 함수들은 허용 인덱스로 동작한다.


<p>
허용 인덱스는 스택 값 질의 시
스택 상단을 확인하는 추가 검사를 피하게 해 준다.
예를 들어 C 함수에서 세 번째 인자를 질의할 때
세 번째 인자가 존재하는지 여부,
즉 3이 유효 인덱스인지 여부를
확인해 볼 필요가 없다.


<p>
허용 인덱스로 호출 가능한 함수들에서
유효 인덱스 아닌 위치는
가상 타입 <a name="pdf-LUA_TNONE"><code>LUA_TNONE</code></a>인 값을 담고 있는
것처럼 처리한다.
그 값은 nil 값처럼 작동한다.





<h2>4.4 &ndash; <a name="4.4">C 클로저</a></h2>

<p>
C 함수를 생성할 때
어떤 값들을 연계해서
<em>C 클로저</em>를 만드는 것이 가능하다.
(<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a> 참고.)
그 값들을 <em>upvalue</em>라고 하며
호출된 함수에서 언제나 접근 가능하다.


<p>
C 함수 호출 시
그 upvalue들은 언제나 특정 가상 인덱스에 위치하게 된다.
그 가상 인덱스를
매크로 <a href="#lua_upvalueindex"><code>lua_upvalueindex</code></a>로 만든다.
어떤 함수에 연계된 첫 번째 upvalue가
<code>lua_upvalueindex(1)</code>에 있는 식이다.
<code>lua_upvalueindex(<em>n</em>)</code> 접근에서
<em>n</em>이 현재 함수의 upvalue 개수보다 크면
(하지만 클로저 upvalue 최대 개수에 1을 더한 256보다는 크지 않으면)
허용이지만 유효하지 않은 인덱스가 나온다.





<h2>4.5 &ndash; <a name="4.5">레지스트리</a></h2>

<p>
루아에는 <em>레지스트리</em>라는
미리 정의된 테이블이 있다.
C 코드에서 이 테이블에
원하는 어떤 루아 값이든 저장할 수 있다.
레지스트리 테이블은 항상 가상 인덱스
<a name="pdf-LUA_REGISTRYINDEX"><code>LUA_REGISTRYINDEX</code></a>에 위치한다.
어느 C 라이브러리에서든 이 테이블에 값을 저장할 수 있되,
충돌을 피하기 위해
다른 라이브러리와 다른 키를
고르도록 신경을 써야 한다.
보통 라이브러리 이름을 담은 문자열이나
코드 내 C 객체 주소인 light userdata,
또는 코드에서 생성한 루아 객체를 키로 쓰면 된다.
변수 이름에서처럼
밑줄로 시작하고 이어서 대문자 글자들이 오는 문자열 키는
루아 자체 용도로 예약되어 있다.


<p>
레지스트리 내의 정수 키는
참조 메커니즘(<a href="#luaL_ref"><code>luaL_ref</code></a>)과
몇 가지 사전 정의 값들에 쓴다.
따라서 다른 용도에 정수 키를 사용해서는 안 된다.


<p>
루아 상태를 새로 생성하면
그 레지스트리에는 몇 가지 미리 정의된 값들이 있다.
이 사전 정의 값들의 인덱스는
<code>lua.h</code>에 상수로 정의되어 있는 정수 키이다.
다음 상수가 정의되어 있다.

<ul>
<li><b><a name="pdf-LUA_RIDX_MAINTHREAD"><code>LUA_RIDX_MAINTHREAD</code></a>: </b>
레지스트리의 이 인덱스에는
상태의 주 스레드가 있다.
(주 스레드는 상태와 함께 생성된 스레드이다.)
</li>

<li><b><a name="pdf-LUA_RIDX_GLOBALS"><code>LUA_RIDX_GLOBALS</code></a>: </b>
레지스트리의 이 인덱스에는
전역 환경이 있다.
</li>
</ul>




<h2>4.6 &ndash; <a name="4.6">C에서의 오류 처리</a></h2>

<p>
내부적으로 루아는 C의 <code>longjmp</code> 기제를 이용해 오류를 처리한다.
(루아를 C++로 컴파일 하면 예외를 쓴다.
소스 코드에서 <code>LUAI_THROW</code>로 검색하면 자세한 내용이 나온다.)
루아가 (메모리 할당 오류나 타입 오류 같은) 오류를 만나면
오류를 <em>제기한다(raise)</em>.
즉, 긴 점프를 한다.
<em>보호 환경</em>에서 <code>setjmp</code>를 사용해
복원점을 지정한다.
그러면 오류 시 가장 최근 활성화시킨 복원점으로 점프 한다.


<p>
C 함수 내에서는 <a href="#lua_error"><code>lua_error</code></a>를 호출해서 오류를 제기할 수 있다.


<p>
API 내 함수 대부분이 메모리 할당 오류 등으로 인해
오류를 제기할 수 있다.
각 함수별 설명에 오류를 제기할 수 있는지 여부가
표시되어 있다.


<p>
보호 환경 밖에서 오류가 생기면
루아에서 <em>패닉 함수</em>를 호출하고서
(<a href="#lua_atpanic"><code>lua_atpanic</code></a> 참고)
<code>abort</code>를 호출해서 호스트 응용을 끝낸다.
끝내는 것을 막으려면 패닉 함수에서
(이를테면 루아 밖의 별도 복원점으로 긴 점프를 해서)
절대 반환하지 않으면 된다.


<p>
이름에서 알 수 있듯
패닉 함수는
최후의 수단이다.
따라서 프로그램에서 쓰지 않는 게 좋다.
일반적으로
루아에서 루아 상태를 가지고 C 함수를 호출할 때는
이미 보호 상태일 것이기에
C 함수에서 그 루아 상태에 하고 싶은 대로 할 수 있다.
하지만 C 코드에서 다른 루아 상태에
(가령 그 함수에 대한 루아 매개변수,
레지스트리에 저장된 루아 상태,
<a href="#lua_newthread"><code>lua_newthread</code></a>의 결과에)
작업을 하는 경우에는
오류를 제기할 수 없는 API 호출에만
그 상태를 사용해야 한다.


<p>
패닉 함수는 메시지 핸들러인 것처럼 돈다. (<a href="#2.3">2.3절</a> 참고.)
특히 스택 상단에 오류 객체가 있다.
하지만 스택 공간에 대해선 어떤 보장도 없다.
패닉 함수에서 스택에 뭔가를 집어넣으려면
먼저 가용 공간을 확인해야 한다. (<a href="#4.2">4.2절</a> 참고.)





<h2>4.7 &ndash; <a name="4.7">C에서의 양보 처리</a></h2>

<p>
코루틴 양보에 루아 내부적으로 C의 <code>longjmp</code> 기제를 이용한다.
그래서 C 함수 <code>foo</code>가 어떤 API 함수를 호출하고
그 API 함수에서
(직접적으로, 또는 양보하는 다른 함수를 호출해서 간접적으로)
양보하면
더 이상 루아에서 <code>foo</code>로 반환할 수 없다.
<code>longjmp</code> 때문에 C 스택에서 프레임이 없어지기 때문이다.


<p>
이런 식의 문제를 피하기 위해
API 호출을 거쳐서 양보하려고 할 때는 루아에서 항상 오류를 제기한다.
단, 세 함수 <a href="#lua_yieldk"><code>lua_yieldk</code></a>, <a href="#lua_callk"><code>lua_callk</code></a>, <a href="#lua_pcallk"><code>lua_pcallk</code></a>가 예외인데,
이 함수들은 양보 후 실행을 이어 나갈
<em>속행 함수</em>를 (<code>k</code>라는 매개변수로) 받는다.


<p>
속행을 설명하기 위해 용어를 좀 정리하겠다.
루아에서 호출하는 C 함수가 있는데,
이를 <em>시초 함수</em>라고 할 것이다.
이 시초 함수가 C API의 그 세 함수들 중 하나를 호출하는데,
이를 <em>피호출 함수</em>라고 할 것이다.
피호출 함수에서 현재 스레드를 양보한다.
(피호출 함수가 <a href="#lua_yieldk"><code>lua_yieldk</code></a>이거나,
피호출 함수가 <a href="#lua_callk"><code>lua_callk</code></a>나 <a href="#lua_pcallk"><code>lua_pcallk</code></a>이고 거기서 호출하는 함수에서 양보를 하는 경우이다.)


<p>
피호출 함수 실행 중에 동작 스레드가 양보를 한다고 하자.
그 스레드가 재개된 후 피호출 함수 실행이 마침내 끝나게 된다.
하지만
피호출 함수가 시초 함수로 반환할 수가 없다.
양보 때문에 C 스택에서 그 함수의 프레임이 사라졌기 때문이다.
그래서 대신 피호출 함수 인자로 받았던
<em>속행 함수</em>를 루아에서 호출한다.
이름에서 알 수 있듯
속행 함수는 시초 함수의 일을 이어서 하게 된다.


<p>
설명을 위해 다음과 같은 함수를 생각해 보자.

<pre>
     int original_function (lua_State *L) {
       ...     /* code 1 */
       status = lua_pcall(L, n, m, h);  /* 루아 호출 */
       ...     /* code 2 */
     }
</pre><p>
<a href="#lua_pcall"><code>lua_pcall</code></a>이 실행할 루아 코드에서
양보를 할 수 있게 하고 싶다.
그러면 먼저 함수를 다음처럼 고쳐 쓴다.

<pre>
     int k (lua_State *L, int status, lua_KContext ctx) {
       ...  /* code 2 */
     }
     
     int original_function (lua_State *L) {
       ...     /* code 1 */
       return k(L, lua_pcall(L, n, m, h), ctx);
     }
</pre><p>
위 코드에서
새 함수 <code>k</code>가
(<a href="#lua_KFunction"><code>lua_KFunction</code></a> 타입) <em>속행 함수</em>이다.
시초 함수에서
<a href="#lua_pcall"><code>lua_pcall</code></a> 호출 후
하던 작업을 모두 하게 된다.
다음으로, <a href="#lua_pcall"><code>lua_pcall</code></a>이 실행하는 루아 코드가
어떻게든 (오류나 양보로) 중단되면
루아에서 <code>k</code>를 호출해야 한다고 알려 주어야 한다.
따라서 <a href="#lua_pcall"><code>lua_pcall</code></a>을 <a href="#lua_pcallk"><code>lua_pcallk</code></a>로 바꿔서
코드를 다음처럼 고쳐 준다.

<pre>
     int original_function (lua_State *L) {
       ...     /* code 1 */
       return k(L, lua_pcallk(L, n, m, h, ctx2, k), ctx1);
     }
</pre><p>
속행 함수를 외부에서 명시적으로도 호출하는 것에 유의하라.
루아에서는 필요할 때만, 즉 오류가 발생했거나 양보 후 재개하는 경우에만
속행을 호출하게 된다.
호출된 함수가 한번도 양보하지 않고 정상적으로 반환하면
<a href="#lua_pcallk"><code>lua_pcallk</code></a>도 (그리고 <a href="#lua_callk"><code>lua_callk</code></a>도) 정상적으로 반환하게 된다.
(물론 그 경우에 속행을 호출하지 않고
시초 함수 내에서 같은 작업을 직접 할 수도 있다.)


<p>
속행 함수에는
루아 상태 말고도 매개변수가 두 개 더 있는데,
호출의 최종 상태, 그리고
<a href="#lua_pcallk"><code>lua_pcallk</code></a>에 원래 전달됐던
문맥 값(<code>ctx</code>)이다.
(루아에서는 이 문맥 값을 사용하지 않고 시초 함수에서 속행 함수로
전달하기만 한다.)
<a href="#lua_pcallk"><code>lua_pcallk</code></a> 경우에
상태 값은 <a href="#lua_pcallk"><code>lua_pcallk</code></a>가 반환했을 값과 같되,
양보 후 실행되는 것이면
(<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>가 아니라)
<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>이다.
<a href="#lua_yieldk"><code>lua_yieldk</code></a>와 <a href="#lua_callk"><code>lua_callk</code></a> 경우에
루아가 속행 호출 시 상태가 항상 <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>이다.
(이 두 함수에서는
오류 경우에 루아가 속행을 호출하지 않는다.
오류 처리를 하는 함수가 아니기 때문이다.)
마찬가지로 <a href="#lua_callk"><code>lua_callk</code></a> 사용 시
<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>를 상태로 해서
속행 함수를 호출하게 될 것이다.
(<a href="#lua_yieldk"><code>lua_yieldk</code></a> 경우에는
속행 함수를 직접 호출하는 것에 별 의미가 없다.
<a href="#lua_yieldk"><code>lua_yieldk</code></a>가 보통은 반환하지 않기 때문이다.)


<p>
루아는 속행 함수를 시초 함수인 것처럼 다룬다.
속행 함수가 시초 함수와 같은 루아 스택을 받으며,
그 스택은 피호출 함수가 반환했을 때와 같은 상태이다.
(예를 들어
<a href="#lua_callk"><code>lua_callk</code></a> 후에는
스택에서 함수와 인자들이 제거되고 호출 결과들로 교체된다.)
또한 upvalue들이 같다.
그리고 무엇을 반환하든 루아에서 이를
시초 함수의 반환처럼 처리한다.





<h2>4.8 &ndash; <a name="4.8">함수와 타입</a></h2>

<p>
여기선 C API의 모든 함수와 타입을 알파벳 순서로 나열한다.
각 함수에는 오른편과 같은 표지가 있다.
<span class="apii">[-o, +p, <em>x</em>]</span>


<p>
첫 번째 필드 <code>o</code>는
함수가 스택에서 항목을 몇 개나 꺼내는가이다.
두 번째 필드 <code>p</code>는
함수가 스택에 항목을 몇 개나 집어넣는가이다.
(어느 함수든 항상 인자를 꺼낸 뒤에 결과를 집어넣는다.)
<code>x|y</code> 형태인 필드는 함수가 상황에 따라
<code>x</code>개 또는 <code>y</code>개 항목을
집어넣을 (꺼낼) 수 있다는 뜻이다.
물음표 '<code>?</code>'는
인자만 봐서는 함수가 몇 개 항목을
꺼내는지/집어넣는지 알 수 없다는 뜻이다.
(이를테면 스택 내용에 따라 달라질 수 있다.)
세 번째 필드 <code>x</code>는
함수가 오류를 제기할 수 있는지를 알려 준다.
'<code>-</code>'는 함수가 절대 오류를 제기하지 않는다는 뜻이다.
'<code>m</code>'은 함수가 메모리 부족 오류나
<code>__gc</code> 메타메소드 실행 중 오류를 제기할 수 있다는 뜻이다.
'<code>e</code>'는 함수가 어떤 오류도 제기할 수 있다는
(직접 또는 메타메소드를 통해 임의의 루아 코드를 실행할 수 있다는)
뜻이다.
'<code>v</code>'는 함수가 의도적으로 오류를 제기할 수 있다는 뜻이다.



<hr><h3><a name="lua_absindex"><code>lua_absindex</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_absindex (lua_State *L, int idx);</pre>

<p>
허용 인덱스 <code>idx</code>를
동등한 절대 인덱스로
(즉 스택 상단 위치와 무관한 인덱스로)
변환한다.





<hr><h3><a name="lua_Alloc"><code>lua_Alloc</code></a></h3>
<pre>typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);</pre>

<p>
루아 상태에서 쓰는 메모리 할당 함수의 타입.
<code>realloc</code>과 비슷하되 완전히 같지는 않은 기능성을
할당자 함수가 제공해야 한다.
인자는
<a href="#lua_newstate"><code>lua_newstate</code></a>에 전달한 불투명 포인터인 <code>ud</code>,
할당/재할당/해제하려는 블록에 대한 포인터인 <code>ptr</code>,
블록의 원래 크기 내지 할당하려는 것에 대한 어떤 코드인 <code>osize</code>,
블록의 새 크기인 <code>nsize</code>이다.


<p>
<code>ptr</code>이 <code>NULL</code>이 아닐 때
<code>osize</code>는 <code>ptr</code>이 가리키는 블록의 크기이다.
즉, 할당이나 재할당 때 주었던 크기이다.


<p>
<code>ptr</code>이 <code>NULL</code>일 때
<code>osize</code>는 루아에서 할당하려는 객체의 종류를 나타낸다.
<code>osize</code>가
<a href="#pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>, <a href="#pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>, <a href="#pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>,
<a href="#pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>, <a href="#pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a>
중 하나이면 루아에서 그 타입의 새 객체를 만들려는 것이다.
<code>osize</code>가 다른 어떤 값이면
루아에서 다른 뭔가를 위해 메모리를 할당하려는 것이다.


<p>
루아에서 할당자 함수에 대해 다음 동작 방식을 가정한다.


<p>
<code>nsize</code>가 0일 때
할당자가 <code>free</code>처럼 동작해야 하며
<code>NULL</code>을 반환한다.


<p>
<code>nsize</code>가 0이 아닐 때
할당자가 <code>realloc</code>처럼 동작해야 한다.
요청을 만족시킬 수 없는 경우, 그리고 그 경우에만
할당자가 <code>NULL</code>을 반환한다.
루아에서는 <code>osize &gt;= nsize</code>일 때
할당자가 절대 실패하지 않는다고 가정한다.


<p>
다음은 간단한 할당자 함수 구현이다.
보조 라이브러리의 <a href="#luaL_newstate"><code>luaL_newstate</code></a>에서 쓰는 것이다.

<pre>
     static void *l_alloc (void *ud, void *ptr, size_t osize,
                                                size_t nsize) {
       (void)ud;  (void)osize;  /* 사용 안 함 */
       if (nsize == 0) {
         free(ptr);
         return NULL;
       }
       else
         return realloc(ptr, nsize);
     }
</pre><p>
참고로 <code>free(NULL)</code>에 아무 효과가 없으며
<code>realloc(NULL,size)</code>이 <code>malloc(size)</code>과 동등함을
표준 C에서 보장한다.
위 코드에서는 블록을 줄일 때 <code>realloc</code>이 실패하지 않는다고 가정한다.
(표준 C에서 그런 동작 방식을 보장하지는 않지만 안전한 가정인 것 같다.)





<hr><h3><a name="lua_arith"><code>lua_arith</code></a></h3><p>
<span class="apii">[-(2|1), +1, <em>e</em>]</span>
<pre>void lua_arith (lua_State *L, int op);</pre>

<p>
스택 상단에 있는 두 값에 대해
(반수/NOT이면 한 값에 대해)
산술 연산이나 비트 연산을 수행한다.
상단 쪽 값이 두 번째 피연산자이며,
값들을 꺼내고 연산 결과를 집어넣는다.
대응하는 루아 연산자의 처리 방식을 따른다.
(즉 메타메소드를 호출할 수도 있다.)


<p>
<code>op</code> 값은 다음 상수들 중 하나여야 한다.

<ul>

<li><b><a name="pdf-LUA_OPADD"><code>LUA_OPADD</code></a>: </b> 덧셈 수행 (<code>+</code>)</li>
<li><b><a name="pdf-LUA_OPSUB"><code>LUA_OPSUB</code></a>: </b> 뺄셈 수행 (<code>-</code>)</li>
<li><b><a name="pdf-LUA_OPMUL"><code>LUA_OPMUL</code></a>: </b> 곱셈 수행 (<code>*</code>)</li>
<li><b><a name="pdf-LUA_OPDIV"><code>LUA_OPDIV</code></a>: </b> 실수 나눗셈 수행 (<code>/</code>)</li>
<li><b><a name="pdf-LUA_OPIDIV"><code>LUA_OPIDIV</code></a>: </b> 내림 나눗셈 수행 (<code>//</code>)</li>
<li><b><a name="pdf-LUA_OPMOD"><code>LUA_OPMOD</code></a>: </b> 모듈로 수행 (<code>%</code>)</li>
<li><b><a name="pdf-LUA_OPPOW"><code>LUA_OPPOW</code></a>: </b> 누승 수행 (<code>^</code>)</li>
<li><b><a name="pdf-LUA_OPUNM"><code>LUA_OPUNM</code></a>: </b> 반수 수행 (단항 <code>-</code>)</li>
<li><b><a name="pdf-LUA_OPBNOT"><code>LUA_OPBNOT</code></a>: </b> 비트 NOT 수행 (<code>~</code>)</li>
<li><b><a name="pdf-LUA_OPBAND"><code>LUA_OPBAND</code></a>: </b> 비트 AND 수행 (<code>&amp;</code>)</li>
<li><b><a name="pdf-LUA_OPBOR"><code>LUA_OPBOR</code></a>: </b> 비트 OR 수행 (<code>|</code>)</li>
<li><b><a name="pdf-LUA_OPBXOR"><code>LUA_OPBXOR</code></a>: </b> 비트 배타적 OR 수행 (<code>~</code>)</li>
<li><b><a name="pdf-LUA_OPSHL"><code>LUA_OPSHL</code></a>: </b> 왼쪽 시프트 수행 (<code>&lt;&lt;</code>)</li>
<li><b><a name="pdf-LUA_OPSHR"><code>LUA_OPSHR</code></a>: </b> 오른쪽 시프트 수행 (<code>&gt;&gt;</code>)</li>

</ul>




<hr><h3><a name="lua_atpanic"><code>lua_atpanic</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);</pre>

<p>
새 패닉 함수를 설정하고 이전 함수를 반환한다. (<a href="#4.6">4.6절</a> 참고.)





<hr><h3><a name="lua_call"><code>lua_call</code></a></h3><p>
<span class="apii">[-(nargs+1), +nresults, <em>e</em>]</span>
<pre>void lua_call (lua_State *L, int nargs, int nresults);</pre>

<p>
함수를 호출한다.


<p>
함수를 호출하려면 규약을 따라야 한다.
먼저 호출할 함수를 스택에 집어넣는다.
다음으로 함수 인자들을 정순서로 집어넣는다.
즉, 첫 번째 인자를 첫 번째로 집어넣는다.
마지막으로 <a href="#lua_call"><code>lua_call</code></a>을 호출한다.
<code>nargs</code>는 스택에 집어넣은 인자 개수이다.
함수가 불릴 때
인자와 함수 값 모두가 스택에서 빠진다.
그리고 함수가 반환할 때 함수 결과가 스택에 들어간다.
그 결과는 <code>nresults</code>개로 조정된다.
단, <code>nresults</code>가 <a name="pdf-LUA_MULTRET"><code>LUA_MULTRET</code></a>이면
함수 결과 모두가 들어간다.
반환되는 값들이 스택 공간에 들어갈 수 있도록 루아에서 처리를 해 준다.
하지만 그 이상의 어떤 스택 공간도 보장하지 않는다.
함수 결과들은 정순서로 스택에 들어간다.
(첫 번째 결과를 첫 번째로 집어넣는다.)
그래서 호출 후에 스택 상단에 마지막 결과가 있게 된다.


<p>
피호출 함수 내에서 오류가 발생하면
(<code>longjmp</code>로) 위로 전파된다.


<p>
이어지는 예는 다음 루아 코드와 동등한 일을 호스트 프로그램에서
어떻게 할 수 있는지 보여 준다.

<pre>
     a = f("how", t.x, 14)
</pre><p>
다음은 C 코드이다.

<pre>
     lua_getglobal(L, "f");                            /* 호출할 함수 */
     lua_pushliteral(L, "how");                         /* 1번째 인자 */
     lua_getglobal(L, "t");                       /* 인덱싱 할 테이블 */
     lua_getfield(L, -1, "x");      /* t.x 결과 집어넣기 (2번째 인자) */
     lua_remove(L, -2);                          /* 스택에서 't' 제거 */
     lua_pushinteger(L, 14);                            /* 3번째 인자 */
     lua_call(L, 3, 1);             /* 3개 인자와 1개 결과로 'f' 호출 */
     lua_setglobal(L, "a");                          /* 전역 'a' 설정 */
</pre><p>
참고로 위 코드는 <em>균형이 맞는다</em>.
즉, 마지막에 스택이 처음 구성으로 돌아간다.
이렇게 하는 것은 좋은 프로그래밍 습관이다.





<hr><h3><a name="lua_callk"><code>lua_callk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +nresults, <em>e</em>]</span>
<pre>void lua_callk (lua_State *L,
                int nargs,
                int nresults,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
이 함수는 정확히 <a href="#lua_call"><code>lua_call</code></a>처럼 동작하되
피호출 함수에서 양보를 할 수 있다. (<a href="#4.7">4.7절</a> 참고.)





<hr><h3><a name="lua_CFunction"><code>lua_CFunction</code></a></h3>
<pre>typedef int (*lua_CFunction) (lua_State *L);</pre>

<p>
C 함수 타입.


<p>
C 함수가 루아와 올바로 의사소통하려면
매개변수 및 결과 전달 방식을 규정하는
규약을 따라야 한다.
C 함수가 루아로부터 인자를 받을 때는
스택에서 정순서로 (첫 번째 인자를 첫 번째로 집어넣기) 받는다.
그래서 함수 시작 때
<code>lua_gettop(L)</code>을 호출하면 함수가 받은 인자 개수를 반환한다.
첫 번째 인자가 (있다면) 1번 인덱스에 있고
마지막 인자가 <code>lua_gettop(L)</code>번 인덱스에 있다.
C 함수에서 루아로 값을 반환할 때는
정순서로 (첫 번째 결과를 첫 번째로 집어넣기) 스택에 집어넣고
결과 개수를 반환하면 된다.
스택에 결과 아래에 있는 다른 값들은
루아에서 적절히 폐기한다.
루아 함수처럼 루아가 호출하는 C 함수도
여러 개 결과를 반환할 수 있다.


<p>
예를 들어 다음 함수는 개수가 가변적인 수 인자들을 받아서
평균과 합을 반환한다.

<pre>
     static int foo (lua_State *L) {
       int n = lua_gettop(L);    /* 인자 개수 */
       lua_Number sum = 0.0;
       int i;
       for (i = 1; i &lt;= n; i++) {
         if (!lua_isnumber(L, i)) {
           lua_pushliteral(L, "incorrect argument");
           lua_error(L);
         }
         sum += lua_tonumber(L, i);
       }
       lua_pushnumber(L, sum/n);        /* 첫 번째 결과 */
       lua_pushnumber(L, sum);          /* 두 번째 결과 */
       return 2;                           /* 결과 개수 */
     }
</pre>




<hr><h3><a name="lua_checkstack"><code>lua_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_checkstack (lua_State *L, int n);</pre>

<p>
스택에 최소 <code>n</code>개의 추가 슬롯이 있도록 만든다.
(즉, 스택에 <code>n</code>개까지 값들을 안전하게 집어넣을 수 있게 한다.)
스택이 고정된 최대 크기(보통 최소 수천 항목)보다 커지게 되거나
추가 공간을 위한 메모리를 할당할 수 없어서
요청을 만족시킬 수 없으면 거짓을 반환한다.
이 함수는 절대 스택을 줄이지 않는다.
즉, 스택에 추가 슬롯 공간이 이미 있으면
변경 없이 둔다.





<hr><h3><a name="lua_close"><code>lua_close</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_close (lua_State *L);</pre>

<p>
지정한 루아 상태의 모든 객체들을
(해당하는 쓰레기 수집 메타메소드가 있으면 호출하여) 없애고
그 상태에서 쓰는 모든 동적 메모리를 해제한다.
여러 플랫폼에서는 이 함수를 호출할 필요가 없을 수도 있는데,
호스트 프로그램이 끝날 때 모든 자원이 알아서 해제되기 때문이다.
반면 여러 상태를 만드는
데몬이나 웹 서버 같은 장기 동작 프로그램에서는
상태가 필요 없게 되자마자 닫아야 할 것이다.





<hr><h3><a name="lua_compare"><code>lua_compare</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_compare (lua_State *L, int index1, int index2, int op);</pre>

<p>
두 루아 값을 비교한다.
인덱스 <code>index1</code>의 값이 인덱스 <code>index2</code>의 값과 비교하여
<code>op</code>를 만족시키는 경우 1을 반환한다.
비교 시 대응하는 루아 연산자의 처리 방식을 따른다.
(즉 메타메소드를 호출할 수도 있다.)
그렇지 않으면 0을 반환한다.
인덱스가 하나라도 유효하지 않을 때에도 0을 반환한다.


<p>
<code>op</code> 값은 다음 상수들 중 하나여야 한다.

<ul>

<li><b><a name="pdf-LUA_OPEQ"><code>LUA_OPEQ</code></a>: </b> 같은지 비교 (<code>==</code>)</li>
<li><b><a name="pdf-LUA_OPLT"><code>LUA_OPLT</code></a>: </b> 작은지 비교 (<code>&lt;</code>)</li>
<li><b><a name="pdf-LUA_OPLE"><code>LUA_OPLE</code></a>: </b> 작거나 같은지 비교 (<code>&lt;=</code>)</li>

</ul>




<hr><h3><a name="lua_concat"><code>lua_concat</code></a></h3><p>
<span class="apii">[-n, +1, <em>e</em>]</span>
<pre>void lua_concat (lua_State *L, int n);</pre>

<p>
스택 상단의 <code>n</code>개 값들을 접합하고,
그 값들을 꺼내고, 결과를 상단에 둔다.
<code>n</code>이 1이면 결과는 스택의 그 한 개 값이다.
(즉, 함수가 아무것도 하지 않는다.)
<code>n</code>이 0이면 결과는 빈 문자열이다.
루아의 일반적 처리 방식에 따라 접합을 수행한다.
(<a href="#3.4.6">3.4.6절</a> 참고.)





<hr><h3><a name="lua_copy"><code>lua_copy</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_copy (lua_State *L, int fromidx, int toidx);</pre>

<p>
인덱스 <code>fromidx</code>의 항목을
유효 인덱스 <code>toidx</code>로 복사하여
그 위치의 값을 교체한다.
다른 위치의 값들은 영향을 받지 않는다.





<hr><h3><a name="lua_createtable"><code>lua_createtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void lua_createtable (lua_State *L, int narr, int nrec);</pre>

<p>
빈 테이블을 새로 만들어서 스택에 집어넣는다.
매개변수 <code>narr</code>은
테이블에 수열로 얼마나 많은 항목이 있을지에 대한 힌트이다.
매개변수 <code>nrec</code>는
테이블에 기타 항목들이 얼마나 많이 있을지에 대한 힌트이다.
루아에서 이 힌트를 이용해 새 테이블에 메모리를 미리 할당해 둘 수도 있다.
테이블에 항목이 몇 개일지 미리 안다면
이 사전 할당이 성능에 도움이 된다.
그렇지 않다면 함수 <a href="#lua_newtable"><code>lua_newtable</code></a>을 쓸 수 있다.





<hr><h3><a name="lua_dump"><code>lua_dump</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_dump (lua_State *L,
                        lua_Writer writer,
                        void *data,
                        int strip);</pre>

<p>
함수를 바이너리 청크 형태로 덤프 한다.
스택 상단의 루아 함수를 받아서
바이너리 청크를 만들어 내는데,
그 청크를 다시 적재하면
덤프 한 것과 동등한 함수가 된다.
<a href="#lua_dump"><code>lua_dump</code></a>에서
청크 부분들을 만들면서
<code>data</code>로 함수 <code>writer</code>를 호출해
쓰기를 한다.


<p>
<code>strip</code>이 참이면
공간 절약을 위해
함수에 대한 디버그 정보를
이진 표현에 모두 포함시키지 않을 수도 있다.


<p>
마지막 쓰기 함수 호출이 반환한 오류 코드가 반환 값이다.
0은 오류 없음을 뜻한다.


<p>
이 함수는 스택에서 루아 함수를 꺼내지 않는다.





<hr><h3><a name="lua_error"><code>lua_error</code></a></h3><p>
<span class="apii">[-1, +0, <em>v</em>]</span>
<pre>int lua_error (lua_State *L);</pre>

<p>
스택 상단의 값을 오류 객체로 사용해
루아 오류를 발생시킨다.
이 함수는 긴 점프를 하기 때문에
절대 반환하지 않는다.
(<a href="#luaL_error"><code>luaL_error</code></a> 참고.)





<hr><h3><a name="lua_gc"><code>lua_gc</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>int lua_gc (lua_State *L, int what, int data);</pre>

<p>
쓰레기 수집기를 제어한다.


<p>
이 함수는 매개변수 <code>what</code>의 값에 따라
여러 가지 작업을 수행한다.

<ul>

<li><b><code>LUA_GCSTOP</code>: </b>
쓰레기 수집기를 멈춘다.
</li>

<li><b><code>LUA_GCRESTART</code>: </b>
쓰레기 수집기를 재시작한다.
</li>

<li><b><code>LUA_GCCOLLECT</code>: </b>
쓰레기 수집 주기 한 번을 수행한다.
</li>

<li><b><code>LUA_GCCOUNT</code>: </b>
루아에서 현재 사용 중인 메모리의 (KB 단위) 양을 반환한다.
</li>

<li><b><code>LUA_GCCOUNTB</code>: </b>
루아에서 현재 사용 중인 메모리의 바이트 양을 1024로 나눈 나머지를 반환한다.
</li>

<li><b><code>LUA_GCSTEP</code>: </b>
쓰레기 수집의 점진적 단계 한 번을 수행한다.
</li>

<li><b><code>LUA_GCSETPAUSE</code>: </b>
<code>data</code>를 수집기의 <em>휴지 시간</em>(<a href="#2.5">2.5절</a>)
새 값으로 설정하고
이전 휴지 시간 값을 반환한다.
</li>

<li><b><code>LUA_GCSETSTEPMUL</code>: </b>
<code>data</code>를 수집기의 <em>단계 승수</em>(<a href="#2.5">2.5절</a>)
새 값으로 설정하고
이전 단계 승수 값을 반환한다.
</li>

<li><b><code>LUA_GCISRUNNING</code>: </b>
수집기가 동작 중인지를 (즉 중단되지 않았는지를) 알려 주는 불리언을 반환한다.
</li>

</ul>

<p>
이 옵션들에 대한 더 자세한 내용은
<a href="#pdf-collectgarbage"><code>collectgarbage</code></a>를 보라.





<hr><h3><a name="lua_getallocf"><code>lua_getallocf</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Alloc lua_getallocf (lua_State *L, void **ud);</pre>

<p>
지정한 상태의 메모리 할당 함수를 반환한다.
<code>ud</code>가 <code>NULL</code>이 아니면
메모리 할당자 함수 설정 때 루아에 주었던 불투명 포인터를
<code>*ud</code>에 저장한다.





<hr><h3><a name="lua_getfield"><code>lua_getfield</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_getfield (lua_State *L, int index, const char *k);</pre>

<p>
값 <code>t[k]</code>를 스택에 집어넣는다.
<code>t</code>는 지정한 인덱스에 있는 값이다.
루아 내에서처럼 이 함수가 "index" 이벤트에 대한
메타메소드를 유발할 수 있다.
(<a href="#2.4">2.4절</a> 참고.)


<p>
집어넣은 값의 타입을 반환한다.





<hr><h3><a name="lua_getextraspace"><code>lua_getextraspace</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_getextraspace (lua_State *L);</pre>

<p>
해당 루아 상태에 연계된
가외 메모리 영역에 대한 포인터를 반환한다.
응용에서 이 영역을 임의 용도에 쓸 수 있다.
루아에서는 이 영역을 사용하지 않는다.


<p>
신규 스레드마다 주 스레드의 영역을 복사해서
이 영역을 초기화 한다.


<p>
기본적으로 이 영역의 크기는 void 포인터만큼이다.
하지만 이 영역을 다른 크기로 해서 루아를 재컴파일 할 수 있다.
(<code>luaconf.h</code>의 <code>LUA_EXTRASPACE</code> 참고.)





<hr><h3><a name="lua_getglobal"><code>lua_getglobal</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_getglobal (lua_State *L, const char *name);</pre>

<p>
전역 <code>name</code>의 값을 스택에 집어넣는다.
그 값의 타입을 반환한다.





<hr><h3><a name="lua_geti"><code>lua_geti</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_geti (lua_State *L, int index, lua_Integer i);</pre>

<p>
값 <code>t[i]</code>를 스택에 집어넣는다.
<code>t</code>는 지정한 인덱스에 있는 값이다.
루아 내에서처럼 이 함수가 "index" 이벤트에 대한
메타메소드를 유발할 수 있다.
(<a href="#2.4">2.4절</a> 참고.)


<p>
집어넣은 값의 타입을 반환한다.





<hr><h3><a name="lua_getmetatable"><code>lua_getmetatable</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>int lua_getmetatable (lua_State *L, int index);</pre>

<p>
지정한 인덱스에 있는 값에 메타테이블이 있으면
그 메타테이블을 스택에 집어넣고 1을 반환한다.
그렇지 않으면
함수가 0을 반환하고 스택에 아무것도 집어넣지 않는다.





<hr><h3><a name="lua_gettable"><code>lua_gettable</code></a></h3><p>
<span class="apii">[-1, +1, <em>e</em>]</span>
<pre>int lua_gettable (lua_State *L, int index);</pre>

<p>
값 <code>t[k]</code>를 스택에 집어넣는다.
<code>t</code>는 지정한 인덱스에 있는 값이고
<code>k</code>는 스택 상단에 있는 값이다.


<p>
이 함수는 스택에서 키를 꺼내고
그 자리에 결과 값을 집어넣는다.
루아 내에서처럼 이 함수가 "index" 이벤트에 대한
메타메소드를 유발할 수 있다.
(<a href="#2.4">2.4절</a> 참고.)


<p>
집어넣은 값의 타입을 반환한다.





<hr><h3><a name="lua_gettop"><code>lua_gettop</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gettop (lua_State *L);</pre>

<p>
스택 상단 항목의 인덱스를 반환한다.
인덱스가 1부터 시작하므로
그 결과는 스택 내 항목 수와 같다.
특히 0은 빈 스택을 뜻한다.





<hr><h3><a name="lua_getuservalue"><code>lua_getuservalue</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_getuservalue (lua_State *L, int index);</pre>

<p>
지정한 인덱스에 있는 full userdata에 연계된 루아 값을
스택에 집어넣는다.


<p>
집어넣은 값의 타입을 반환한다.





<hr><h3><a name="lua_insert"><code>lua_insert</code></a></h3><p>
<span class="apii">[-1, +1, &ndash;]</span>
<pre>void lua_insert (lua_State *L, int index);</pre>

<p>
상단 항목을 지정한 유효 인덱스로 옮기고
그 인덱스 위의 항목들을 빈 공간으로 밀어 올린다.
가상 인덱스로 이 함수를 호출할 수 없다.
가상 인덱스는 실제 스택 위치가 아니기 때문이다.





<hr><h3><a name="lua_Integer"><code>lua_Integer</code></a></h3>
<pre>typedef ... lua_Integer;</pre>

<p>
루아 정수 타입.


<p>
기본적으로 이 타입은 <code>long long</code>(보통 64비트 2의 보수 정수)이다.
하지만 <code>long</code>이나 <code>int</code>(보통 32비트 2의 보수 정수)로 바꿀 수 있다.
(<code>luaconf.h</code>의 <code>LUA_INT_TYPE</code> 참고.)


<p>
그 타입에 맞는 최솟값과 최댓값으로
상수 <a name="pdf-LUA_MININTEGER"><code>LUA_MININTEGER</code></a>와 <a name="pdf-LUA_MAXINTEGER"><code>LUA_MAXINTEGER</code></a>를 루아에서 정의하고 있기도 하다.





<hr><h3><a name="lua_isboolean"><code>lua_isboolean</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isboolean (lua_State *L, int index);</pre>

<p>
지정한 인덱스에 있는 값이 불리언이면 1을 반환하고
아니면 0을 반환한다.





<hr><h3><a name="lua_iscfunction"><code>lua_iscfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_iscfunction (lua_State *L, int index);</pre>

<p>
지정한 인덱스에 있는 값이 C 함수이면 1을 반환하고
아니면 0을 반환한다.





<hr><h3><a name="lua_isfunction"><code>lua_isfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isfunction (lua_State *L, int index);</pre>

<p>
지정한 인덱스에 있는 값이 (C 또는 루아) 함수이면 1을 반환하고
아니면 0을 반환한다.





<hr><h3><a name="lua_isinteger"><code>lua_isinteger</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isinteger (lua_State *L, int index);</pre>

<p>
지정한 인덱스에 있는 값이 정수이면
(즉 값이 수이고 정수로 표현되어 있으면) 1을 반환하고
아니면 0을 반환한다.





<hr><h3><a name="lua_islightuserdata"><code>lua_islightuserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_islightuserdata (lua_State *L, int index);</pre>

<p>
지정한 인덱스에 있는 값이 light userdata이면 1을 반환하고
아니면 0을 반환한다.





<hr><h3><a name="lua_isnil"><code>lua_isnil</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnil (lua_State *L, int index);</pre>

<p>
지정한 인덱스에 있는 값이 <b>nil</b>이면 1을 반환하고
아니면 0을 반환한다.





<hr><h3><a name="lua_isnone"><code>lua_isnone</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnone (lua_State *L, int index);</pre>

<p>
지정한 인덱스가 유효하지 않으면 1을 반환하고
아니면 0을 반환한다.





<hr><h3><a name="lua_isnoneornil"><code>lua_isnoneornil</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnoneornil (lua_State *L, int index);</pre>

<p>
지정한 인덱스가 유효하지 않거나
그 인덱스에 있는 값이 <b>nil</b>이면 1을 반환하고
아니면 0을 반환한다.





<hr><h3><a name="lua_isnumber"><code>lua_isnumber</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnumber (lua_State *L, int index);</pre>

<p>
지정한 인덱스에 있는 값이 수이거나
수로 변환 가능한 문자열이면 1을 반환하고
아니면 0을 반환한다.





<hr><h3><a name="lua_isstring"><code>lua_isstring</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isstring (lua_State *L, int index);</pre>

<p>
지정한 인덱스에 있는 값이 문자열이거나
(언제나 문자열로 변환 가능한) 수이면 1을 반환하고
아니면 0을 반환한다.





<hr><h3><a name="lua_istable"><code>lua_istable</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_istable (lua_State *L, int index);</pre>

<p>
지정한 인덱스에 있는 값이 테이블이면 1을 반환하고
아니면 0을 반환한다.





<hr><h3><a name="lua_isthread"><code>lua_isthread</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isthread (lua_State *L, int index);</pre>

<p>
지정한 인덱스에 있는 값이 스레드이면 1을 반환하고
아니면 0을 반환한다.





<hr><h3><a name="lua_isuserdata"><code>lua_isuserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isuserdata (lua_State *L, int index);</pre>

<p>
지정한 인덱스에 있는 값이 (full 또는 light) userdata이면 1을 반환하고
아니면 0을 반환한다.





<hr><h3><a name="lua_isyieldable"><code>lua_isyieldable</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isyieldable (lua_State *L);</pre>

<p>
지정한 코루틴이 양보할 수 있으면 1을 반환하고
아니면 0을 반환한다.





<hr><h3><a name="lua_KContext"><code>lua_KContext</code></a></h3>
<pre>typedef ... lua_KContext;</pre>

<p>
속행 함수 문맥을 위한 타입.
수 타입이어야 한다.
<code>intptr_t</code>가 사용 가능하면
<code>intptr_t</code>로 이 타입이 정의되어 있으며,
그래서 포인터도 저장할 수 있다.
그렇지 않으면 <code>ptrdiff_t</code>로 정의되어 있다.





<hr><h3><a name="lua_KFunction"><code>lua_KFunction</code></a></h3>
<pre>typedef int (*lua_KFunction) (lua_State *L, int status, lua_KContext ctx);</pre>

<p>
속행 함수 타입. (<a href="#4.7">4.7절</a> 참고.)





<hr><h3><a name="lua_len"><code>lua_len</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_len (lua_State *L, int index);</pre>

<p>
지정한 인덱스에 있는 값의 길이를 반환한다.
루아의 '<code>#</code>' 연산자(<a href="#3.4.7">3.4.7절</a>)와 동등하며
"length" 이벤트에 대한 메타메소드를 유발할 수 있다.
(<a href="#2.4">2.4절</a> 참고.)
결과를 스택에 집어넣는다.





<hr><h3><a name="lua_load"><code>lua_load</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_load (lua_State *L,
              lua_Reader reader,
              void *data,
              const char *chunkname,
              const char *mode);</pre>

<p>
루아 청크를 적재하고 실행은 하지 않는다.
오류가 없으면 <code>lua_load</code>에서
청크를 루아 함수로 컴파일 하여
스택 상단에 집어넣는다.
그렇지 않으면 오류 메시지를 집어넣는다.


<p>
<code>lua_load</code>의 반환 값은 다음과 같다.

<ul>

<li><b><a href="#pdf-LUA_OK"><code>LUA_OK</code></a>: </b> 오류 없음</li>

<li><b><a name="pdf-LUA_ERRSYNTAX"><code>LUA_ERRSYNTAX</code></a>: </b>
사전 컴파일 중 구문 오류</li>

<li><b><a href="#pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>: </b>
메모리 할당 오류 (메모리 부족)</li>

<li><b><a href="#pdf-LUA_ERRGCMM"><code>LUA_ERRGCMM</code></a>: </b>
<code>__gc</code> 메타메소드 실행 중 오류.
(이 오류는 적재하려는 청크와 아무 관련이 없다.
쓰레기 수집기가 만들어 내는 오류이다.)
</li>

</ul>

<p>
<code>lua_load</code> 함수는 사용자가 제공한 <code>reader</code> 함수를 사용해
청크를 읽어 들인다. (<a href="#lua_Reader"><code>lua_Reader</code></a> 참고.)
<code>data</code> 인자는 읽기 함수에게 전달하는 불투명한 값이다.


<p>
<code>chunkname</code> 인자는 청크에 이름을 준다.
오류 메시지와 디버그 정보(<a href="#4.9">4.9절</a>)에 쓰인다.


<p>
청크가 텍스트인지 바이너리인지 <code>lua_load</code>에서 자동으로 탐지하여
그에 맞게 적재한다. (<code>luac</code> 프로그램 참고.)
문자열 <code>mode</code>는 <a href="#pdf-load"><code>load</code></a> 함수에서처럼 동작하며,
그에 더해서 <code>NULL</code> 값이 문자열 "<code>bt</code>"와 동등하다.


<p>
<code>lua_load</code> 내부적으로 스택을 사용한다.
따라서 읽기 함수에서 반환할 때는 항상
스택이 변경 없는 상태여야 한다.


<p>
결과로 나오는 함수에 upvalue가 있는 경우
레지스트리(<a href="#4.5">4.5절</a>)의 <code>LUA_RIDX_GLOBALS</code> 인덱스에 저장된
전역 환경의 값을 첫 번째 upvalue에 설정한다.
메인 청크를 적재할 때는
그 upvalue가 <code>_ENV</code> 변수가 된다. (<a href="#2.2">2.2절</a> 참고.)
다른 upvalue들은 <b>nil</b>로 초기화 된다.





<hr><h3><a name="lua_newstate"><code>lua_newstate</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *lua_newstate (lua_Alloc f, void *ud);</pre>

<p>
새로운 독립적 상태에서 도는 새 스레드를 만든다.
스레드나 상태를 만들 수 없으면 (메모리 부족) <code>NULL</code>을 반환한다.
인자 <code>f</code>는 할당자 함수이다.
루아에서 이 상태를 위한 모든 메모리 할당이 그 함수를 통해 이뤄진다.
(<a href="#lua_Alloc"><code>lua_Alloc</code></a> 참고.)
두 번째 인자인 <code>ud</code>는 불투명 포인터이며
할당자 호출 때마다 전달된다.





<hr><h3><a name="lua_newtable"><code>lua_newtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void lua_newtable (lua_State *L);</pre>

<p>
빈 테이블을 새로 만들어서 스택에 집어넣는다.
<code>lua_createtable(L, 0, 0)</code>과 동등하다.





<hr><h3><a name="lua_newthread"><code>lua_newthread</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>lua_State *lua_newthread (lua_State *L);</pre>

<p>
스레드를 새로 만들어서 스택에 집어넣고
그 새 스레드를 나타내는 <a href="#lua_State"><code>lua_State</code></a> 포인터를 반환한다.
이 함수가 반환하는 새 스레드는 원래 스레드와 전역 환경은 공유하지만
독립적인 실행 스택이 있다.


<p>
스레드를 닫거나 없애는 명시적 함수가 없다.
여느 루아 객체와 마찬가지로 스레드는 쓰레기 수집의 대상이다.





<hr><h3><a name="lua_newuserdata"><code>lua_newuserdata</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void *lua_newuserdata (lua_State *L, size_t size);</pre>

<p>
이 함수는 지정한 크기로 메모리 블록을 새로 할당해서
그 블록 주소로 새 full userdata를 스택에 집어넣고
그 주소를 반환한다.
호스트 프로그램에서 그 메모리를 마음대로 사용할 수 있다.





<hr><h3><a name="lua_next"><code>lua_next</code></a></h3><p>
<span class="apii">[-1, +(2|0), <em>e</em>]</span>
<pre>int lua_next (lua_State *L, int index);</pre>

<p>
스택에서 키를 꺼내고
지정한 인덱스에 있는 테이블에서 가져온 키&ndash;값 쌍을
(지정한 키 "다음"에 있는 쌍을) 스택에 집어넣는다.
테이블에 항목이 더 없으면
<a href="#lua_next"><code>lua_next</code></a>가 0을 반환한다.
(그리고 아무것도 집어넣지 않는다.)


<p>
보통 순회는 다음 같은 형태이다.

<pre>
     /* 스택 인덱스 't'에 테이블 있음 */
     lua_pushnil(L);  /* 첫 번째 키 */
     while (lua_next(L, t) != 0) {
       /* '키'(인덱스 -2)와 '값'(인덱스 -1) 사용 */
       printf("%s - %s\n",
              lua_typename(L, lua_type(L, -2)),
              lua_typename(L, lua_type(L, -1)));
       /* '값' 제거. '키'는 다음 반복을 위해 유지 */
       lua_pop(L, 1);
     }
</pre>

<p>
테이블을 순회하는 동안에
키가 확실히 문자열임을 아는 경우가 아니면
키에 바로 <a href="#lua_tolstring"><code>lua_tolstring</code></a>을 호출해선 안 된다.
<a href="#lua_tolstring"><code>lua_tolstring</code></a>이
지정한 인덱스에 있는 값을 바꿀 수도 있기 때문에
다음 <a href="#lua_next"><code>lua_next</code></a> 호출에
혼란을 줄 수 있다.


<p>
테이블 순회 중 변경에 대한 주의 사항은
함수 <a href="#pdf-next"><code>next</code></a>를 보라.





<hr><h3><a name="lua_Number"><code>lua_Number</code></a></h3>
<pre>typedef ... lua_Number;</pre>

<p>
루아 실수 타입.


<p>
기본적으로 이 타입은 <code>double</code>이다.
하지만 단정밀도 <code>float</code>이나 <code>long double</code>로 바꿀 수 있다.
(<code>luaconf.h</code>의 <code>LUA_FLOAT_TYPE</code> 참고.)





<hr><h3><a name="lua_numbertointeger"><code>lua_numbertointeger</code></a></h3>
<pre>int lua_numbertointeger (lua_Number n, lua_Integer *p);</pre>

<p>
루아 실수를 루아 정수로 변환한다.
이 매크로에서는 <code>n</code>이 정수인 값을 가지고 있다고 가정한다.
그 값이 루아 정수 범위 내에 있으면
정수로 변환하여 <code>*p</code>에 할당한다.
그리고 변환에 성공했는지를 나타내는 불리언을 결과로 내놓는다.
(참고로 그 범위 검사를 이 매크로 없이 제대로 하는 것은
올림/내림 때문에 까다로울 수 있다.)


<p>
이 매크로에서 인자를 여러 번 평가할 수도 있다.





<hr><h3><a name="lua_pcall"><code>lua_pcall</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), &ndash;]</span>
<pre>int lua_pcall (lua_State *L, int nargs, int nresults, int msgh);</pre>

<p>
보호 모드로 함수를 호출한다.


<p>
<code>nargs</code>와 <code>nresults</code>의 의미는
<a href="#lua_call"><code>lua_call</code></a>과 같다.
호출 중에 오류가 없으면
<a href="#lua_pcall"><code>lua_pcall</code></a>은 정확히 <a href="#lua_call"><code>lua_call</code></a>처럼 동작한다.
하지만 오류가 있으면
<a href="#lua_pcall"><code>lua_pcall</code></a>이 오류를 잡아서
스택에 값 하나(오류 객체)를 집어넣고
오류 코드를 반환한다.
<a href="#lua_call"><code>lua_call</code></a>처럼
<a href="#lua_pcall"><code>lua_pcall</code></a>이 항상
함수와 그 인자들을 스택에서 제거한다.


<p>
<code>msgh</code>가 0이면
스택으로 반환된 오류 객체가
정확히 원래의 오류 객체이다.
그렇지 않으면 <code>msgh</code>는
<em>메시지 핸들러</em>의 스택 인덱스이다.
(이 인덱스는 가상 인덱스일 수 없다.)
런타임 오류가 발생하면
오류 객체를 가지고 그 함수를 호출하며
그 반환 값이
<a href="#lua_pcall"><code>lua_pcall</code></a>이
스택으로 반환하는 객체가 된다.


<p>
보통은 오류 객체에 스택 트레이스백 같은 디버그 정보를 추가하는 데
메시지 핸들러를 쓴다.
<a href="#lua_pcall"><code>lua_pcall</code></a> 반환 후에는
스택이 이미 풀렸으므로
그런 정보를 수집할 수 없다.


<p>
<a href="#lua_pcall"><code>lua_pcall</code></a> 함수는
(<code>lua.h</code>에 정의된) 다음 상수들 중 하나를 반환한다.

<ul>

<li><b><a name="pdf-LUA_OK"><code>LUA_OK</code></a> (0): </b>
성공.</li>

<li><b><a name="pdf-LUA_ERRRUN"><code>LUA_ERRRUN</code></a>: </b>
런타임 오류.
</li>

<li><b><a name="pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>: </b>
메모리 할당 오류.
이 오류에 대해선 루아가 메시지 핸들러를 호출하지 않는다.
</li>

<li><b><a name="pdf-LUA_ERRERR"><code>LUA_ERRERR</code></a>: </b>
메시지 핸들러 동작 중 오류.
</li>

<li><b><a name="pdf-LUA_ERRGCMM"><code>LUA_ERRGCMM</code></a>: </b>
<code>__gc</code> 메타메소드 동작 중 오류.
이 오류에 대해선 루아가 메시지 핸들러를 호출하지 않는다.
(이런 류의 오류는 일반적으로
호출하려는 함수와 아무 관련이 없기 때문이다.)
</li>

</ul>




<hr><h3><a name="lua_pcallk"><code>lua_pcallk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), &ndash;]</span>
<pre>int lua_pcallk (lua_State *L,
                int nargs,
                int nresults,
                int msgh,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
이 함수는 정확히 <a href="#lua_pcall"><code>lua_pcall</code></a>처럼 동작하되
피호출 함수에서 양보를 할 수 있다. (<a href="#4.7">4.7절</a> 참고.)





<hr><h3><a name="lua_pop"><code>lua_pop</code></a></h3><p>
<span class="apii">[-n, +0, &ndash;]</span>
<pre>void lua_pop (lua_State *L, int n);</pre>

<p>
스택에서 <code>n</code>개 항목을 꺼낸다.





<hr><h3><a name="lua_pushboolean"><code>lua_pushboolean</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushboolean (lua_State *L, int b);</pre>

<p>
값이 <code>b</code>인 불리언 값을 스택에 집어넣는다.





<hr><h3><a name="lua_pushcclosure"><code>lua_pushcclosure</code></a></h3><p>
<span class="apii">[-n, +1, <em>m</em>]</span>
<pre>void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);</pre>

<p>
새 C 클로저를 스택에 집어넣는다.


<p>
C 함수를 만들 때
어떤 값들을 연계해서 C 클로저를 만드는 것이 가능하다.
(<a href="#4.4">4.4절</a> 참고.)
그러면 호출 시 그 함수에서 값들에 접근할 수 있다.
C 함수에 값을 연계하려면
먼저 값을 스택에 집어넣어야 한다.
(값이 여러 개일 때는 첫 번째 값을 첫 번째로 집어넣는다.)
그리고 <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>를 호출해서
C 함수를 만들어 스택에 집어넣는데,
인자 <code>n</code>은 그 함수에 얼마나 많은 값을 연계하려는지 알려 준다.
<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>는 또한 스택에서 그 값들을 꺼낸다.


<p>
<code>n</code>의 최댓값은 255이다.


<p>
<code>n</code>이 0일 때
이 함수는 <em>경량 C 함수</em>를 만드는데,
그냥 C 함수에 대한 포인터이다.
그 경우에는 절대 메모리 오류를 제기하지 않는다.





<hr><h3><a name="lua_pushcfunction"><code>lua_pushcfunction</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushcfunction (lua_State *L, lua_CFunction f);</pre>

<p>
C 함수를 스택에 집어넣는다.
이 함수는 C 함수 포인터를 받아서
<code>function</code> 타입 루아 값을 스택에 집어넣는다.
그 값을 호출하면 대응하는 C 함수가 불린다.


<p>
루아에서 호출 가능해야 하는 함수는
정확한 규약에 따라 매개변수를 받고
결과를 반환해야 한다.
(<a href="#lua_CFunction"><code>lua_CFunction</code></a> 참고.)





<hr><h3><a name="lua_pushfstring"><code>lua_pushfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushfstring (lua_State *L, const char *fmt, ...);</pre>

<p>
서식을 준 문자열을 스택에 집어넣고
그 문자열에 대한 포인터를 반환한다.
ISO C 함수 <code>sprintf</code>와 비슷하지만
몇 가지 중요한 차이가 있다.

<ul>

<li>
결과를 위한 공간을 할당해 주지 않아도 된다.
결과는 루아 문자열이며 루아에서 메모리 할당을
(그리고 쓰레기 수집을 통해 해제까지) 대신 해 준다.
</li>

<li>
변환 지정자에 상당히 제약이 있다.
플래그, 폭, 정밀도가 없다.
변환 지정자로 가능한 것은
'<code>%%</code>' (문자 '<code>%</code>' 삽입),
'<code>%s</code>' (영 종료 문자열 삽입, 크기 제약 없음),
'<code>%f</code>' (<a href="#lua_Number"><code>lua_Number</code></a> 삽입),
'<code>%I</code>' (<a href="#lua_Integer"><code>lua_Integer</code></a> 삽입),
'<code>%p</code>' (포인터를 16진수로 삽입),
'<code>%d</code>' (<code>int</code> 삽입),
'<code>%c</code>' (<code>int</code>를 한 바이트 문자로 삽입),
'<code>%U</code>' (<code>long int</code>를 UTF-8 바이트 열로 삽입)이 전부이다.
</li>

</ul>

<p>
다른 집어넣기 함수들과 달리
이 함수는 결과 저장 슬롯을 포함해
필요한 스택 공간을 확인한다.





<hr><h3><a name="lua_pushglobaltable"><code>lua_pushglobaltable</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushglobaltable (lua_State *L);</pre>

<p>
전역 환경을 스택에 집어넣는다.





<hr><h3><a name="lua_pushinteger"><code>lua_pushinteger</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushinteger (lua_State *L, lua_Integer n);</pre>

<p>
값이 <code>n</code>인 정수를 스택에 집어넣는다.





<hr><h3><a name="lua_pushlightuserdata"><code>lua_pushlightuserdata</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushlightuserdata (lua_State *L, void *p);</pre>

<p>
light userdata를 스택에 집어넣는다.


<p>
루아에서 userdata는 C의 값을 나타낸다.
<em>light userdata</em>는 <code>void*</code>인 포인터를 나타낸다.
(수와 마찬가지로) 하나의 값이다.
따로 생성하지 않고,
개별 메타테이블이 없으며,
(생성한 적이 없으므로) 수집하지 않는다.
한 light userdata는 동일한 C 주소를 가진
"모든" light userdata와 같다.





<hr><h3><a name="lua_pushliteral"><code>lua_pushliteral</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *lua_pushliteral (lua_State *L, const char *s);</pre>

<p>
이 매크로는 <a href="#lua_pushstring"><code>lua_pushstring</code></a>과 동등하다.
단, <code>s</code>가 리터럴 문자열일 때만 써야 한다.





<hr><h3><a name="lua_pushlstring"><code>lua_pushlstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *lua_pushlstring (lua_State *L, const char *s, size_t len);</pre>

<p>
<code>s</code>가 가리키는 크기 <code>len</code>인 문자열을 스택에 집어넣는다.
지정한 문자열의 내부 사본을 루아에서 만들기 (또는 재사용하기) 때문에
함수 반환 후 즉시 <code>s</code>에 있는 메모리를 해제하거나 재사용할 수 있다.
문자열에 0을 포함해 임의의 이진 데이터를 담을 수 있다.


<p>
문자열의 내부 사본에 대한 포인터를 반환한다.





<hr><h3><a name="lua_pushnil"><code>lua_pushnil</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushnil (lua_State *L);</pre>

<p>
nil 값을 스택에 집어넣는다.





<hr><h3><a name="lua_pushnumber"><code>lua_pushnumber</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushnumber (lua_State *L, lua_Number n);</pre>

<p>
값이 <code>n</code>인 실수를 스택에 집어넣는다.





<hr><h3><a name="lua_pushstring"><code>lua_pushstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *lua_pushstring (lua_State *L, const char *s);</pre>

<p>
<code>s</code>가 가리키는 영 종료 문자열을 스택에 집어넣는다.
지정한 문자열의 내부 사본을 루아에서 만들기 (또는 재사용하기) 때문에
함수 반환 후 즉시 <code>s</code>에 있는 메모리를 해제하거나 재사용할 수 있다.


<p>
문자열의 내부 사본에 대한 포인터를 반환한다.


<p>
<code>s</code>가 <code>NULL</code>이면 <b>nil</b>을 집어넣고 <code>NULL</code>을 반환한다.





<hr><h3><a name="lua_pushthread"><code>lua_pushthread</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_pushthread (lua_State *L);</pre>

<p>
<code>L</code>이 나타내는 스레드를 스택에 집어넣는다.
그 스레드가 상태의 주 스레드이면 1을 반환한다.





<hr><h3><a name="lua_pushvalue"><code>lua_pushvalue</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushvalue (lua_State *L, int index);</pre>

<p>
지정한 인덱스에 있는 항목의 사본을 스택에 집어넣는다.





<hr><h3><a name="lua_pushvfstring"><code>lua_pushvfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);</pre>

<p>
<a href="#lua_pushfstring"><code>lua_pushfstring</code></a>과 동등하되,
가변 개수 인자 대신 <code>va_list</code>를 받는다.





<hr><h3><a name="lua_rawequal"><code>lua_rawequal</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_rawequal (lua_State *L, int index1, int index2);</pre>

<p>
인덱스 <code>index1</code>과 <code>index2</code>의 두 값이
단순 비교로 (즉 <code>__eq</code> 메타메소드 호출 없이) 같으면
1을 반환한다.
그렇지 않으면 0을 반환한다.
인덱스가 하나라도 유효하지 않을 때에도 0을 반환한다.





<hr><h3><a name="lua_rawget"><code>lua_rawget</code></a></h3><p>
<span class="apii">[-1, +1, &ndash;]</span>
<pre>int lua_rawget (lua_State *L, int index);</pre>

<p>
<a href="#lua_gettable"><code>lua_gettable</code></a>과 유사하되,
(메타메소드 안 쓰는) raw 접근을 한다.





<hr><h3><a name="lua_rawgeti"><code>lua_rawgeti</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_rawgeti (lua_State *L, int index, lua_Integer n);</pre>

<p>
값 <code>t[n]</code>을 스택에 집어넣는다.
<code>t</code>는 지정한 인덱스에 있는 테이블이다.
접근이 raw이다.
즉, <code>__index</code> 메타메소드를 부르지 않는다.


<p>
집어넣은 값의 타입을 반환한다.





<hr><h3><a name="lua_rawgetp"><code>lua_rawgetp</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_rawgetp (lua_State *L, int index, const void *p);</pre>

<p>
값 <code>t[k]</code>를 스택에 집어넣는다.
<code>t</code>는 지정한 인덱스에 있는 테이블이고
<code>k</code>는 포인터 <code>p</code>를 light userdata로 나타낸 것이다.
접근이 raw이다.
즉, <code>__index</code> 메타메소드를 부르지 않는다.


<p>
집어넣은 값의 타입을 반환한다.





<hr><h3><a name="lua_rawlen"><code>lua_rawlen</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>size_t lua_rawlen (lua_State *L, int index);</pre>

<p>
지정한 인덱스에 있는 값의 raw "길이"를 반환한다.
문자열에서는 문자열 길이이다.
테이블에서는 메타메소드 안 쓴 길이 연산자('<code>#</code>') 결과이다.
userdata에서는 그 userdata를 위해 할당한 메모리 블록의 크기이다.
다른 값들에서는 0이다.





<hr><h3><a name="lua_rawset"><code>lua_rawset</code></a></h3><p>
<span class="apii">[-2, +0, <em>m</em>]</span>
<pre>void lua_rawset (lua_State *L, int index);</pre>

<p>
<a href="#lua_settable"><code>lua_settable</code></a>과 유사하되,
(메타메소드 안 쓰는) raw 할당을 한다.





<hr><h3><a name="lua_rawseti"><code>lua_rawseti</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
<pre>void lua_rawseti (lua_State *L, int index, lua_Integer i);</pre>

<p>
<code>t[i] = v</code>와 동등한 일을 한다.
<code>t</code>는 지정한 인덱스에 있는 테이블이고
<code>v</code>는 스택 상단에 있는 값이다.


<p>
이 함수는 스택에서 값을 꺼낸다.
할당이 raw이다.
즉, <code>__newindex</code> 메타메소드를 부르지 않는다.





<hr><h3><a name="lua_rawsetp"><code>lua_rawsetp</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
<pre>void lua_rawsetp (lua_State *L, int index, const void *p);</pre>

<p>
<code>t[p] = v</code>와 동등한 일을 한다.
<code>t</code>는 지정한 인덱스에 있는 테이블이고
<code>p</code>는 light userdata로 표현한 것이며
<code>v</code>는 스택 상단에 있는 값이다.


<p>
이 함수는 스택에서 값을 꺼낸다.
할당이 raw이다.
즉, <code>__newindex</code> 메타메소드를 부르지 않는다.





<hr><h3><a name="lua_Reader"><code>lua_Reader</code></a></h3>
<pre>typedef const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);</pre>

<p>
<a href="#lua_load"><code>lua_load</code></a>에서 사용하는 읽기 함수이다.
<a href="#lua_load"><code>lua_load</code></a>에서
청크 조각이 더 필요할 때마다
읽기 함수를 호출하며,
<code>data</code> 매개변수를 건네준다.
읽기 함수에서는 새 청크 조각이 있는
메모리 블록에 대한 포인터를 반환하고
<code>size</code>를 블록 크기로 설정해야 한다.
그 블록은 읽기 함수가 다시 호출될 때까지 존재해야 한다.
읽기 함수에서 청크 끝을 알리려면
<code>NULL</code>을 반환하거나 <code>size</code>를 0으로 설정해야 한다.
읽기 함수는 0보다 큰 어떤 크기의 조각도 반환할 수 있다.





<hr><h3><a name="lua_register"><code>lua_register</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void lua_register (lua_State *L, const char *name, lua_CFunction f);</pre>

<p>
C 함수 <code>f</code>를 전역 <code>name</code>의 새 값으로 설정한다.
매크로로 정의되어 있다.

<pre>
     #define lua_register(L,n,f) \
            (lua_pushcfunction(L, f), lua_setglobal(L, n))
</pre>




<hr><h3><a name="lua_remove"><code>lua_remove</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_remove (lua_State *L, int index);</pre>

<p>
지정한 유효 인덱스에 있는 항목을 제거하고
그 인덱스 위의 항목들을 밀어 내려서 구멍을 채운다.
가상 인덱스로 이 함수를 호출할 수 없다.
가상 인덱스는 실제 스택 위치가 아니기 때문이다.





<hr><h3><a name="lua_replace"><code>lua_replace</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_replace (lua_State *L, int index);</pre>

<p>
상단 항목을 지정한 유효 인덱스로 옮기되
항목을 밀어 올리지 않는다.
(그래서 그 지정 인덱스에 있는 값을 교체하게 된다.)
그리고 그 상단 항목을 꺼낸다.





<hr><h3><a name="lua_resume"><code>lua_resume</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>int lua_resume (lua_State *L, lua_State *from, int nargs);</pre>

<p>
지정한 스레드 <code>L</code>에서 코루틴을 시작하고 재개한다.


<p>
코루틴을 시작하려면
메인 함수와 인자를 스레드 스택에 집어넣고서
<code>nargs</code>를 인자 개수로 해서
<a href="#lua_resume"><code>lua_resume</code></a>을 호출하면 된다.
코루틴이 실행을 중지하거나 완료할 때 이 호출이 반환한다.
반환 시 스택에는 <a href="#lua_yield"><code>lua_yield</code></a>가 건네준 모든 값이,
또는 몸체 함수가 반환한 모든 값이 들어 있다.
코루틴이 양보한 경우 <a href="#lua_resume"><code>lua_resume</code></a>이
<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>를 반환하고,
코루틴이 오류 없이 실행을 마친 경우 <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>를 반환하고,
오류가 발생한 경우 오류 코드(<a href="#lua_pcall"><code>lua_pcall</code></a> 참고)를 반환한다.


<p>
오류가 발생한 경우
스택이 풀려 있지 않으므로
거기에 디버그 API를 사용할 수 있다.
스택 상단에 오류 객체가 있다.


<p>
코루틴을 재개하려면
최근 <a href="#lua_yield"><code>lua_yield</code></a>의 결과가 남아 있으면 제거하고
<code>yield</code> 결과로 전달할 값들만 스택에 둔 다음
<a href="#lua_resume"><code>lua_resume</code></a>을 호출하면 된다.


<p>
매개변수 <code>from</code>은 <code>L</code>을 재개하고 있는 코루틴을 나타낸다.
그런 코루틴이 없으면
이 매개변수가 <code>NULL</code>일 수 있다.





<hr><h3><a name="lua_rotate"><code>lua_rotate</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_rotate (lua_State *L, int idx, int n);</pre>

<p>
유효 인덱스 <code>idx</code>와 스택 상단 사이의
스택 항목들을 회전시킨다.
양수 <code>n</code>에 대해선 상단 방향으로 <code>n</code> 위치만큼,
음수 <code>n</code>에 대해선 하단 방향으로 <code>-n</code> 위치만큼
항목들을 회전시킨다.
<code>n</code>의 절대값이 회전시키려는 구간의 길이보다 크면 안 된다.
가상 인덱스로 이 함수를 호출할 수 없다.
가상 인덱스는 실제 스택 위치가 아니기 때문이다.





<hr><h3><a name="lua_setallocf"><code>lua_setallocf</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);</pre>

<p>
지정한 상태의 할당자 함수를 <code>f</code>로 바꾸고
사용자 데이터를 <code>ud</code>로 한다.





<hr><h3><a name="lua_setfield"><code>lua_setfield</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_setfield (lua_State *L, int index, const char *k);</pre>

<p>
<code>t[k] = v</code>와 동등한 일을 한다.
<code>t</code>는 지정한 인덱스에 있는 값이고
<code>v</code>는 스택 상단에 있는 값이다.


<p>
이 함수는 스택에서 값을 꺼낸다.
루아 내에서처럼 이 함수가 "newindex" 이벤트에 대한
메타메소드를 유발할 수 있다.
(<a href="#2.4">2.4절</a> 참고.)





<hr><h3><a name="lua_setglobal"><code>lua_setglobal</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_setglobal (lua_State *L, const char *name);</pre>

<p>
스택에서 값을 꺼내서
전역 <code>name</code>의 새 값으로 설정한다.





<hr><h3><a name="lua_seti"><code>lua_seti</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_seti (lua_State *L, int index, lua_Integer n);</pre>

<p>
<code>t[n] = v</code>와 동등한 일을 한다.
<code>t</code>는 지정한 인덱스에 있는 값이고
<code>v</code>는 스택 상단에 있는 값이다.


<p>
이 함수는 스택에서 값을 꺼낸다.
루아 내에서처럼 이 함수가 "newindex" 이벤트에 대한
메타메소드를 유발할 수 있다.
(<a href="#2.4">2.4절</a> 참고.)





<hr><h3><a name="lua_setmetatable"><code>lua_setmetatable</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_setmetatable (lua_State *L, int index);</pre>

<p>
스택에서 테이블을 꺼내서
지정한 인덱스에 있는 값의 새 메타테이블로 설정한다.





<hr><h3><a name="lua_settable"><code>lua_settable</code></a></h3><p>
<span class="apii">[-2, +0, <em>e</em>]</span>
<pre>void lua_settable (lua_State *L, int index);</pre>

<p>
<code>t[k] = v</code>와 동등한 일을 한다.
<code>t</code>는 지정한 인덱스에 있는 값이고
<code>v</code>는 스택 상단에 있는 값이며
<code>k</code>는 상단 바로 아래의 값이다.


<p>
이 함수는 스택에서 키와 값 모두를 꺼낸다.
루아 내에서처럼 이 함수가 "newindex" 이벤트에 대한
메타메소드를 유발할 수 있다.
(<a href="#2.4">2.4절</a> 참고.)





<hr><h3><a name="lua_settop"><code>lua_settop</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>void lua_settop (lua_State *L, int index);</pre>

<p>
임의 인덱스 또는 0을 받아서
스택 상단 위치를 그 인덱스로 설정한다.
새 상단이 이전보다 높으면
새 항목들을 <b>nil</b>로 채운다.
<code>index</code>가 0이면 스택 항목들을 모두 제거한다.





<hr><h3><a name="lua_setuservalue"><code>lua_setuservalue</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_setuservalue (lua_State *L, int index);</pre>

<p>
스택에서 값을 꺼내서
지정한 인덱스에 있는 full userdata에 연계된 새 값으로 설정한다.





<hr><h3><a name="lua_State"><code>lua_State</code></a></h3>
<pre>typedef struct lua_State lua_State;</pre>

<p>
스레드를, 그리고 (그 스레드를 통해) 간접적으로
루아 인터프리터의 전체 상태를 가리키는 불투명 자료 구조.
루아 라이브러리는 완전하게 재진입 가능하다.
즉, 전역 변수가 전혀 없다.
이 자료 구조를 통해 상태에 대한 모든 정보에 접근 가능하다.


<p>
라이브러리의 모든 함수에 첫 번째 인자로 이 구조에 대한 포인터를 주어야 한다.
단, 무에서부터 루아 상태를 만드는
<a href="#lua_newstate"><code>lua_newstate</code></a>는 예외이다.





<hr><h3><a name="lua_status"><code>lua_status</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_status (lua_State *L);</pre>

<p>
스레드 <code>L</code>의 상태를 반환한다.


<p>
상태는
정상 스레드이면 0(<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>),
스레드가 <a href="#lua_resume"><code>lua_resume</code></a> 실행을 오류로 끝마쳤으면 오류 코드,
스레드가 중지되어 있으면 <a name="pdf-LUA_YIELD"><code>LUA_YIELD</code></a>일 수 있다.


<p>
상태가 <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>인 스레드에서만 함수들을 호출할 수 있다.
상태가 <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>나 <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>인 스레드를 재개할 수 있다. (각기 새 코루틴을 시작하거나 코루틴을 재개한다.)





<hr><h3><a name="lua_stringtonumber"><code>lua_stringtonumber</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>size_t lua_stringtonumber (lua_State *L, const char *s);</pre>

<p>
영 종료 문자열 <code>s</code>를 수로 변환하고,
그 수를 스택에 집어넣고,
문자열의 총 크기, 즉 길이 더하기 1을 반환한다.
변환 결과는 루아 어휘 규정에 따라
정수나 실수가 될 수 있다.
(<a href="#3.1">3.1절</a> 참고.)
문자열에 전후 공백과 부호가 있을 수 있다.
문자열이 유효한 수가 아니면
0을 반환하며 아무것도 집어넣지 않는다.
(따라서 결과를 불리언으로 이용할 수 있다.
변환이 성공하면 참이다.)





<hr><h3><a name="lua_toboolean"><code>lua_toboolean</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_toboolean (lua_State *L, int index);</pre>

<p>
지정한 인덱스에 있는 루아 값을 C 불리언 값(0 또는 1)으로 변환한다.
루아의 여느 검사처럼
<b>false</b> 및 <b>nil</b>과 다른 루아 값에 대해선
<a href="#lua_toboolean"><code>lua_toboolean</code></a>이 참을 반환하고
아니면 거짓을 반환한다.
(실제 불리언인 값만 받아들이고 싶다면
<a href="#lua_isboolean"><code>lua_isboolean</code></a>으로 값의 타입을 검사하면 된다.)





<hr><h3><a name="lua_tocfunction"><code>lua_tocfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_CFunction lua_tocfunction (lua_State *L, int index);</pre>

<p>
지정한 인덱스에 있는 값을 C 함수로 변환한다.
그 값이 C 함수여야 한다.
아니면 <code>NULL</code>을 반환한다.





<hr><h3><a name="lua_tointeger"><code>lua_tointeger</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Integer lua_tointeger (lua_State *L, int index);</pre>

<p>
<code>isnum</code>이 <code>NULL</code>인 <a href="#lua_tointegerx"><code>lua_tointegerx</code></a>와 동등하다.





<hr><h3><a name="lua_tointegerx"><code>lua_tointegerx</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Integer lua_tointegerx (lua_State *L, int index, int *isnum);</pre>

<p>
지정한 인덱스에 있는 루아 값을 부호 있는 정수 타입
<a href="#lua_Integer"><code>lua_Integer</code></a>로 변환한다.
루아 값이 정수이거나 정수로 변환 가능한 수나 문자열이어야 한다.
(<a href="#3.4.3">3.4.3절</a> 참고.)
아니면 <code>lua_tointegerx</code>가 0을 반환한다.


<p>
<code>isnum</code>이 <code>NULL</code>이 아니면
참조 대상에 연산 성공 여부를 나타내는 불리언 값을 할당한다.





<hr><h3><a name="lua_tolstring"><code>lua_tolstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>const char *lua_tolstring (lua_State *L, int index, size_t *len);</pre>

<p>
지정한 인덱스에 있는 루아 값을 C 문자열로 변환한다.
<code>len</code>이 <code>NULL</code>이 아니면
<code>*len</code>에 문자열 길이를 설정한다.
루아 값이 문자열이나 수여야 한다.
아니면 함수가 <code>NULL</code>을 반환한다.
값이 수인 경우
<code>lua_tolstring</code>은
<em>스택의 실제 값을 문자열로 바꾼다</em>.
(테이블 순회 중 키에 <code>lua_tolstring</code>을 적용하는 경우
이 변경이 <a href="#lua_next"><code>lua_next</code></a>에 혼란을 준다.)


<p>
<code>lua_tolstring</code>은
루아 상태 내 문자열에 대한 포인터를 반환한다.
이 문자열에는 (C에서처럼) 항상 마지막 문자 뒤에
영('<code>\0</code>')이 있다.
하지만 내용 중간에도 영이 있을 수 있다.


<p>
루아에 쓰레기 수집기가 있기 때문에
<code>lua_tolstring</code>이 반환한 포인터가
해당 루아 값이 스택에서 제거된 후에 유효하리라는 보장이 없다.





<hr><h3><a name="lua_tonumber"><code>lua_tonumber</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Number lua_tonumber (lua_State *L, int index);</pre>

<p>
<code>isnum</code>이 <code>NULL</code>인 <a href="#lua_tonumberx"><code>lua_tonumberx</code></a>와 동등하다.





<hr><h3><a name="lua_tonumberx"><code>lua_tonumberx</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Number lua_tonumberx (lua_State *L, int index, int *isnum);</pre>

<p>
지정한 인덱스에 있는 루아 값을
C 타입 <a href="#lua_Number"<code>lua_Number</code></a>로 변환한다.
(<a href="#lua_Number"><code>lua_Number</code></a> 참고.)
루아 값이 수이거나 수로 변환 가능한 문자열이어야 한다.
(<a href="#3.4.3">3.4.3절</a> 참고.)
아니면 <a href="#lua_tonumberx"><code>lua_tonumberx</code></a>가 0을 반환한다.


<p>
<code>isnum</code>이 <code>NULL</code>이 아니면
참조 대상에 연산 성공 여부를 나타내는 불리언 값을 할당한다.





<hr><h3><a name="lua_topointer"><code>lua_topointer</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const void *lua_topointer (lua_State *L, int index);</pre>

<p>
지정한 인덱스에 있는 값을 범용 C 포인터(<code>void*</code>)로 변환한다.
그 값은 userdata, 테이블, 스레드, 함수일 수 있다.
아니면 <code>lua_topointer</code>가 <code>NULL</code>을 반환한다.
객체가 다르면 포인터도 서로 다르게 된다.
포인터를 원래 값으로 역변환하는 방법은 없다.


<p>
보통은 해싱과 디버그 정보 용도로만 이 함수를 쓴다.





<hr><h3><a name="lua_tostring"><code>lua_tostring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>const char *lua_tostring (lua_State *L, int index);</pre>

<p>
<code>len</code>이 <code>NULL</code>인 <a href="#lua_tolstring"><code>lua_tolstring</code></a>과 동등하다.





<hr><h3><a name="lua_tothread"><code>lua_tothread</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *lua_tothread (lua_State *L, int index);</pre>

<p>
지정한 인덱스에 있는 값을
(<code>lua_State*</code>로 나타낸) 루아 스레드로 변환한다.
그 값이 스레드여야 한다.
아니면 함수가 <code>NULL</code>을 반환한다.





<hr><h3><a name="lua_touserdata"><code>lua_touserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_touserdata (lua_State *L, int index);</pre>

<p>
지정한 인덱스에 있는 값이 full userdata이면
그 블록 주소를 반환한다.
값이 light userdata이면
그 포인터를 반환한다.
그 외 경우에는 <code>NULL</code>을 반환한다.





<hr><h3><a name="lua_type"><code>lua_type</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_type (lua_State *L, int index);</pre>

<p>
지정한 유효 인덱스에 있는 값의 타입을 반환한다.
유효하지 않은 (하지만 허용인) 인덱스에 대해선 <code>LUA_TNONE</code>을 반환한다.
<a href="#lua_type"><code>lua_type</code></a>이 반환하는 타입은
<code>lua.h</code>에 정의된 상수로 나타낸다.
<a name="pdf-LUA_TNIL"><code>LUA_TNIL</code></a> (0),
<a name="pdf-LUA_TNUMBER"><code>LUA_TNUMBER</code></a>,
<a name="pdf-LUA_TBOOLEAN"><code>LUA_TBOOLEAN</code></a>,
<a name="pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>,
<a name="pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>,
<a name="pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>,
<a name="pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>,
<a name="pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a>,
<a name="pdf-LUA_TLIGHTUSERDATA"><code>LUA_TLIGHTUSERDATA</code></a>
등이다.





<hr><h3><a name="lua_typename"><code>lua_typename</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const char *lua_typename (lua_State *L, int tp);</pre>

<p>
<a href="#lua_type"><code>lua_type</code></a>이 반환하는 값들 중 하나인
<code>tp</code> 값이 나타내는 타입의 이름을 반환한다.





<hr><h3><a name="lua_Unsigned"><code>lua_Unsigned</code></a></h3>
<pre>typedef ... lua_Unsigned;</pre>

<p>
<a href="#lua_Integer"><code>lua_Integer</code></a>의 부호 없는 버전.





<hr><h3><a name="lua_upvalueindex"><code>lua_upvalueindex</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_upvalueindex (int i);</pre>

<p>
동작 중인 함수의 <code>i</code>번째 upvalue를 나타내는
가상 인덱스를 반환한다. (<a href="#4.4">4.4절</a> 참고.)





<hr><h3><a name="lua_version"><code>lua_version</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const lua_Number *lua_version (lua_State *L);</pre>

<p>
루아 코어에 (C 정적 변수로) 저장되어 있는
버전 번호의 주소를 반환한다.
유효한 <a href="#lua_State"><code>lua_State</code></a>로 호출 시
그 상태를 생성하는 데 사용한 버전의 주소를 반환한다.
<code>NULL</code>로 호출 시
그 호출을 실행하는 버전의 주소를 반환한다.





<hr><h3><a name="lua_Writer"><code>lua_Writer</code></a></h3>
<pre>typedef int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);</pre>

<p>
<a href="#lua_dump"><code>lua_dump</code></a>에서 사용하는 쓰기 함수의 타입이다.
<a href="#lua_dump"><code>lua_dump</code></a>에서
청크 조각을 하나씩 만들어 낼 때마다
쓰기 함수를 호출하며,
기록할 버퍼(<code>p</code>)와 그 크기(<code>sz</code>),
<a href="#lua_dump"><code>lua_dump</code></a>에 제공한
<code>data</code> 매개변수를 건네준다.


<p>
쓰기 함수는 오류 코드를 반환한다.
0은 오류 없음을 뜻한다.
다른 값은 오류를 뜻하며 <a href="#lua_dump"><code>lua_dump</code></a>가 더는 쓰기 함수를 호출하지 않게 한다.





<hr><h3><a name="lua_xmove"><code>lua_xmove</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>void lua_xmove (lua_State *from, lua_State *to, int n);</pre>

<p>
한 상태의 스레드들 간에 값을 교환한다.


<p>
이 함수는 스택 <code>from</code>에서 값을 <code>n</code>개 꺼내서
스택 <code>to</code>에 집어넣는다.





<hr><h3><a name="lua_yield"><code>lua_yield</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>int lua_yield (lua_State *L, int nresults);</pre>

<p>
이 함수는 <a href="#lua_yieldk"><code>lua_yieldk</code></a>와 동등하되
속행이 없다. (<a href="#4.7">4.7절</a> 참고.)
그래서 스레드가 실행을 재개할 때,
<code>lua_yield</code> 호출 함수를 호출한 함수에서
실행을 이어 간다.





<hr><h3><a name="lua_yieldk"><code>lua_yieldk</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>int lua_yieldk (lua_State *L,
                int nresults,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
코루틴(스레드)을 양보한다.


<p>
C 함수에서 <a href="#lua_yieldk"><code>lua_yieldk</code></a>를 호출하면
동작 중인 코루틴이 실행을 중지하며
그 코루틴을 시작한 <a href="#lua_resume"><code>lua_resume</code></a> 호출이 반환한다.
매개변수 <code>nresults</code>는 스택으로
<a href="#lua_resume"><code>lua_resume</code></a>에게 결과로 전달할 값 개수이다.


<p>
코루틴 실행을 재개할 때
지정한 속행 함수 <code>k</code>를 루아가 호출해서
양보를 한 C 함수의 실행을 이어 간다.
(<a href="#4.7">4.7절</a> 참고.)
그 속행 함수가 받는 스택은 이전 함수의 스택에서
<code>nresults</code>개 결과가 없어지고
<a href="#lua_resume"><code>lua_resume</code></a>이 받은 인자로 바뀐 것이다.
또한
<a href="#lua_yieldk"><code>lua_yieldk</code></a>에게 건네준
<code>ctx</code> 값을 속행 함수가 받는다.


<p>
일반적으로 이 함수는 반환하지 않는다.
나중에 코루틴이 실행을 재개할 때
속행 함수로 실행이 이어지기 때문이다.
하지만 한 가지 특별한 경우가 있는데,
행 훅이나 카운트 훅 (<a href="#4.9">4.9절</a> 참고) 안에서
이 함수를 호출할 때이다.
그 경우 속행 없이
(아마도 <a href="#lua_yield"><code>lua_yield</code></a> 형태로),
그리고 결과도 없이 <code>lua_yieldk</code>를 호출해야 하며
호출 바로 다음에서 훅이 반환해야 한다.
그러면 루아에서 양보를 하고,
코루틴이 실행을 재개할 때
훅을 유발했던 (루아) 함수의 실행을 정상적으로 이어 간다.


<p>
속행 함수 없는 C 호출이 미완료 상태인 스레드에서 호출하거나
재개에 의해 동작 중이 아닌 스레드에서 (가령 메인 스레드에서) 호출하는 경우
이 함수가 오류를 제기할 수 있다.







<h2>4.9 &ndash; <a name="4.9">디버그 인터페이스</a></h2>

<p>
루아에는 어떤 디버깅 기제도 내장되어 있지 않다.
대신 함수와 <em>훅</em>을 통해
특수한 인터페이스를 제공한다.
이 인터페이스를 이용해
인터프리터의 "내부 정보"가 필요한
다양한 디버거나 프로파일러, 기타 도구들을
만들 수 있다.



<hr><h3><a name="lua_Debug"><code>lua_Debug</code></a></h3>
<pre>typedef struct lua_Debug {
  int event;
  const char *name;           /* (n) */
  const char *namewhat;       /* (n) */
  const char *what;           /* (S) */
  const char *source;         /* (S) */
  int currentline;            /* (l) */
  int linedefined;            /* (S) */
  int lastlinedefined;        /* (S) */
  unsigned char nups;         /* (u) upvalue 개수 */
  unsigned char nparams;      /* (u) 매개변수 개수 */
  char isvararg;              /* (u) */
  char istailcall;            /* (t) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* private part */
  <em>기타 필드</em>
} lua_Debug;</pre>

<p>
함수나 활성 레코드에 대한 다양한 정보를 담는 데 쓰는 구조체.
<a href="#lua_getstack"><code>lua_getstack</code></a>에서 이후 사용을 위해
이 구조체의 비공개 부분만을 채운다.
<a href="#lua_Debug"<code>lua_Debug</code></a>의 다른 필드들에
유용한 정보를 채우려면
<a href="#lua_getinfo"><code>lua_getinfo</code></a>를 호출하면 된다.


<p>
<a href="#lua_Debug"><code>lua_Debug</code></a> 필드들의 의미는 다음과 같다.

<ul>

<li><b><code>source</code>: </b>
함수를 만든 청크의 이름.
<code>source</code>가 '<code>@</code>'로 시작하면
함수가 파일에 정의되어 있었다는 뜻이고
'<code>@</code>' 다음이 그 파일 이름이다.
<code>source</code>가 '<code>=</code>'로 시작하면
나머지 내용이 어떤 사용자별 방식으로 원천을 기술하는 것이다.
그 외 경우는
함수가 문자열에 정의되어 있었다는 뜻이고
<code>source</code>가 그 문자열이다.
</li>

<li><b><code>short_src</code>: </b>
<code>source</code>의 "출력용" 버전. 오류 메시지에 사용.
</li>

<li><b><code>linedefined</code>: </b>
함수 정의가 시작하는 행 번호.
</li>

<li><b><code>lastlinedefined</code>: </b>
함수 정의가 끝나는 행 번호.
</li>

<li><b><code>what</code>: </b>
함수가 루아 함수이면 문자열 <code>"Lua"</code>,
C 함수이면 <code>"C"</code>,
청크의 메인 부분이면 <code>"main"</code>.
</li>

<li><b><code>currentline</code>: </b>
해당 함수가 현재 실행 중인 행.
행 정보를 얻을 수 없을 때는
<code>currentline</code>을 -1로 설정한다.
</li>

<li><b><code>name</code>: </b>
해당 함수의 적당한 이름.
루아에서 함수는 일급 값이기 때문에
고정된 이름이 없다.
어느 함수가 여러 전역 변수의 값일 수 있고
다른 함수는 테이블 필드에만 저장되어 있을 수 있다.
<code>lua_getinfo</code> 함수에서는 적절한 이름을 찾기 위해
그 함수가 어떻게 호출되었는지 확인한다.
이름을 찾을 수 없으면
<code>name</code>을 <code>NULL</code>로 설정한다.
</li>

<li><b><code>namewhat</code>: </b>
<code>name</code> 필드를 설명한다.
<code>namewhat</code>의 값은 함수를 어떻게 호출했는지에 따라서
<code>"global"</code>, <code>"local"</code>, <code>"method"</code>,
<code>"field"</code>, <code>"upvalue"</code>, <code>""</code>(빈 문자열)일 수 있다.
(다른 어느 경우에도 해당하지 않을 때 빈 문자열을 쓴다.)
</li>

<li><b><code>istailcall</code>: </b>
이 함수 실행이 꼬리 호출에 의한 것이면 참이다.
그 경우 스택에 이 단계의 호출자가 없다.
</li>

<li><b><code>nups</code>: </b>
함수의 upvalue 개수.
</li>

<li><b><code>nparams</code>: </b>
함수의 고정 매개변수 개수.
(C 함수에는 항상 0.)
</li>

<li><b><code>isvararg</code>: </b>
함수가 vararg 함수이면 참.
(C 함수에는 항상 참.)
</li>

</ul>




<hr><h3><a name="lua_gethook"><code>lua_gethook</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Hook lua_gethook (lua_State *L);</pre>

<p>
현재 훅 함수를 반환한다.





<hr><h3><a name="lua_gethookcount"><code>lua_gethookcount</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gethookcount (lua_State *L);</pre>

<p>
현재 훅 카운트를 반환한다.





<hr><h3><a name="lua_gethookmask"><code>lua_gethookmask</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gethookmask (lua_State *L);</pre>

<p>
현재 훅 마스크를 반환한다.





<hr><h3><a name="lua_getinfo"><code>lua_getinfo</code></a></h3><p>
<span class="apii">[-(0|1), +(0|1|2), <em>e</em>]</span>
<pre>int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);</pre>

<p>
특정 함수 내지 함수 호출에 대한 정보를 얻는다.


<p>
함수 호출에 대한 정보를 얻으려면
매개변수 <code>ar</code>이
앞선 <a href="#lua_getstack"><code>lua_getstack</code></a> 호출로 채웠거나
훅 인자로 받은 (<a href="#lua_Hook"><code>lua_Hook</code></a> 참고)
유효한 활성 레코드여야 한다.


<p>
함수에 대한 정보를 얻으려면 함수를 스택에 집어넣고
<code>what</code> 문자열이 '<code>&gt;</code>' 문자로 시작하게 하면 된다.
(이 경우에
<code>lua_getinfo</code>가 스택 상단에서 그 함수를 꺼낸다.)
예를 들어 어느 행에서 함수 <code>f</code>를 정의했는지 알기 위해
다음과 같이 코드를 작성할 수 있다.

<pre>
     lua_Debug ar;
     lua_getglobal(L, "f");  /* 전역 'f' 얻기 */
     lua_getinfo(L, "&gt;S", &amp;ar);
     printf("%d\n", ar.linedefined);
</pre>

<p>
<code>what</code> 문자열의 각 문자가
<code>ar</code> 구조체에서 채울 필드나
스택에 집어넣을 값을 선택한다.

<ul>

<li><b>'<code>n</code>': </b> <code>name</code> 및 <code>namewhat</code> 필드를 채운다.
</li>

<li><b>'<code>S</code>': </b>
<code>source</code>, <code>short_src</code>, <code>linedefined</code>,
<code>lastlinedefined</code>, <code>what</code> 필드를 채운다.
</li>

<li><b>'<code>l</code>': </b> <code>currentline</code> 필드를 채운다.
</li>

<li><b>'<code>t</code>': </b> <code>istailcall</code> 필드를 채운다.
</li>

<li><b>'<code>u</code>': </b> <code>nups</code>,
<code>nparams</code>, <code>isvararg</code> 필드를 채운다.
</li>

<li><b>'<code>f</code>': </b>
해당 단계에서 실행 중인 함수를
스택에 집어넣는다.
</li>

<li><b>'<code>L</code>': </b>
그 함수 상의 유효 행의 번호가 인덱스인 테이블을
스택에 집어넣는다.
(<em>유효 행</em>이란 어떤 연관 코드가 있는 행이다.
즉, 중단점을 넣을 수 있는 행이다.
유효하지 않은 행에는 빈 행과 주석이 포함된다.)


<p>
이 옵션을 '<code>f</code>' 옵션과 함께 주면
함수 다음에 테이블을 집어넣는다.
</li>

</ul>

<p>
오류 시 (예를 들어 <code>what</code>에 잘못된 옵션이 있을 때)
이 함수는 0을 반환한다.





<hr><h3><a name="lua_getlocal"><code>lua_getlocal</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>
해당 활성 레코드 내지 해당 함수의
지역 변수에 대한 정보를 얻는다.


<p>
첫 번째 경우에는
매개변수 <code>ar</code>이
앞선 <a href="#lua_getstack"><code>lua_getstack</code></a> 호출로 채웠거나
훅 인자로 받은 (<a href="#lua_Hook"><code>lua_Hook</code></a> 참고)
유효한 활성 레코드여야 한다.
인덱스 <code>n</code>으로 어느 지역 변수를 조사할지 선택한다.
변수 인덱스와 이름에 대한 자세한 내용은 <a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a> 참고.


<p>
<a href="#lua_getlocal"><code>lua_getlocal</code></a>은 변수의 값을 스택에 집어넣고
이름을 반환한다.


<p>
두 번째 경우에는
<code>ar</code>이 <code>NULL</code>이어야 하고
조사할 함수가 스택 상단에 있어야 한다.
이 경우 (어느 변수가 활성인지에 대한 정보가 없으므로)
루아 함수의 매개변수들만 보이며
스택에는 아무 값도 집어넣지 않는다.


<p>
인덱스가 활성 지역 변수 개수보다 크면
<code>NULL</code>을 반환한다.
(그리고 아무것도 집어넣지 않는다.)





<hr><h3><a name="lua_getstack"><code>lua_getstack</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_getstack (lua_State *L, int level, lua_Debug *ar);</pre>

<p>
인터프리터 런타임 스택에 대한 정보를 얻는다.


<p>
이 함수는 해당 단계에서 실행 중인
함수 <em>활성 레코드</em>의 신원 정보를
<a href="#lua_Debug"><code>lua_Debug</code></a>의 부분들에 채운다.
0번 단계는 현재 돌고 있는 함수이고
<em>n+1</em>번 단계는 <em>n</em>번 단계를 호출한 함수이다.
(꼬리 호출은 스택에서 자리를 차지하지 않으므로 제외된다.)
오류가 없을 때 <a href="#lua_getstack"><code>lua_getstack</code></a>은 1을 반환한다.
스택 깊이보다 큰 단계로 호출하면 0을 반환한다.





<hr><h3><a name="lua_getupvalue"><code>lua_getupvalue</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>const char *lua_getupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
인덱스 <code>funcindex</code>에 있는 클로저의
<code>n</code> 번째 upvalue에 대한 정보를 얻는다.
그 upvalue의 값을 스택에 집어넣고
이름을 반환한다.
인덱스 <code>n</code>이 upvalue 개수보다 크면
<code>NULL</code>을 반환한다.
(그리고 아무것도 집어넣지 않는다.)


<p>
C 함수의 경우 이 함수가 모든 upvalue에
이름으로 빈 문자열 <code>""</code>을 쓴다.
(루아 함수의 경우
upvalue는 함수에서 사용하여 그 결과로 클로저에 포함된
외부의 지역 변수이다.)


<p>
upvalue들은 함수 전체에서 활성이므로
특별한 순서가 없다.
임의 순서로 번호가 붙는다.





<hr><h3><a name="lua_Hook"><code>lua_Hook</code></a></h3>
<pre>typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);</pre>

<p>
디버그용 훅 함수 타입.


<p>
훅이 불릴 때 <code>ar</code> 인자의 <code>event</code> 필드가
그 훅을 유발한 특정 이벤트로 설정되어 있다.
상수
<a name="pdf-LUA_HOOKCALL"><code>LUA_HOOKCALL</code></a>, <a name="pdf-LUA_HOOKRET"><code>LUA_HOOKRET</code></a>,
<a name="pdf-LUA_HOOKTAILCALL"><code>LUA_HOOKTAILCALL</code></a>, <a name="pdf-LUA_HOOKLINE"><code>LUA_HOOKLINE</code></a>,
<a name="pdf-LUA_HOOKCOUNT"><code>LUA_HOOKCOUNT</code></a>로 이벤트를 나타낸다.
또한 행 이벤트에서는 <code>currentline</code> 필드도 설정되어 있다.
<code>ar</code>의 다른 필드의 값을 얻으려면
훅에서 <a href="#lua_getinfo"><code>lua_getinfo</code></a>를 호출해야 한다.


<p>
호출 이벤트에서는 <code>event</code>가 일반적인 값 <code>LUA_HOOKCALL</code>일 수도 있고
꼬리 호출에 대한 <code>LUA_HOOKTAILCALL</code>일 수도 있다.
꼬리 호출인 경우에는 대응하는 반환 이벤트가 없다.


<p>
훅을 실행하는 동안 루아에서는 다른 훅 호출을 꺼 둔다.
그래서 훅에서 루아를 다시 호출해서 함수나 청크를 실행하는 경우
훅 호출 없이 실행이 이뤄진다.


<p>
훅 함수에는 속행이 있을 수 없다.
즉, 널이 아닌 <code>k</code>로 <a href="#lua_yieldk"><code>lua_yieldk</code></a>,
<a href="#lua_pcallk"><code>lua_pcallk</code></a>, <a href="#lua_callk"><code>lua_callk</code></a>를 호출할 수 없다.


<p>
훅 함수는 정해진 조건 하에서만 양보를 할 수 있다.
카운트 이벤트와 행 이벤트에서만 양보할 수 있다.
양보를 하려면 훅 함수에서
<code>nresults</code>를 0으로 해서 (즉 값 없이)
<a href="#lua_yield"><code>lua_yield</code></a>를 호출하여
실행을 마쳐야 한다.





<hr><h3><a name="lua_sethook"><code>lua_sethook</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_sethook (lua_State *L, lua_Hook f, int mask, int count);</pre>

<p>
디버그용 훅 함수를 설정한다.


<p>
인자 <code>f</code>는 훅 함수이다.
<code>mask</code>는 어떤 이벤트에 훅이 불릴지 지정하며, 상수
<a name="pdf-LUA_MASKCALL"><code>LUA_MASKCALL</code></a>,
<a name="pdf-LUA_MASKRET"><code>LUA_MASKRET</code></a>,
<a name="pdf-LUA_MASKLINE"><code>LUA_MASKLINE</code></a>,
<a name="pdf-LUA_MASKCOUNT"><code>LUA_MASKCOUNT</code></a>를
비트 OR 해서 구성한다.
<code>count</code> 인자는 마스크에 <code>LUA_MASKCOUNT</code>가
들어 있을 때만 의미가 있다.
각 이벤트에 대해 아래 설명처럼 훅이 호출된다.

<ul>

<li><b>호출 훅: </b> 인터프리터가 함수를 호출할 때 부른다.
새 함수로 진입한 직후에 함수에서 첫 번째 인자를 얻기 전에
훅을 호출한다.
</li>

<li><b>반환 훅: </b> 인터프리터가 함수에서 반환할 때 부른다.
함수를 떠나기 직전에 훅을 호출한다.
함수가 반환하게 될 값에 접근하는 표준적 방법이 없다.
</li>

<li><b>행 훅: </b> 인터프리터가 새 코드 행의 실행을 시작하려 하거나
코드에서 뒤로 (또는 같은 행으로) 점프할 때 부른다.
(루아 함수 실행 중에만 이 이벤트가 발생한다.)
</li>

<li><b>카운트 훅: </b> 인터프리터가 인스트럭션을 <code>count</code>개
실행한 다음마다 부른다.
(루아 함수 실행 중에만 이 이벤트가 발생한다.)
</li>

</ul>

<p>
<code>mask</code>를 0으로 설정해서 훅을 끈다.





<hr><h3><a name="lua_setlocal"><code>lua_setlocal</code></a></h3><p>
<span class="apii">[-(0|1), +0, &ndash;]</span>
<pre>const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>
해당 활성 레코드의 지역 변수의 값을 설정한다.
스택 상단의 값을 변수에 할당하고
이름을 반환한다.
또한 스택에서 값을 꺼낸다.


<p>
인덱스가 활성 지역 변수 개수보다 크면
<code>NULL</code>을 반환한다.
(그리고 아무것도 꺼내지 않는다.)


<p>
매개변수 <code>ar</code>과 <code>n</code>은 <a href="#lua_getlocal"><code>lua_getlocal</code></a> 함수에서와 같다.





<hr><h3><a name="lua_setupvalue"><code>lua_setupvalue</code></a></h3><p>
<span class="apii">[-(0|1), +0, &ndash;]</span>
<pre>const char *lua_setupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
클로저의 upvalue의 값을 설정한다.
스택 상단의 값을 upvalue에 할당하고
이름을 반환한다.
또한 스택에서 값을 꺼낸다.


<p>
인덱스 <code>n</code>이 upvalue 개수보다 크면
<code>NULL</code>을 반환한다.
(그리고 아무것도 꺼내지 않는다.)


<p>
매개변수 <code>funcindex</code>와 <code>n</code>은 <a href="#lua_getupvalue"><code>lua_getupvalue</code></a> 함수에서와 같다.





<hr><h3><a name="lua_upvalueid"><code>lua_upvalueid</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_upvalueid (lua_State *L, int funcindex, int n);</pre>

<p>
인덱스 <code>funcindex</code>에 있는 클로저에서
<code>n</code>번 upvalue의 고유 식별자를 반환한다.


<p>
이 고유 식별자를 이용하면 upvalue를 여러 클로저에서 공유하는지 여부를
프로그램에서 확인할 수 있다.
upvalue를 공유하는 (즉 같은 외부 지역 변수에 접근하는)
루아 클로저들은 각각의 upvalue 인덱스에 대해
동일한 ID를 반환하게 된다.


<p>
매개변수 <code>funcindex</code>와 <code>n</code>은 <a href="#lua_getupvalue"><code>lua_getupvalue</code></a> 함수에서와 같다.
단, <code>n</code>이 upvalue 개수보다 클 수 없다.





<hr><h3><a name="lua_upvaluejoin"><code>lua_upvaluejoin</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_upvaluejoin (lua_State *L, int funcindex1, int n1,
                                    int funcindex2, int n2);</pre>

<p>
인덱스 <code>funcindex1</code>에 있는 루아 클로저의 <code>n1</code> 번째 upvalue가
인덱스 <code>funcindex2</code>에 있는 루아 클로저의 <code>n2</code> 번째 upvalue를
가리키게 만든다.







<h1>5 &ndash; <a name="5">보조 라이브러리</a></h1>

<p>

<em>보조 라이브러리</em>에는 C와 루아를 연결해 주는
여러 편리한 함수들이 있다.
기본 API가 C와 루아 사이의 모든 상호작용을 위한
기반 함수를 제공한다면
보조 라이브러리는 몇 가지 자주 있는 작업을 위한
고수준 함수를 제공한다.


<p>
보조 라이브러리의 모든 함수와 타입은
헤더 파일 <code>lauxlib.h</code>에 정의되어 있으며
앞에 <code>luaL_</code>이 붙어 있다.


<p>
보조 라이브러리의 모든 함수는
기본 API를 바탕으로 만든 것이고,
그래서 그 API가 할 수 없는 것을 해 주지는 못한다.
그렇지만 보조 라이브러리 사용은
코드의 무모순성을 향상시켜 준다.


<p>
보조 라이브러리의 여러 함수에서는
내부적으로 스택 슬롯 몇 개를 추가로 쓴다.
보조 라이브러리의 함수에서 슬롯을 다섯 개 미만으로 사용할 때는
스택 크기를 확인하지 않는다.
즉, 슬롯이 충분히 있다고 그냥 가정한다.


<p>
보조 라이브러리의 여러 함수들은
C 함수 인자를 검사하는 데 쓰인다.
오류 메시지가 인자에 맞춰져 있으므로
(가령 "<code>bad argument #1</code>")
다른 스택 값에는 이 함수를 사용하지 않는 게 좋다.


<p>
이름이 <code>luaL_check*</code>인 함수들은
검사가 통과 안 되면 항상 오류를 제기한다.



<h2>5.1 &ndash; <a name="5.1">함수와 타입</a></h2>

<p>
여기선 보조 라이브러리의 모든 함수와 타입을 알파벳 순서로 나열한다.



<hr><h3><a name="luaL_addchar"><code>luaL_addchar</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
<pre>void luaL_addchar (luaL_Buffer *B, char c);</pre>

<p>
바이트 <code>c</code>를
버퍼 <code>B</code>에 추가한다.
(<a href="#luaL_Buffer"><code>luaL_Buffer</code></a> 참고.)





<hr><h3><a name="luaL_addlstring"><code>luaL_addlstring</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
<pre>void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);</pre>

<p>
<code>s</code>가 가리키는 길이 <code>l</code>인 문자열을
버퍼 <code>B</code>에 추가한다.
(<a href="#luaL_Buffer"><code>luaL_Buffer</code></a> 참고.)
문자열 내에 영이 있을 수 있다.





<hr><h3><a name="luaL_addsize"><code>luaL_addsize</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>void luaL_addsize (luaL_Buffer *B, size_t n);</pre>

<p>
버퍼 영역으로 미리 복사한
(<a href="#luaL_prepbuffer"><code>luaL_prepbuffer</code></a> 참고)
길이 <code>n</code>인 문자열을
버퍼 <code>B</code>에 추가한다.
(<a href="#luaL_Buffer"><code>luaL_Buffer</code></a> 참고.)





<hr><h3><a name="luaL_addstring"><code>luaL_addstring</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
<pre>void luaL_addstring (luaL_Buffer *B, const char *s);</pre>

<p>
<code>s</code>가 가리키는 영 종료 문자열을
버퍼 <code>B</code>에 추가한다.
(<a href="#luaL_Buffer"><code>luaL_Buffer</code></a> 참고.)





<hr><h3><a name="luaL_addvalue"><code>luaL_addvalue</code></a></h3><p>
<span class="apii">[-1, +?, <em>m</em>]</span>
<pre>void luaL_addvalue (luaL_Buffer *B);</pre>

<p>
스택 상단의 값을
버퍼 <code>B</code>에 추가한다.
(<a href="#luaL_Buffer"><code>luaL_Buffer</code></a> 참고.)
값을 꺼낸다.


<p>
문자열 버퍼 함수들 중 유일하게
스택에 따로 항목(버퍼에 추가할 값)을 두고
호출할 수 있는 (또한 그래야 하는) 함수이다.





<hr><h3><a name="luaL_argcheck"><code>luaL_argcheck</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_argcheck (lua_State *L,
                    int cond,
                    int arg,
                    const char *extramsg);</pre>

<p>
<code>cond</code>가 참인지 확인한다.
참이 아니면 표준 메시지로 오류를 제기한다.
(<a href="#luaL_argerror"><code>luaL_argerror</code></a> 참고.)





<hr><h3><a name="luaL_argerror"><code>luaL_argerror</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_argerror (lua_State *L, int arg, const char *extramsg);</pre>

<p>
이 함수를 호출한 C 함수의 <code>arg</code> 번째 인자에 대한 문제를 보고하는
오류를 제기한다.
<code>extramsg</code>를 담은 다음 표준 메시지를 사용한다.

<pre>
     bad argument #<em>arg</em> to '<em>함수명</em>' (<em>extramsg</em>)
</pre><p>
이 함수는 절대 반환하지 않는다.





<hr><h3><a name="luaL_Buffer"><code>luaL_Buffer</code></a></h3>
<pre>typedef struct luaL_Buffer luaL_Buffer;</pre>

<p>
<em>문자열 버퍼</em> 타입.


<p>
문자열 버퍼를 이용해 C 코드에서 루아 문자열을 조금씩 만들어 나갈 수 있다.
다음과 같은 패턴으로 사용한다.

<ul>

<li>먼저 <a href="#luaL_Buffer"><code>luaL_Buffer</code></a> 타입 변수 <code>b</code>를 선언한다.</li>

<li>그리고 <code>luaL_buffinit(L, &amp;b)</code> 호출로 초기화 한다.</li>

<li>
그리고 <code>luaL_add*</code> 함수를 호출해서
버퍼에 문자열 조각들을 추가한다.
</li>

<li>
<code>luaL_pushresult(&amp;b)</code> 호출로 마무리한다.
그러면 스택 상단에 최종 문자열이 남는다.
</li>

</ul>

<p>
결과 문자열의 전체 크기를 미리 알고 있다면
다음과 같이 버퍼를 사용할 수 있다.

<ul>

<li>먼저 <a href="#luaL_Buffer"><code>luaL_Buffer</code></a> 타입 변수 <code>b</code>를 선언한다.</li>

<li>그리고 <code>luaL_buffinitsize(L, &amp;b, sz)</code> 호출로 초기화 하고
<code>sz</code> 크기의 공간을 미리 할당한다.</li>

<li>그리고 그 공간으로 문자열을 복사한다.</li>

<li>
<code>luaL_pushresultsize(&amp;b, sz)</code> 호출로 마무리한다.
<code>sz</code>는 그 공간으로 복사한 결과 문자열 전체 크기이다.
</li>

</ul>

<p>
정상 동작 중에
문자열 버퍼에서 쓰는 스택 슬롯 수가 바뀔 수 있다.
따라서 버퍼 사용 중에는 스택 상단이 어디인지
알고 있다고 가정할 수 없다.
두 버퍼 연산 호출 사이에서 스택을 쓰려면
사용이 균형이 맞아야만 가능하다.
즉, 어떤 버퍼 연산을 호출할 때의 스택이
이전 버퍼 연산 직후와
같은 높이여야 한다.
(이 규칙의 유일한 예외가 <a href="#luaL_addvalue"><code>luaL_addvalue</code></a>이다.)
<a href="#luaL_pushresult"><code>luaL_pushresult</code></a>를 호출하면
스택이 버퍼를 초기화 했던 때의 높이로 돌아가고
거기에 최종 문자열이 더해진다.





<hr><h3><a name="luaL_buffinit"><code>luaL_buffinit</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_buffinit (lua_State *L, luaL_Buffer *B);</pre>

<p>
버퍼 <code>B</code>를 초기화 한다.
이 함수는 어떤 공간도 할당해 두지 않는다.
버퍼가 변수로 선언되어 있어야 한다.
(<a href="#luaL_Buffer"><code>luaL_Buffer</code></a> 참고.)





<hr><h3><a name="luaL_buffinitsize"><code>luaL_buffinitsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
<pre>char *luaL_buffinitsize (lua_State *L, luaL_Buffer *B, size_t sz);</pre>

<p>
<a href="#luaL_buffinit"><code>luaL_buffinit</code></a>, <a href="#luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a>
연속 호출과 동등하다.





<hr><h3><a name="luaL_callmeta"><code>luaL_callmeta</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>e</em>]</span>
<pre>int luaL_callmeta (lua_State *L, int obj, const char *e);</pre>

<p>
메타메소드를 호출한다.


<p>
인덱스 <code>obj</code>에 있는 객체에 메타메소드가 있고
그 메타메소드에 필드 <code>e</code>가 있으면
객체를 유일한 인자로 해서 그 필드를 호출한다.
이 경우 함수가 참을 반환하며
호출 반환 값을 스택 상단에 집어넣는다.
메타테이블이 없거나 메타메소드가 없으면
함수가 거짓을 반환한다. (스택에는 아무것도 집어넣지 않는다.)





<hr><h3><a name="luaL_checkany"><code>luaL_checkany</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checkany (lua_State *L, int arg);</pre>

<p>
<code>arg</code> 위치에 어느 타입이든 (<b>nil</b> 포함)
함수 인자가 있는지 확인한다.





<hr><h3><a name="luaL_checkinteger"><code>luaL_checkinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Integer luaL_checkinteger (lua_State *L, int arg);</pre>

<p>
<code>arg</code> 번째 함수 인자가 정수인지
(또는 정수로 변환할 수 있는지) 확인하고
그 정수를 <a href="#lua_Integer"><code>lua_Integer</code></a>로 캐스팅 해서 반환한다.





<hr><h3><a name="luaL_checklstring"><code>luaL_checklstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_checklstring (lua_State *L, int arg, size_t *l);</pre>

<p>
<code>arg</code> 번째 함수 인자가 문자열인지 확인하고
그 문자열을 반환한다.
<code>l</code>이 <code>NULL</code>이 아니면
<code>*l</code>에 문자열 길이를 채운다.


<p>
이 함수는 <a href="#lua_tolstring"><code>lua_tolstring</code></a>을 써서 결과를 얻는다.
따라서 그 함수의 모든 변환 방식과 주의 사항이 여기에도 적용된다.





<hr><h3><a name="luaL_checknumber"><code>luaL_checknumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Number luaL_checknumber (lua_State *L, int arg);</pre>

<p>
<code>arg</code> 번째 함수 인자가 수인지 확인하고
그 수를 반환한다.





<hr><h3><a name="luaL_checkoption"><code>luaL_checkoption</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_checkoption (lua_State *L,
                      int arg,
                      const char *def,
                      const char *const lst[]);</pre>

<p>
<code>arg</code> 번째 함수 인자가 문자열인지 확인하고
(NULL로 끝나는) <code>lst</code> 배열에서 그 문자열을 탐색한다.
배열에서 문자열을 찾은 인덱스를 반환한다.
인자가 문자열이 아니거나
그 문자열을 찾을 수 없으면 오류를 제기한다.


<p>
<code>def</code>가 <code>NULL</code>이 아니면
인자 <code>arg</code>가 없거나 그 인자가 <b>nil</b>일 때
기본값으로 <code>def</code>를 쓴다.


<p>
문자열을 C 열거형으로 연결하는 데 유용한 함수이다.
(선택지를 나타내는 데 수 대신 문자열을 쓰는 것이
루아 라이브러리들의 일반적 관행이다.)





<hr><h3><a name="luaL_checkstack"><code>luaL_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checkstack (lua_State *L, int sz, const char *msg);</pre>

<p>
스택 크기를 <code>top + sz</code>개 항목으로 키운다.
스택이 그 크기로 커질 수 없으면 오류를 제기한다.
<code>msg</code>는 오류 메시지에 들어갈 추가 텍스트이다.
(추가할 텍스트가 없으면 <code>NULL</code>.)





<hr><h3><a name="luaL_checkstring"><code>luaL_checkstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_checkstring (lua_State *L, int arg);</pre>

<p>
<code>arg</code> 번째 함수 인자가 문자열인지 확인하고
그 문자열을 반환한다.


<p>
이 함수는 <a href="#lua_tolstring"><code>lua_tolstring</code></a>을 써서 결과를 얻는다.
따라서 그 함수의 모든 변환 방식과 주의 사항이 여기에도 적용된다.





<hr><h3><a name="luaL_checktype"><code>luaL_checktype</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checktype (lua_State *L, int arg, int t);</pre>

<p>
<code>arg</code> 번째 함수 인자가 타입 <code>t</code>인지 확인한다.
<code>t</code>의 타입 표현 방식에 대해선 <a href="#lua_type"><code>lua_type</code></a>을 보라.





<hr><h3><a name="luaL_checkudata"><code>luaL_checkudata</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void *luaL_checkudata (lua_State *L, int arg, const char *tname);</pre>

<p>
<code>arg</code> 번째 함수 인자가 타입이 <code>tname</code>인
(<a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a> 참고)
userdata인지 확인하고 그 userdata 주소를
(<a href="#lua_touserdata"><code>lua_touserdata</code></a> 참고)
반환한다.





<hr><h3><a name="luaL_checkversion"><code>luaL_checkversion</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checkversion (lua_State *L);</pre>

<p>
호출을 실행하는 코어와
루아 상태를 생성한 코어,
호출을 하고 있는 코어가 모두 같은 루아 버전을 쓰고 있는지 확인한다.
또한 호출을 실행하는 코어와
루아 상태를 생성한 코어가
같은 주소 공간을 쓰고 있는지도 확인한다.





<hr><h3><a name="luaL_dofile"><code>luaL_dofile</code></a></h3><p>
<span class="apii">[-0, +?, <em>e</em>]</span>
<pre>int luaL_dofile (lua_State *L, const char *filename);</pre>

<p>
지정한 파일을 적재해서 실행한다.
다음 매크로로 정의되어 있다.

<pre>
     (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>
아무 오류도 없으면 거짓을 반환하고
오류 발생 시 참을 반환한다.





<hr><h3><a name="luaL_dostring"><code>luaL_dostring</code></a></h3><p>
<span class="apii">[-0, +?, &ndash;]</span>
<pre>int luaL_dostring (lua_State *L, const char *str);</pre>

<p>
지정한 문자열을 적재해서 실행한다.
다음 매크로로 정의되어 있다.

<pre>
     (luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>
아무 오류도 없으면 거짓을 반환하고
오류 발생 시 참을 반환한다.





<hr><h3><a name="luaL_error"><code>luaL_error</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_error (lua_State *L, const char *fmt, ...);</pre>

<p>
오류를 제기한다.
<code>fmt</code>에 더해 추가 인자로 오류 메시지 형식을 받으며
<a href="#lua_pushfstring"><code>lua_pushfstring</code></a>에서와 같은 규칙을 따른다.
또한 오류가 발생한 파일 이름 및 행 번호에 대한 정보가 있으면
메시지 앞쪽에 추가한다.


<p>
이 함수는 절대 반환하지 않는다.
하지만 C 함수에서 관용구처럼
<code>return luaL_error(<em>args</em>)</code>라고 쓴다.





<hr><h3><a name="luaL_execresult"><code>luaL_execresult</code></a></h3><p>
<span class="apii">[-0, +3, <em>m</em>]</span>
<pre>int luaL_execresult (lua_State *L, int stat);</pre>

<p>
표준 라이브러리의 프로세스 관련 함수들(<a href="#pdf-os.execute"><code>os.execute</code></a>,
<a href="#pdf-io.close"><code>io.close</code></a>)을 위한
반환 값을 만들어 낸다.





<hr><h3><a name="luaL_fileresult"><code>luaL_fileresult</code></a></h3><p>
<span class="apii">[-0, +(1|3), <em>m</em>]</span>
<pre>int luaL_fileresult (lua_State *L, int stat, const char *fname);</pre>

<p>
표준 라이브러리의 파일 관련 함수들(<a href="#pdf-io.open"><code>io.open</code></a>,
<a href="#pdf-os.rename"><code>os.rename</code></a>, <a href="#pdf-file:seek"><code>file:seek</code></a> 등)을 위한
반환 값을 만들어 낸다.





<hr><h3><a name="luaL_getmetafield"><code>luaL_getmetafield</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>m</em>]</span>
<pre>int luaL_getmetafield (lua_State *L, int obj, const char *e);</pre>

<p>
인덱스 <code>obj</code>에 있는 객체의 메타테이블의 필드 <code>e</code>를
스택에 집어넣고 집어넣은 값의 타입을 반환한다.
그 객체에 메타테이블이 없거나
메타테이블에 그 필드가 없으면
아무 것도 집어넣지 않고 <code>LUA_TNIL</code>을 반환한다.





<hr><h3><a name="luaL_getmetatable"><code>luaL_getmetatable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>int luaL_getmetatable (lua_State *L, const char *tname);</pre>

<p>
레지스트리에서 이름 <code>tname</code>에 연계되어 있는
(<a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a> 참고)
메타테이블을 스택에 집어넣는다.
(그 이름에 연계된 메타테이블이 없으면 <b>nil</b>을 집어넣는다.)
집어넣은 값의 타입을 반환한다.





<hr><h3><a name="luaL_getsubtable"><code>luaL_getsubtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int luaL_getsubtable (lua_State *L, int idx, const char *fname);</pre>

<p>
인덱스 <code>idx</code>에 있는 값 <code>t</code>에 대해
<code>t[fname]</code>이 테이블이게 하고서
그 테이블을 스택에 집어넣는다.
이전의 테이블을 찾은 경우에는 참을 반환하고
새 테이블을 만든 경우에는 거짓을 반환한다.





<hr><h3><a name="luaL_gsub"><code>luaL_gsub</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *luaL_gsub (lua_State *L,
                       const char *s,
                       const char *p,
                       const char *r);</pre>

<p>
문자열 <code>s</code>에서
문자열 <code>p</code>를 모두
문자열 <code>r</code>로 바꾼 사본을 만든다.
결과 문자열을 스택에 집어넣고 그 문자열을 반환한다.





<hr><h3><a name="luaL_len"><code>luaL_len</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>lua_Integer luaL_len (lua_State *L, int index);</pre>

<p>
지정한 인덱스에 있는 값의 "길이"를 수로 반환한다.
루아의 '<code>#</code>' 연산자(<a href="#3.4.7">3.4.7절</a>)와 동등하다.
연산 결과가 정수가 아니면 오류를 제기한다.
(메타메소드를 통해서만 그런 경우가 발생할 수 있다.)





<hr><h3><a name="luaL_loadbuffer"><code>luaL_loadbuffer</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_loadbuffer (lua_State *L,
                     const char *buff,
                     size_t sz,
                     const char *name);</pre>

<p>
<code>mode</code>가 <code>NULL</code>인 <a href="#luaL_loadbufferx"><code>luaL_loadbufferx</code></a>와 동등하다.





<hr><h3><a name="luaL_loadbufferx"><code>luaL_loadbufferx</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_loadbufferx (lua_State *L,
                      const char *buff,
                      size_t sz,
                      const char *name,
                      const char *mode);</pre>

<p>
버퍼에서 루아 청크를 적재한다.
<a href="#lua_load"><code>lua_load</code></a>를 사용해
<code>buff</code>가 가리키는 크기 <code>sz</code>인 버퍼에 있는 청크를 적재한다.


<p>
이 함수는 <a href="#lua_load"><code>lua_load</code></a>와 같은 결과를 반환한다.
<code>name</code>은 청크 이름이며
디버그 정보와 오류 메시지에 쓰인다.
문자열 <code>mode</code>는 <a href="#lua_load"><code>lua_load</code></a> 함수에서처럼 동작한다.





<hr><h3><a name="luaL_loadfile"><code>luaL_loadfile</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>int luaL_loadfile (lua_State *L, const char *filename);</pre>

<p>
<code>mode</code>가 <code>NULL</code>인 <a href="#luaL_loadfilex"><code>luaL_loadfilex</code></a>와 동등하다.





<hr><h3><a name="luaL_loadfilex"><code>luaL_loadfilex</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>int luaL_loadfilex (lua_State *L, const char *filename,
                                            const char *mode);</pre>

<p>
파일에서 루아 청크를 적재한다.
<a href="#lua_load"><code>lua_load</code></a>를 사용해
이름이 <code>filename</code>인 파일에 있는 청크를 적재한다.
<code>filename</code>이 <code>NULL</code>이면
표준 입력을 읽어서 적재한다.
파일 첫 행이 <code>#</code>로 시작하면 그 행을 무시한다.


<p>
문자열 <code>mode</code>는 <a href="#lua_load"><code>lua_load</code></a> 함수에서처럼 동작한다.


<p>
이 함수는 <a href="#lua_load"><code>lua_load</code></a>와 같은 결과를 반환하되,
파일 관련 오류(가령 파일을 열거나 읽을 수 없음)에 대한
오류 코드 <a name="pdf-LUA_ERRFILE"><code>LUA_ERRFILE</code></a>이 추가로 있다.


<p>
<a href="#lua_load"><code>lua_load</code></a>처럼 이 함수는 청크 적재만 하고
실행은 하지 않는다.





<hr><h3><a name="luaL_loadstring"><code>luaL_loadstring</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_loadstring (lua_State *L, const char *s);</pre>

<p>
문자열에서 루아 청크를 적재한다.
<a href="#lua_load"><code>lua_load</code></a>를 사용해
영 종료 문자열 <code>s</code>에 있는 청크를 적재한다.


<p>
이 함수는 <a href="#lua_load"><code>lua_load</code></a>와 같은 결과를 반환한다.


<p>
또한 <a href="#lua_load"><code>lua_load</code></a>처럼 이 함수는 청크 적재만 하고
실행은 하지 않는다.





<hr><h3><a name="luaL_newlib"><code>luaL_newlib</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void luaL_newlib (lua_State *L, const luaL_Reg l[]);</pre>

<p>
새 테이블을 만들어서
목록 <code>l</code>의 함수들을 거기 등록한다.


<p>
다음 매크로로 구현되어 있다.

<pre>
     (luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))
</pre><p>
배열 <code>l</code>이 배열 포인터가 아니라
실제 배열이어야 한다.





<hr><h3><a name="luaL_newlibtable"><code>luaL_newlibtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void luaL_newlibtable (lua_State *L, const luaL_Reg l[]);</pre>

<p>
배열 <code>l</code>의 전체 항목을 저장하기에 최적인 크기로
새 테이블을 만든다.
(실제로 저장하지는 않는다.)
<a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a>와 함께 쓰기 위한 것이다.
(<a href="#luaL_newlib"><code>luaL_newlib</code></a> 참고.)


<p>
매크로로 구현되어 있다.
배열 <code>l</code>이 배열 포인터가 아니라
실제 배열이어야 한다.





<hr><h3><a name="luaL_newmetatable"><code>luaL_newmetatable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>int luaL_newmetatable (lua_State *L, const char *tname);</pre>

<p>
레지스트리에 키 <code>tname</code>이 이미 있으면
0을 반환한다.
그렇지 않으면
userdata의 메타테이블로 쓸 새 테이블을 만들고,
그 테이블에 <code>__name = tname</code> 쌍을 추가하고,
레지스트리에 <code>[tname] = 새 테이블</code> 쌍을 추가하고,
1을 반환한다.
(몇몇 오류 보고 함수에서 <code>__name</code> 항목을 이용한다.)


<p>
두 경우 모두 레지스트리에서 <code>tname</code>에 연계된
최종 값을 스택에 집어넣는다.





<hr><h3><a name="luaL_newstate"><code>luaL_newstate</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *luaL_newstate (void);</pre>

<p>
새 루아 상태를 만든다.
표준 C <code>realloc</code> 함수 기반 할당자로
<a href="#lua_newstate"><code>lua_newstate</code></a>를 호출하고서,
치명적 오류 시 표준 오류 출력에 오류 메시지를 찍는
패닉 함수(<a href="#4.6">4.6절</a>)를 설정한다.


<p>
새 상태를 반환한다.
메모리 할당 오류 발생 시 <code>NULL</code>을 반환한다.





<hr><h3><a name="luaL_openlibs"><code>luaL_openlibs</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void luaL_openlibs (lua_State *L);</pre>

<p>
지정한 상태 안에서 표준 루아 라이브러리 모두를 연다.





<hr><h3><a name="luaL_opt"><code>luaL_opt</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>T luaL_opt (L, func, arg, dflt);</pre>

<p>
이 매크로는 다음과 같이 정의되어 있다.

<pre>
     (lua_isnoneornil(L,(arg)) ? (dflt) : func(L,(arg)))
</pre><p>
말로 하자면, <code>arg</code> 번째 인자가 nil이거나 존재하지 않으면
기본값 <code>dflt</code>가 매크로 결과가 된다.
그렇지 않으면 상태 <code>L</code>과 인자 인덱스 <code>arg</code>를
매개변수로 해서 <code>func</code>를 호출한 결과를 내놓는다.
식 <code>dflt</code>를 필요시에만 평가한다는 점에 유의하라.





<hr><h3><a name="luaL_optinteger"><code>luaL_optinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Integer luaL_optinteger (lua_State *L,
                             int arg,
                             lua_Integer d);</pre>

<p>
<code>arg</code> 번째 함수 인자가 정수이면
(또는 정수로 변환 가능하면)
그 정수를 반환한다.
그 인자가 존재하지 않거나 <b>nil</b>이면
<code>d</code>를 반환한다.
그 외 경우에는 오류를 제기한다.





<hr><h3><a name="luaL_optlstring"><code>luaL_optlstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_optlstring (lua_State *L,
                             int arg,
                             const char *d,
                             size_t *l);</pre>

<p>
<code>arg</code> 번째 함수 인자가 문자열이면
그 문자열을 반환한다.
그 인자가 존재하지 않거나 <b>nil</b>이면
<code>d</code>를 반환한다.
그 외 경우에는 오류를 제기한다.


<p>
<code>l</code>이 <code>NULL</code>이 아니면
<code>*l</code> 위치에 결과의 길이를 채운다.
결과가 <code>NULL</code>이면
(<code>d</code>를 반환하는데 <code>d == NULL</code>일 때만 가능)
길이가 0이라고 본다.


<p>
이 함수는 <a href="#lua_tolstring"><code>lua_tolstring</code></a>을 써서 결과를 얻는다.
따라서 그 함수의 모든 변환 방식과 주의 사항이 여기에도 적용된다.





<hr><h3><a name="luaL_optnumber"><code>luaL_optnumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Number luaL_optnumber (lua_State *L, int arg, lua_Number d);</pre>

<p>
<code>arg</code> 번째 함수 인자가 수이면
그 수를 반환한다.
그 인자가 존재하지 않거나 <b>nil</b>이면
<code>d</code>를 반환한다.
그 외 경우에는 오류를 제기한다.





<hr><h3><a name="luaL_optstring"><code>luaL_optstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_optstring (lua_State *L,
                            int arg,
                            const char *d);</pre>

<p>
<code>arg</code> 번째 함수 인자가 문자열이면
그 문자열을 반환한다.
그 인자가 존재하지 않거나 <b>nil</b>이면
<code>d</code>를 반환한다.
그 외 경우에는 오류를 제기한다.





<hr><h3><a name="luaL_prepbuffer"><code>luaL_prepbuffer</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
<pre>char *luaL_prepbuffer (luaL_Buffer *B);</pre>

<p>
미리 정의된 크기 <a name="pdf-LUAL_BUFFERSIZE"><code>LUAL_BUFFERSIZE</code></a>를 쓰는
<a href="#luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a>와 동등하다.





<hr><h3><a name="luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
<pre>char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz);</pre>

<p>
크기가 <code>sz</code>인 공간의 주소를 반환한다.
그리로 문자열을 복사해서 버퍼 <code>B</code>에 추가시킬 수 있다.
(<a href="#luaL_Buffer"><code>luaL_Buffer</code></a> 참고.)
그 공간에 문자열을 복사한 후에
문자열 크기로 <a href="#luaL_addsize"><code>luaL_addsize</code></a>를 호출해야
실제로 버퍼에 추가된다.





<hr><h3><a name="luaL_pushresult"><code>luaL_pushresult</code></a></h3><p>
<span class="apii">[-?, +1, <em>m</em>]</span>
<pre>void luaL_pushresult (luaL_Buffer *B);</pre>

<p>
버퍼 <code>B</code> 사용을 끝마치고 최종 문자열을
스택 상단에 둔다.





<hr><h3><a name="luaL_pushresultsize"><code>luaL_pushresultsize</code></a></h3><p>
<span class="apii">[-?, +1, <em>m</em>]</span>
<pre>void luaL_pushresultsize (luaL_Buffer *B, size_t sz);</pre>

<p>
<a href="#luaL_addsize"><code>luaL_addsize</code></a>, <a href="#luaL_pushresult"><code>luaL_pushresult</code></a> 연속 호출과 동등하다.





<hr><h3><a name="luaL_ref"><code>luaL_ref</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
<pre>int luaL_ref (lua_State *L, int t);</pre>

<p>
스택 상단에 있는 객체에 대한 <em>참조</em>를
인덱스 <code>t</code>에 있는 테이블에 만들고
그 참조를 반환한다.
(그리고 그 객체를 꺼낸다.)


<p>
참조는 유일무이한 정수 키이다.
테이블 <code>t</code>에 직접 정수 키를 추가하지 않는 한
<a href="#luaL_ref"><code>luaL_ref</code></a>는 반환하는 키의 유일성을 보장한다.
<code>lua_rawgeti(L, t, r)</code> 호출로
참조 <code>r</code>이 가리키는 객체를 가져올 수 있다.
<a href="#luaL_unref"><code>luaL_unref</code></a> 함수로 참조 및 연관 객체를 해제한다.


<p>
스택 상단의 객체가 <b>nil</b>이면
<a href="#luaL_ref"><code>luaL_ref</code></a>는 상수 <a name="pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>을 반환한다.
상수 <a name="pdf-LUA_NOREF"><code>LUA_NOREF</code></a>는 <a href="#luaL_ref"><code>luaL_ref</code></a>가 반환하는 어떤 참조와도 다르다고 보장된다.





<hr><h3><a name="luaL_Reg"><code>luaL_Reg</code></a></h3>
<pre>typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;</pre>

<p>
<a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a>로
등록할 함수 배열을 위한 타입.
<code>name</code>은 함수 이름이고
<code>func</code>는 함수 포인터이다.
<a href="#luaL_Reg"><code>luaL_Reg</code></a>의 배열은
<code>name</code>과 <code>func</code>가 모두 <code>NULL</code>인
경계 항목으로 끝나야 한다.





<hr><h3><a name="luaL_requiref"><code>luaL_requiref</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void luaL_requiref (lua_State *L, const char *modname,
                    lua_CFunction openf, int glb);</pre>

<p>
<a href="#pdf-package.loaded"><code>package.loaded</code></a>에 <code>modname</code>이 이미 있지 않으면
문자열 <code>modname</code>을 인자로 해서 <code>openf</code> 함수를 호출한다.
그리고 그 함수가 <a href="#pdf-require"><code>require</code></a>를 통해 호출된 것처럼
호출 결과를 <code>package.loaded[modname]</code>에 설정한다.


<p>
<code>glb</code>가 참이면
전역 <code>modname</code>에도 모듈을 저장한다.


<p>
모듈의 사본을 스택에 둔다.





<hr><h3><a name="luaL_setfuncs"><code>luaL_setfuncs</code></a></h3><p>
<span class="apii">[-nup, +0, <em>m</em>]</span>
<pre>void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup);</pre>

<p>
배열 <code>l</code>의 모든 함수들을
(<a href="#luaL_Reg"><code>luaL_Reg</code></a> 참고)
스택 상단에 있는 (위에 upvalue가 있을 수도 있음. 이어지는 내용 참고)
테이블에 등록한다.


<p>
<code>nup</code>가 0이 아니면
<code>nup</code>개 upvalue를 공유하게 해서 모든 함수를 생성한다.
그 upvalue들을 스택에서 라이브러리 테이블 위에 미리 집어넣어야 한다.
등록 후 스택에서 그 값들이 빠진다.





<hr><h3><a name="luaL_setmetatable"><code>luaL_setmetatable</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_setmetatable (lua_State *L, const char *tname);</pre>

<p>
스택 상단에 있는 객체의 메타테이블을
레지스트리에서 이름 <code>tname</code>에 연계된
메타테이블로 설정한다.
(<a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a> 참고.)





<hr><h3><a name="luaL_Stream"><code>luaL_Stream</code></a></h3>
<pre>typedef struct luaL_Stream {
  FILE *f;
  lua_CFunction closef;
} luaL_Stream;</pre>

<p>
표준 I/O 라이브러리에서 사용하는
파일 핸들 표준 표현 방식이다.


<p>
파일 핸들은 <code>LUA_FILEHANDLE</code>이라는 메타테이블을 가진
full userdata로 구현되어 있다.
(<code>LUA_FILEHANDLE</code>은 실제 메타테이블 이름을 나타내는 매크로이다.)
I/O 라이브러리에서 그 메타테이블을 만든다.
(<a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a> 참고.)


<p>
그 userdata는 시작 부분이 <code>luaL_Stream</code> 구조체여야 한다.
그 초반 구조 뒤에 다른 데이터를 담을 수 있다.
필드 <code>f</code>는 대응하는 C 스트림에 대한 포인터이다.
(또는 생성 미완료 핸들을 나타내는 <code>NULL</code>일 수 있다.)
필드 <code>closef</code>는 핸들이 닫히거나 수집될 때
호출되어 스트림을 닫아 줄 루아 함수를 가리킨다.
이 함수는 파일 핸들을 유일한 인자로 받으며
(성공 시) <b>true</b> 또는
(오류 시) <b>nil</b>에 더해 오류 메시지를 반환해야 한다.
이 필드를 호출한 다음
루아에서 필드 값을 <code>NULL</code>로 바꾸어
핸들이 닫혔음을 표시한다.





<hr><h3><a name="luaL_testudata"><code>luaL_testudata</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>void *luaL_testudata (lua_State *L, int arg, const char *tname);</pre>

<p>
이 함수는 <a href="#luaL_checkudata"><code>luaL_checkudata</code></a>처럼 동작하되,
검사 실패 시 오류를 제기하는 대신 <code>NULL</code>을 반환한다.





<hr><h3><a name="luaL_tolstring"><code>luaL_tolstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *luaL_tolstring (lua_State *L, int idx, size_t *len);</pre>

<p>
지정한 인덱스에 있는 어떤 루아 값이든
적당한 형식의 C 문자열로 변환한다.
결과 문자열을 스택에 집어넣고 반환도 한다.
또한 <code>len</code>이 <code>NULL</code>이 아니면
<code>*len</code>에 문자열 길이를 설정한다.


<p>
그 값에 메타테이블이 있고 <code>__tostring</code> 필드가 있으면
<code>luaL_tolstring</code>에서 값을 인자로 해서 해당 메타메소드를 호출하여
호출 결과를 자기 결과로 쓴다.





<hr><h3><a name="luaL_traceback"><code>luaL_traceback</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void luaL_traceback (lua_State *L, lua_State *L1, const char *msg,
                     int level);</pre>

<p>
스택 <code>L1</code>의 트레이스백을 만들어서 집어넣는다.
<code>msg</code>가 <code>NULL</code>이 아니면
트레이스백 앞쪽에 덧붙인다.
<code>level</code> 매개변수는 어느 단계에서
트레이스백을 시작할지 알려 준다.





<hr><h3><a name="luaL_typename"><code>luaL_typename</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const char *luaL_typename (lua_State *L, int index);</pre>

<p>
지정한 인덱스에 있는 값의 타입 이름을 반환한다.





<hr><h3><a name="luaL_unref"><code>luaL_unref</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_unref (lua_State *L, int t, int ref);</pre>

<p>
인덱스 <code>t</code>에 있는 테이블에서 참조 <code>ref</code>를 해제한다.
(<a href="#luaL_ref"><code>luaL_ref</code></a> 참고.)
테이블에서 항목을 제거하여
피참조 객체가 수집될 수 있게 한다.
참조 <code>ref</code>도 해제하여 다시 쓸 수 있게 한다.


<p>
<code>ref</code>가 <a href="#pdf-LUA_NOREF"><code>LUA_NOREF</code></a>나 <a href="#pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>이면
<a href="#luaL_unref"><code>luaL_unref</code></a>는 아무것도 하지 않는다.





<hr><h3><a name="luaL_where"><code>luaL_where</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void luaL_where (lua_State *L, int lvl);</pre>

<p>
호출 스택 <code>lvl</code>번 단계에서의 현재 제어 위치를 나타내는
문자열을 스택에 집어넣는다.
보통 이 문자열은 다음 형식이다.

<pre>
     <em>청크이름</em>:<em>현재행</em>:
</pre><p>
0번 단계가 동작 중인 함수이고
1번 단계가 그 동작 중인 함수를 호출한 함수인 식이다.


<p>
오류 메시지 시작 부분을 만드는 데 이 함수가 쓰인다.







<h1>6 &ndash; <a name="6">표준 라이브러리</a></h1>

<p>
표준 루아 라이브러리들은 C API를 통해 직접 구현한
유용한 함수들을 제공한다.
그 함수들 중 일부는 언어에 필수적인 서비스를 제공한다.
(예: <a href="#pdf-type"><code>type</code></a>, <a href="#pdf-getmetatable"><code>getmetatable</code></a>.)
다른 일부는 "외부" 서비스에 접근할 수 있게 해 준다. (예: I/O.)
또 다른 일부는 루아 자체에서 구현할 수도 있었지만
C로 구현할 만큼 상당히 유용하거나 중요한 성능상 요구가 있다.
(예: <a href="#pdf-table.sort"><code>table.sort</code></a>.)


<p>
모든 라이브러리들은 공식 C API를 통해 구현되어 있으며
별도의 C 모듈로 제공된다.
현재 루아에는 다음 표준 라이브러리가 있다.

<ul>

<li>기본 라이브러리 (<a href="#6.1">6.1절</a>)</li>

<li>코루틴 라이브러리 (<a href="#6.2">6.2절</a>)</li>

<li>패키지 라이브러리 (<a href="#6.3">6.3절</a>)</li>

<li>문자열 조작 (<a href="#6.4">6.4절</a>)</li>

<li>기본적인 UTF-8 지원 (<a href="#6.5">6.5절</a>)</li>

<li>테이블 조작 (<a href="#6.6">6.6절</a>)</li>

<li>수학 함수 (<a href="#6.7">6.7절</a>) (sin, log 등)</li>

<li>입력과 출력 (<a href="#6.8">6.8절</a>)</li>

<li>운영 체제 기능 (<a href="#6.9">6.9절</a>)</li>

<li>디버그 기능 (<a href="#6.10">6.10절</a>)</li>

</ul><p>
기본 라이브러리와 패키지 라이브러리를 제외한 다른 라이브러리들은
모든 함수를 전역 테이블의 필드나 객체의 메소드로 제공한다.


<p>
C 호스트 프로그램에서 이 라이브러리들에 접근하려면
<a href="#luaL_openlibs"><code>luaL_openlibs</code></a>를 호출하면 된다.
그러면 모든 표준 라이브러리들을 연다.
또는 개별적으로 열기 위해 호스트 프로그램에서
<a href="#luaL_requiref"><code>luaL_requiref</code></a>를 사용해
<a name="pdf-luaopen_base"><code>luaopen_base</code></a> (기본 라이브러리),
<a name="pdf-luaopen_package"><code>luaopen_package</code></a> (패키지 라이브러리),
<a name="pdf-luaopen_coroutine"><code>luaopen_coroutine</code></a> (코루틴 라이브러리),
<a name="pdf-luaopen_string"><code>luaopen_string</code></a> (문자열 라이브러리),
<a name="pdf-luaopen_utf8"><code>luaopen_utf8</code></a> (UTF8 라이브러리),
<a name="pdf-luaopen_table"><code>luaopen_table</code></a> (테이블 라이브러리),
<a name="pdf-luaopen_math"><code>luaopen_math</code></a> (수학 라이브러리),
<a name="pdf-luaopen_io"><code>luaopen_io</code></a> (I/O 라이브러리),
<a name="pdf-luaopen_os"><code>luaopen_os</code></a> (운영 체제 라이브러리),
<a name="pdf-luaopen_debug"><code>luaopen_debug</code></a> (디버그 라이브러리)를
호출할 수 있다.
<a name="pdf-lualib.h"><code>lualib.h</code></a>에 이 함수들이 선언되어 있다.



<h2>6.1 &ndash; <a name="6.1">기본 함수</a></h2>

<p>
기본 라이브러리는 루아에 핵심 함수들을 제공한다.
응용에 이 라이브러리를 포함시키지 않는다면
그 요소들 중 일부를 대신하는 구현을 제공해야 할지 여부를
조심스럽게 점검해 보아야 할 것이다.


<p>
<hr><h3><a name="pdf-assert"><code>assert (v [, message])</code></a></h3>


<p>
인자 <code>v</code>의 값이 거짓(즉 <b>nil</b>이나 <b>false</b>)이면
<a href="#pdf-error"><code>error</code></a>를 호출한다.
그렇지 않으면 인자 전체를 반환한다.
error 호출 경우에
<code>message</code>가 오류 객체가 된다.
그 인자가 없으면 "<code>assertion failed!</code>"를 쓴다.




<p>
<hr><h3><a name="pdf-collectgarbage"><code>collectgarbage ([opt [, arg]])</code></a></h3>


<p>
이 함수는 쓰레기 수집기에 대한 포괄적 인터페이스이다.
첫 번째 인자 <code>opt</code>에 따라서 다양한 기능을 수행한다.

<ul>

<li><b>"<code>collect</code>": </b>
쓰레기 수집 주기 한 번을 수행한다.
기본 옵션이다.
</li>

<li><b>"<code>stop</code>": </b>
쓰레기 수집기의 자동 실행을 멈춘다.
재시작 호출 전까지는
명시적으로 부를 때만 수집기가 돌게 된다.
</li>

<li><b>"<code>restart</code>": </b>
쓰레기 수집기의 자동 실행을 재시작한다.
</li>

<li><b>"<code>count</code>": </b>
루아에서 사용 중인 메모리의 (KB 단위) 총량을 반환한다.
값에 수소 부분이 있어서
1024로 곱하면
(오버플로우 되지 않는다면)
루아가 사용 중인 정확한 바이트 수가 나온다.
</li>

<li><b>"<code>step</code>": </b>
쓰레기 수집 단계를 수행한다.
단계 "크기"를 <code>arg</code>로 조절한다.
값이 0이면
(쪼갤 수 없는) 기본 단계 한 번을 수집기가 수행한다.
값이 0이 아니면
루아가 메모리를 그만큼 (KB 단위) 할당한 것처럼
수집기가 동작을 수행한다.
그 단계로 한 수집 주기가 끝난 경우 <b>true</b>를 반환한다.
</li>

<li><b>"<code>setpause</code>": </b>
<code>arg</code>를 수집기의 <em>휴지 시간</em>(<a href="#2.5">2.5절</a>)
새 값으로 설정한다.
<em>휴지 시간</em>의 이전 값을 반환한다.
</li>

<li><b>"<code>setstepmul</code>": </b>
<code>arg</code>를 수집기의 <em>단계 승수</em>(<a href="#2.5">2.5절</a>)
새 값으로 설정한다.
<em>단계 승수</em>의 이전 값을 반환한다.
</li>

<li><b>"<code>isrunning</code>": </b>
수집기가 동작 중인지를 (즉 중단되지 않았는지를) 알려 주는
불리언을 반환한다.
</li>

</ul>



<p>
<hr><h3><a name="pdf-dofile"><code>dofile ([filename])</code></a></h3>
지명한 파일을 열어서 그 내용을 루아 청크로서 실행한다.
인자 없이 호출 시
<code>dofile</code>은 표준 입력(<code>stdin</code>)의 내용을 실행한다.
청크가 반환한 모든 값을 반환한다.
오류 발생 시 <code>dofile</code>은 그 오류를
호출자에게 전파한다. (즉 <code>dofile</code>은 보호 모드로 돌지 않는다.)




<p>
<hr><h3><a name="pdf-error"><code>error (message [, level])</code></a></h3>
마지막으로 보호 모드로 호출된 함수를 끝내고
<code>message</code>를 오류 객체로 반환한다.
함수 <code>error</code>는 절대 반환하지 않는다.


<p>
메시지가 문자열이면 일반적으로 <code>error</code>에서
메시지 시작 부분에 오류 위치에 대한 정보를 좀 추가한다.
<code>level</code> 인자는 그 오류 위치를 어떻게 얻을 수 있는지를 나타낸다.
단계가 1(기본값)이면 <code>error</code> 함수를 호출한 지점이
오류 위치이다.
또 단계 2는 <code>error</code>를 호출한 함수를 호출했던
위치를 나타내고 하는 식이다.
단계를 0으로 주면 메시지에 오류 위치 정보를 추가하지 않는다.




<p>
<hr><h3><a name="pdf-_G"><code>_G</code></a></h3>
전역 환경(<a href="#2.2">2.2절</a>)을 가지고 있는
전역 변수이다. (함수가 아니다.)
루아 자체에서는 이 변수를 쓰지 않는다.
값을 바꿔도 아무 환경에도 영향을 주지 않으며
그 반대도 마찬가지이다.




<p>
<hr><h3><a name="pdf-getmetatable"><code>getmetatable (object)</code></a></h3>


<p>
<code>object</code>에 메타테이블이 없으면 <b>nil</b>을 반환한다.
그렇지 않고
객체의 메타테이블에 <code>__metatable</code> 필드가 있으면
연계된 값을 반환한다.
그 외 경우에는 지정한 객체의 메타테이블을 반환한다.




<p>
<hr><h3><a name="pdf-ipairs"><code>ipairs (t)</code></a></h3>


<p>
세 값(반복자 함수, 테이블 <code>t</code>, 0)을 반환한다.
그래서 다음과 같이 쓰면

<pre>
     for i,v in ipairs(t) do <em>body</em> end
</pre><p>
(<code>1,t[1]</code>), (<code>2,t[2]</code>), ...
식으로 모든 키&ndash;값 쌍에 대해서
빈 값이 나올 때까지 반복하게 된다.




<p>
<hr><h3><a name="pdf-load"><code>load (chunk [, chunkname [, mode [, env]]])</code></a></h3>


<p>
청크를 적재한다.


<p>
<code>chunk</code>가 문자열이면 이 문자열이 청크이다.
<code>chunk</code>가 함수이면
<code>load</code>에서 이를 반복 호출해서 청크 조각들을 얻는다.
각 <code>chunk</code> 호출에서는 이전 결과들에서 이어지는
문자열을 반환해야 한다.
빈 문자열 내지 <b>nil</b>을 반환하거나 아무 값도 반환하지 않는 것으로
청크 끝을 나타낸다.


<p>
구문 오류가 없으면
컴파일 한 청크를 함수 형태로 반환한다.
그렇지 않으면 <b>nil</b>에 더해 오류 메시지를 반환한다.


<p>
결과 함수에 upvalue가 있는 경우에는
<code>env</code> 매개변수가 있으면 그 값으로,
아니면 전역 환경의 값으로
첫 번째 upvalue를 설정한다.
다른 upvalue들은 <b>nil</b>로 초기화 한다.
(메인 청크를 적재할 때는
결과 함수에 항상 정확히 한 개의 upvalue,
즉 <code>_ENV</code> 변수만 있게 된다. (<a href="#2.2">2.2절</a> 참고.)
하지만 함수로부터 만든 바이너리 청크를 적재할 때는
(<a href="#pdf-string.dump"><code>string.dump</code></a> 참고)
결과 함수에 임의 개수의 upvalue가 있을 수 있다.)
모든 upvalue들은 새것이다.
즉 다른 함수와 공유하지 않는다.


<p>
<code>chunkname</code>은 오류 메시지와 디버그 정보(<a href="#4.9">4.9절</a>)에서
청크 이름으로 쓴다.
없을 때는
<code>chunk</code>가 문자열이면 <code>chunk</code>를 쓰고
아니면 "<code>=(load)</code>"를 쓴다.


<p>
문자열 <code>mode</code>는 청크가 텍스트나 바이너리(즉 미리 컴파일 한 청크)일
수 있는지를 제어한다.
문자열 "<code>b</code>"(바이너리 청크만), "<code>t</code>"(텍스트 청크만),
"<code>bt</code>"(바이너리와 텍스트 모두)일 수 있다.
기본은 "<code>bt</code>"이다.


<p>
루아에서 바이너리 청크의 무모순성을 검사하지 않는다.
악의적으로 조작된 바이너리 청크 때문에
인터프리터가 비정상 동작하게 될 수 있다.




<p>
<hr><h3><a name="pdf-loadfile"><code>loadfile ([filename [, mode [, env]]])</code></a></h3>


<p>
<a href="#pdf-load"><code>load</code></a>와 비슷하되,
파일 <code>filename</code>으로부터
또는 파일 이름이 없으면
표준 입력으로부터 청크를 얻는다.




<p>
<hr><h3><a name="pdf-next"><code>next (table [, index])</code></a></h3>


<p>
프로그램에서 테이블의 모든 필드를 순회할 수 있게 해 준다.
첫 번째 인자는 테이블이고
두 번째 인자는 그 테이블 내 인덱스이다.
<code>next</code>는 테이블의 다음 인덱스와
그 연계 값을 반환한다.
두 번째 인자를 <b>nil</b>로 해서 호출하면
<code>next</code>가 시작 인덱스와
그 연계 값을 반환한다.
마지막 인덱스로 호출하거나
빈 테이블에서 <b>nil</b>로 호출하면
<code>next</code>가 <b>nil</b>을 반환한다.
두 번째 인자가 없으면 <b>nil</b>로 해석한다.
그래서 <code>next(t)</code>를 써서 테이블이 비어 있는지 확인할 수 있다.


<p>
인덱스를 내놓는 순서가 명세되어 있지 않으며
<em>숫자 인덱스도 마찬가지이다</em>.
(수 순서로 테이블을 순회하려면
수열형 <b>for</b>를 쓰면 된다.)


<p>
순회 도중에
테이블 내의 존재하지 않는 필드에 값을 할당하는 경우
<code>next</code>의 동작 방식이 규정되어 있지 않다.
하지만 기존 필드를 변경할 수는 있다.
특히 기존 필드들을 모두 비울 수 있다.




<p>
<hr><h3><a name="pdf-pairs"><code>pairs (t)</code></a></h3>


<p>
<code>t</code>에 메타메소드 <code>__pairs</code>가 있으면
<code>t</code>를 인자로 해서 호출하고
그 호출의 처음 세 개 결과를 반환한다.


<p>
그렇지 않으면 <a href="#pdf-next"><code>next</code></a> 함수, 테이블 <code>t</code>, <b>nil</b>,
이렇게 세 값을 반환한다.
그래서 다음과 같이 쓰면

<pre>
     for k,v in pairs(t) do <em>body</em> end
</pre><p>
테이블 <code>t</code>의 모든 키&ndash;값 쌍에 대해서 반복하게 된다.


<p>
테이블 순회 중 변경에 대한 주의 사항은
함수 <a href="#pdf-next"><code>next</code></a>를 보라.




<p>
<hr><h3><a name="pdf-pcall"><code>pcall (f [, arg1, &middot;&middot;&middot;])</code></a></h3>


<p>
주어진 인자들을 가지고 함수 <code>f</code>를
<em>보호 모드</em>로 호출한다.
<code>f</code> 안에서 오류가 발생하더라도 전파되지 않는다는 의미이다.
대신 <code>pcall</code>이 그 오류를 잡아서
상태 코드를 반환한다.
첫 번째 결과는 상태 코드(불리언)인데
호출이 오류 없이 성공하면 참이다.
그 경우 호출의 모든 결과를 <code>pcall</code>이
첫 번째 결과 뒤에 붙여서 반환한다.
오류 발생 시에는 <code>pcall</code>이 <b>false</b>에 더해 오류 메시지를 반환한다.




<p>
<hr><h3><a name="pdf-print"><code>print (&middot;&middot;&middot;)</code></a></h3>
임의 개수의 인자를 받아서
<a href="#pdf-tostring"><code>tostring</code></a> 함수로 각 인자를 문자열로 변환하여
그 값들을 <code>stdout</code>으로 찍는다.
<code>print</code>는 서식을 준 출력을 위한 것이 아니다.
디버깅 등을 위해
간단히 값을 표시하는 방법일 뿐이다.
출력을 완전히 제어하려면
<a href="#pdf-string.format"><code>string.format</code></a>과 <a href="#pdf-io.write"><code>io.write</code></a>를 쓰면 된다.




<p>
<hr><h3><a name="pdf-rawequal"><code>rawequal (v1, v2)</code></a></h3>
<code>__eq</code> 메타메소드 호출 없이
<code>v1</code>이 <code>v2</code>와 같은지 확인한다.
불리언을 반환한다.




<p>
<hr><h3><a name="pdf-rawget"><code>rawget (table, index)</code></a></h3>
<code>__index</code> 메타메소드 호출 없이
<code>table[index]</code>의 진짜 값을 얻는다.
<code>table</code>은 테이블이어야 하며
<code>index</code>는 아무 값이나 가능하다.




<p>
<hr><h3><a name="pdf-rawlen"><code>rawlen (v)</code></a></h3>
<code>__len</code> 메타메소드 호출 없이
객체 <code>v</code>의 길이를 반환한다.
<code>v</code>는 테이블이나 문자열이어야 한다.
정수를 반환한다.




<p>
<hr><h3><a name="pdf-rawset"><code>rawset (table, index, value)</code></a></h3>
<code>__newindex</code> 메타메소드 호출 없이
<code>table[index]</code>의 진짜 값을 <code>value</code>로 설정한다.
<code>table</code>은 테이블이어야 한다.
<code>index</code>는 <b>nil</b>과 NaN를 제외한 아무 값이나 가능하고
<code>value</code>는 아무 루아 값이나 가능하다.


<p>
이 함수는 <code>table</code>을 반환한다.




<p>
<hr><h3><a name="pdf-select"><code>select (index, &middot;&middot;&middot;)</code></a></h3>


<p>
<code>index</code>가 수이면
<code>index</code> 번째 인자 뒤의 인자들을 모두 반환한다.
음수는 끝부터 인덱스를 센다. (-1이 마지막 인자이다.)
수가 아니면 <code>index</code>가 문자열 <code>"#"</code>이어야 하며
<code>select</code>가 받은 그 외 추가 인자들의 총개수를 반환한다.




<p>
<hr><h3><a name="pdf-setmetatable"><code>setmetatable (table, metatable)</code></a></h3>


<p>
지정한 테이블의 메타테이블을 설정한다.
(루아 코드에서 다른 타입들의 메타테이블을 바꾸려면
디버그 라이브러리(<a href="#6.10">6.10절</a>)를 사용해야 한다.)
<code>metatable</code>이 <b>nil</b>이면
지정한 테이블의 메타테이블을 제거한다.
그 원래 메타테이블에 <code>__metatable</code> 필드가 있으면
오류를 제기한다.


<p>
이 함수는 <code>table</code>을 반환한다.




<p>
<hr><h3><a name="pdf-tonumber"><code>tonumber (e [, base])</code></a></h3>


<p>
<code>base</code> 없이 호출 시
<code>tonumber</code>는 인자를 수로 변환하려고 시도한다.
인자가 이미 수이거나
수로 변환 가능한 문자열이면
그 수를 반환한다.
그렇지 않으면 <b>nil</b>을 반환한다.


<p>
문자열 변환 결과는 루아 어휘 규정에 따라
정수나 실수가 될 수 있다. (<a href="#3.1">3.1절</a> 참고.)
(문자열에 전후 공백과 부호가 있을 수 있다.)


<p>
<code>base</code>를 주고 호출 시
<code>e</code>는 그 진법에서
정수로 해석되는 문자열이어야 한다.
기수로 2에서 36까지 어떤 정수도 가능하다.
10을 넘는 진법에서는 (대문자 또는 소문자) 글자 '<code>A</code>'가 10을 나타내고
'<code>B</code>'가 11을 나타내고,
그런 식으로 '<code>Z</code>'는 35를 나타낸다.
지정한 진법에서 문자열 <code>e</code>가 유효한 숫자가 아니면
함수가 <b>nil</b>을 반환한다.




<p>
<hr><h3><a name="pdf-tostring"><code>tostring (v)</code></a></h3>
어느 타입의 값이든 받아서
사람이 읽을 수 있는 형식의 문자열로 변환한다.
(수가 변환되는 방식을 완전히 제어하려면
<a href="#pdf-string.format"><code>string.format</code></a>을 쓰면 된다.)


<p>
<code>v</code>의 메타테이블에 <code>__tostring</code> 필드가 있으면
해당하는 값을 <code>v</code>를 인자로 해서 호출하여
호출 결과를 <code>tostring</code>의 결과로 쓴다.




<p>
<hr><h3><a name="pdf-type"><code>type (v)</code></a></h3>
유일한 인자의 타입을 문자열 형태로 반환한다.
가능한 결과는
"<code>nil</code>" (값 <b>nil</b>이 아니라 문자열),
"<code>number</code>",
"<code>string</code>",
"<code>boolean</code>",
"<code>table</code>",
"<code>function</code>",
"<code>thread</code>",
"<code>userdata</code>"이다.




<p>
<hr><h3><a name="pdf-_VERSION"><code>_VERSION</code></a></h3>


<p>
동작 중인 루아 버전을 담은 문자열을 가지고 있는
전역 변수이다. (함수가 아니다.)
이 변수의 현행 값은 "<code>Lua 5.3</code>"이다.




<p>
<hr><h3><a name="pdf-xpcall"><code>xpcall (f, msgh [, arg1, &middot;&middot;&middot;])</code></a></h3>


<p>
이 함수는 <a href="#pdf-pcall"><code>pcall</code></a>과 유사하되,
새 메시지 핸들러 <code>msgh</code>를 설정한다.







<h2>6.2 &ndash; <a name="6.2">코루틴 조작</a></h2>

<p>
이 라이브러리는 코루틴을 조작하는 연산들로 이뤄져 있다.
테이블 <a name="#pdf-coroutine"><code>coroutine</code></a> 안에 연산들이 들어 있다.
코루틴에 대한 일반적 설명은 <a href="#2.6">2.6절</a>을 보라.


<p>
<hr><h3><a name="pdf-coroutine.create"><code>coroutine.create (f)</code></a></h3>


<p>
<code>f</code>를 몸체로 해서 새 코루틴을 만든다.
<code>f</code>는 함수여야 한다.
<code>"thread"</code> 타입 객체인
새 코루틴을 반환한다.




<p>
<hr><h3><a name="pdf-coroutine.isyieldable"><code>coroutine.isyieldable ()</code></a></h3>


<p>
동작 중인 코루틴이 양보할 수 있으면 참을 반환한다.


<p>
동작 중인 코루틴이 양보할 수 있으려면
메인 스레드가 아니고 양보 불가능한 C 함수 안에 있지 않으면 된다.




<p>
<hr><h3><a name="pdf-coroutine.resume"><code>coroutine.resume (co [, val1, &middot;&middot;&middot;])</code></a></h3>


<p>
코루틴 <code>co</code>의 실행을 시작하거나 계속한다.
코루틴을 처음 재개할 때는
그 몸체 실행을 시작한다.
<code>val1</code>, ... 값들이
몸체 함수에게 인자로 전달된다.
코루틴이 양보를 하고 난 후에
<code>resume</code>은 코루틴을 재시작한다.
<code>val1</code>, ... 값들이
yield의 결과로 전달된다.


<p>
코루틴이 오류 없이 돌면
<code>resume</code>이 <b>true</b>에 더해서
(코루틴이 양보할 때) <code>yield</code>로 전달한 값들이나
(코루틴이 끝날 때) 몸체 함수가 반환한 값들을 반환한다.
오류가 있으면
<code>resume</code>이 <b>false</b>에 더해 오류 메시지를 반환한다.




<p>
<hr><h3><a name="pdf-coroutine.running"><code>coroutine.running ()</code></a></h3>


<p>
동작 중인 코루틴과 더불어 불리언을 반환하는데,
동작 중인 코루틴이 메인이면 참이다.




<p>
<hr><h3><a name="pdf-coroutine.status"><code>coroutine.status (co)</code></a></h3>


<p>
코루틴 <code>co</code>의 상태를 문자열로 반환한다.
코루틴이 동작 중이면 (즉 거기서 <code>status</code>를 호출했으면)
<code>"running"</code>이고,
코루틴이 <code>yield</code> 호출 안에서 정지되어 있거나
아직 동작을 시작하지 않았으면 <code>"suspended"</code>이고,
코루틴이 활성이지만 동작 중이 아니면
(즉 다른 코루틴을 재개했으면) <code>"normal"</code>이고,
코루틴이 몸체 함수를 끝마쳤거나
오류로 중단되었으면 <code>"dead"</code>이다.




<p>
<hr><h3><a name="pdf-coroutine.wrap"><code>coroutine.wrap (f)</code></a></h3>


<p>
<code>f</code>를 몸체로 해서 새 코루틴을 만든다.
<code>f</code>는 함수여야 한다.
함수를 반환하며, 그 함수를 호출할 때마다 코루틴을 재개한다.
그 함수에 인자를 주면
<code>resume</code>에 준 추가 인자처럼 동작한다.
그리고 처음의 불리언을 제외하고
<code>resume</code>이 반환하는 것과 같은 값들을 반환한다.
오류 발생 시 오류를 전파한다.




<p>
<hr><h3><a name="pdf-coroutine.yield"><code>coroutine.yield (&middot;&middot;&middot;)</code></a></h3>


<p>
호출한 코루틴의 실행을 정지한다.
<code>yield</code>에 인자를 주면
<code>resume</code>의 추가 결과로 전달된다.







<h2>6.3 &ndash; <a name="6.3">모듈</a></h2>

<p>
패키지 라이브러리는 루아에서 모듈을 적재하기 위한
기본 요소들을 제공한다.
전역 환경으로 직접 내보내는 함수는
<a href="#pdf-require"><code>require</code></a> 하나이다.
나머지는 모두 테이블 <a name="#pdf-package"><code>package</code></a>를 통해 내보낸다.


<p>
<hr><h3><a name="pdf-require"><code>require (modname)</code></a></h3>


<p>
지정한 모듈을 적재한다.
먼저 <a href="#pdf-package.loaded"><code>package.loaded</code></a> 테이블을 확인해서
<code>modname</code>이 이미 적재되어 있는지 알아본다.
그 경우에는 <code>package.loaded[modname]</code>에 저장된 값을
<code>require</code>가 반환한다.
아닌 경우에는 그 모듈을 위한 <em>적재 함수</em>를 찾아 본다.


<p>
<code>require</code>에서 적재 함수를 찾는 동작은
<a href="#pdf-package.searchers"><code>package.searchers</code></a> 열에 따라 이뤄진다.
이 열을 바꾸면
<code>require</code>에서 모듈을 찾는 방식을 바꿀 수 있다.
이어지는 설명은 <a href="#pdf-package.searchers"><code>package.searchers</code></a>의
기본 설정을 기준으로 한 것이다.


<p>
<code>require</code>에서 먼저 <code>package.preload[modname]</code>을 확인한다.
값이 있으면 (함수여야 하는) 그 값이 적재 함수이다.
그렇지 않으면
<a href="#pdf-package.path"><code>package.path</code></a>에 저장된
경로를 이용해 루아 적재 함수를 탐색한다.
그것도 실패하면
<a href="#pdf-package.cpath"><code>package.cpath</code></a>에 저장된
경로를 이용해 C 적재 함수를 탐색한다.
그것도 실패하면
<em>일체형</em> 적재 함수를 시도한다.
(<a href="#pdf-package.searchers"><code>package.searchers</code></a> 참고.)


<p>
적재 함수를 찾으면
<code>modname</code>, 그리고 적재 함수를 찾은 방법에 따라 달라지는 어떤 추가 값을
인자로 해서 <code>require</code>에서 적재 함수를 호출한다.
(적재 함수가 파일에서 왔다면
그 추가 값은 파일 이름이다.)
적재 함수가 nil 아닌 값을 반환하면
<code>require</code>에서 그 반환 값을 <code>package.loaded[modname]</code>에 할당한다.
적재 함수가 nil 아닌 값을 반환하지 않고
<code>package.loaded[modname]</code>에 어떤 값도 할당하지 않았으면
<code>require</code>에서 그 항목에 <b>true</b>를 할당한다.
어느 경우이든 <code>package.loaded[modname]</code>의 최종 값을
<code>require</code>가 반환한다.


<p>
모듈 적재나 실행 중 오류가 있거나
모듈 적재 함수를 찾을 수 없는 경우에는
<code>require</code>가 오류를 제기한다.




<p>
<hr><h3><a name="pdf-package.config"><code>package.config</code></a></h3>


<p>
패키지에 관한 몇 가지 컴파일 타임 설정들을 기술하는 문자열.
이 문자열은 다음 행들이 이어진 것이다.

<ul>

<li>첫 번째 행은 디렉터리 구분 문자열이다.
기본값은 윈도우에서 '<code>\</code>'이고 다른 모든 시스템에서 '<code>/</code>'이다.</li>

<li>두 번째 행은 경로 내에서 템플릿들을 구분하는 문자이다.
기본값은 '<code>;</code>'이다.</li>

<li>세 번째 행은 템플릿 내에서 치환 지점을 표시하는 문자열이다.
기본값은 '<code>?</code>'이다.</li>

<li>네 번째 행은 윈도우 경로에서 실행 파일의 디렉터리로
바뀌는 문자열이다.
기본값은 '<code>!</code>'이다.</li>

<li>다섯 번째 행은 <code>luaopen_</code> 함수 이름을 만들어 낼 때
이후 텍스트를 모두 무시하게 하는 표시이다.
기본값은 '<code>-</code>'이다.</li>

</ul>



<p>
<hr><h3><a name="pdf-package.cpath"><code>package.cpath</code></a></h3>


<p>
<a href="#pdf-require"><code>require</code></a>에서 C 적재 함수 탐색에 쓰는 경로.


<p>
루아 경로 <a href="#pdf-package.path"><code>package.path</code></a>와 같은 방식으로
C 경로 <a href="#pdf-package.cpath"><code>package.cpath</code></a>를 초기화 한다.
환경 변수 <a name="#pdf-LUA_CPATH_5_3"><code>LUA_CPATH_5_3</code></a>이나
환경 변수 <a name="#pdf-LUA_CPATH"><code>LUA_CPATH</code></a>를 사용하거나
<code>luaconf.h</code>에 정의된 기본 경로를 사용한다.




<p>
<hr><h3><a name="pdf-package.loaded"><code>package.loaded</code></a></h3>


<p>
어느 모듈이 이미 적재되어 있는지를 제어하기 위해
<a href="#pdf-require"><code>require</code></a>에서 쓰는 테이블.
모듈 <code>modname</code>을 요구했는데
<code>package.loaded[modname]</code>이 거짓이 아니면
<a href="#pdf-require"><code>require</code></a>는 그냥 거기 저장되어 있는 값을 반환한다.


<p>
이 변수는 실제 테이블에 대한 참조일 뿐이다.
이 변수에 할당을 해도
<a href="#pdf-require"><code>require</code></a>에서 쓰는 테이블이 바뀌지 않는다.




<p>
<hr><h3><a name="pdf-package.loadlib"><code>package.loadlib (libname, funcname)</code></a></h3>


<p>
호스트 프로그램을 C 라이브러리 <code>libname</code>과 동적으로 링크 한다.


<p>
<code>funcname</code>이 "<code>*</code>"이면
라이브러리와 링크 해서
그 라이브러리가 내보내는 심볼들을
다른 동적 링크 라이브러리에서 사용할 수 있게 만들기만 한다.
그렇지 않으면
라이브러리 안에서 함수 <code>funcname</code>을 찾아서
그 함수를 C 함수 형태로 반환한다.
따라서 <code>funcname</code>은 <a href="#lua_CFunction"><code>lua_CFunction</code></a> 원형을 따라야 한다.
(<a href="#luaCFunction"><code>lua_CFunction</code></a> 참고.)


<p>
이 함수는 패키지 및 모듈 시스템을 완전히 건너뛰는
저수준 함수이다.
<a href="#pdf-require"><code>require</code></a>와 달리
경로 탐색을 수행하지 않으며
자동으로 확장자를 추가하지 않는다.
<code>libname</code>은 필요 시 경로와 확장자까지 포함한
C 라이브러리의 완전한 파일 이름이어야 한다.
<code>funcname</code>은 C 라이브러리에서 내보내는 정확한 이름이어야 한다.
(사용하는 C 컴파일러와 링커에 따라 달라질 수도 있다.)


<p>
이 기능을 표준 C에서 지원하지 않는다.
그래서 일부 플랫폼에서만
(윈도우, 리눅스, 맥 OS X, 솔라리스, BSD,
기타 <code>dlfcn</code> 표준을 지원하는 유닉스 시스템)
사용 가능하다.




<p>
<hr><h3><a name="pdf-package.path"><code>package.path</code></a></h3>


<p>
<a href="#pdf-require"><code>require</code></a>에서 루아 적재 함수 탐색에 쓰는 경로.


<p>
루아가 시작할 때 이 변수를
환경 변수 <a name="#pdf-LUA_PATH_5_3"><code>LUA_PATH_5_3</code></a>이나
환경 변수 <a name="#pdf-LUA_PATH"><code>LUA_PATH</code></a>로 초기화 한다.
그 환경 변수들이 정의되어 있지 않으면
<code>luaconf.h</code>에 정의된 기본 경로로 초기화 한다.
환경 변수 값 내에 "<code>;;</code>"가 있으면
거기에 기본 경로를 바꿔 넣는다.




<p>
<hr><h3><a name="pdf-package.preload"><code>package.preload</code></a></h3>


<p>
개별 모듈의 적재 함수들을 저장하는 테이블.
(<a href="#pdf-require"><code>require</code></a> 참고.)


<p>
이 변수는 실제 테이블에 대한 참조일 뿐이다.
이 변수에 할당을 해도
<a href="#pdf-require"><code>require</code></a>에서 쓰는 테이블이 바뀌지 않는다.




<p>
<hr><h3><a name="pdf-package.searchers"><code>package.searchers</code></a></h3>


<p>
모듈 적재 방식을 제어하기 위한 <a href="#pdf-require"><code>require</code></a>에서 쓰는 테이블.


<p>
이 테이블의 각 항목은 <em>탐색 함수</em>이다.
모듈을 찾을 때
<a href="#pdf-require"><code>require</code></a>에서 이 탐색 함수 각각을 오름차순으로,
모듈 이름(<a href="#pdf-require"><code>require</code></a>에 준 인자)을
유일한 매개변수로 해서 호출한다.
그 함수는 다른 함수(모듈 <em>적재 함수</em>)에 더해
그 적재 함수에게 전달할 값을 추가로 반환할 수 있다.
또는 모듈을 찾지 못한 이유를 설명하는 문자열을
(설명할 것이 없으면 <b>nil</b>을) 반환할 수 있다.


<p>
루아가 네 가지 탐색 함수로 이 테이블을 초기화 한다.


<p>
첫 번째 탐색 함수는
<a href="#pdf-package.preload"><code>package.preload</code></a> 테이블 안의
적재 함수만 찾아 본다.


<p>
두 번째 탐색 함수는
<a href="#pdf-package.path"><code>package.path</code></a>에 저장된 경로를 이용해
루아 라이브러리 적재 함수를 찾는다.
함수 <a href="#pdf-package.searchpath"><code>package.searchpath</code></a>에서
기술하는 대로 탐색이 이뤄진다.


<p>
세 번째 탐색 함수는
변수 <a href="#pdf-package.cpath"><code>package.cpath</code></a>에서 얻은 경로를 이용해
C 라이브러리 적재 함수를 찾는다.
마찬가지로
함수 <a href="#pdf-package.searchpath"><code>package.searchpath</code></a>에서
기술하는 대로 탐색이 이뤄진다.
예를 들어 C 경로가 다음 문자열일 때

<pre>
     "./?.so;./?.dll;/usr/local/?/init.so"
</pre><p>
모듈 <code>foo</code> 탐색 함수는 파일
<code>./foo.so</code>, <code>./foo.dll</code>,
<code>/usr/local/foo/init.so</code>를 차례대로 열어 보게 된다.
C 라이브러리를 찾으면 탐색 함수에서는 먼저 동적 링크 기제를 이용해
응용을 그 라이브러리와 링크 한다.
그러고 나서 적재 함수로 사용할 C 함수를 그 라이브러리 안에서 찾아 본다.
그 C 함수의 이름은 문자열 "<code>luaopen_</code>"에
모듈 이름을 덧붙이고서 마침표를 밑줄로 바꾼 것이다.
그리고 모듈 이름에 하이픈이 있으면
첫 번째 하이픈부터 이후를 제거한다.
예를 들어 모듈 이름이 <code>a.b.c-v2.1</code>이면
함수 이름이 <code>luaopen_a_b_c</code>가 된다.


<p>
네 번째 탐색 함수는 <em>일체형 적재 함수</em>를 시도한다.
지정한 모듈의 최상위 단계 이름으로
C 경로에서 라이브러리를 탐색한다.
예를 들어 <code>a.b.c</code>를 요청하는 경우
<code>a</code>로 C 라이브러리를 탐색하게 된다.
발견하면 그 안에서
서브모듈의 열기 함수를 찾는다.
예컨대 <code>luaopen_a_b_c</code>를 찾게 된다.
이 기제를 이용하면 패키지에서 C 서브모듈 여러 개를
라이브러리 한 개에 집어넣을 수 있다.
그러면서 각 서브모듈의 원래 열기 함수를 그대로 유지한다.


<p>
첫 번째(preload)를 제외한 모든 탐색 함수는
<a href="#pdf-package.searchpath"><code>package.searchpath</code></a>가 반환한
모듈 발견 파일 이름을 추가 값으로 반환한다.
첫 번째 탐색 함수는 추가 값을 반환하지 않는다.




<p>
<hr><h3><a name="pdf-package.searchpath"><code>package.searchpath (name, path [, sep [, rep]])</code></a></h3>


<p>
지정한 <code>path</code>에서 지정한 <code>name</code>을 찾는다.


<p>
<code>path</code>는 <em>템플릿</em>들을 세미콜론으로 구분해 담은 문자열이다.
각 템플릿에 대해서
템플릿 안에 물음표가 있으면
(<code>sep</code>(기본값은 마침표)를 모두
<code>rep</code>(기본값은 시스템의 디렉터리 구분자)로 바꾼)
<code>name</code> 사본으로 바꾸고서
결과로 나온 파일 이름으로 열기를 시도한다.


<p>
예를 들어 <code>path</code>가 다음 문자열인 경우에

<pre>
     "./?.lua;./?.lc;/usr/local/?/init.lua"
</pre><p>
이름을 <code>foo.a</code>로 해서 탐색하면 파일
<code>./foo/a.lua</code>, <code>./foo/a.lc</code>,
<code>/usr/local/foo/a/init.lua</code>를 차례대로
열어 보게 된다.


<p>
읽기 모드로 열 수 있는 첫 번째 파일의 치환 후 이름을
(파일을 닫고 나서) 반환한다.
성공한 파일이 없으면 <b>nil</b>에 더해 오류 메시지를 반환한다.
(그 오류 메시지에는 열기를 시도한 파일 이름이 모두 나열되어 있다.)







<h2>6.4 &ndash; <a name="6.4">문자열 조작</a></h2>

<p>
이 라이브러리는 부분 문자열 검색과 추출, 패턴 검사 같은
문자열 조작을 위한 범용 함수들을 제공한다.
루아에서 문자열에 인덱스를 쓸 때는 첫 번째 글자가
1번 위치이다. (C에서처럼 0번이 아니다.)
인덱스가 음수일 수 있어서 문자열 끝을 기준으로 한
역방향 인덱스로 해석한다.
즉 마지막 문자가 -1번 위치에 있는 식이다.


<p>
문자열 라이브러리는 모든 함수를
테이블 <a name="pdf-string"><code>string</code></a> 안에 제공한다.
그리고 문자열들에 메타테이블을 설정하는데
거기서 <code>__index</code> 필드가 <code>string</code> 테이블을 가리킨다.
그래서 문자열 함수들을 객체 지향 스타일로 사용할 수 있다.
예를 들어 <code>string.byte(s,i)</code>를
<code>s:byte(i)</code>라고 쓸 수 있다.


<p>
문자열 라이브러리에서는 1바이트 문자 인코딩을 상정한다.


<p>
<hr><h3><a name="pdf-string.byte"><code>string.byte (s [, i [, j]])</code></a></h3>
문자 <code>s[i]</code>, <code>s[i+1]</code>, ..., <code>s[j]</code>의
내부 숫자 코드들을 반환한다.
<code>i</code>의 기본값은 1이고
<code>j</code>의 기본값은 <code>i</code>이다.
<a href="#pdf-string.sub"><code>string.sub</code></a> 함수와 같은 규칙에 따라서
인덱스들을 정정한다.


<p>
숫자 코드가 반드시 플랫폼 간에 이식 가능한 것은 아니다.




<p>
<hr><h3><a name="pdf-string.char"><code>string.char (&middot;&middot;&middot;)</code></a></h3>
0개 이상의 정수를 받아서
길이가 인자 개수와 같은 문자열을 반환한다.
문자열 각 문자의 내부 숫자 코드가 대응하는 인자와 같다.


<p>
숫자 코드가 반드시 플랫폼 간에 이식 가능한 것은 아니다.




<p>
<hr><h3><a name="pdf-string.dump"><code>string.dump (function [, strip])</code></a></h3>


<p>
주어진 함수의 이진 표현(<em>바이너리 청크</em>)을 담은
문자열을 반환한다.
이후 그 문자열에 <a href="#pdf-load"><code>load</code></a> 하면
함수의 복사본을 (하지만 upvalue는 새 값으로) 반환한다.
<code>strip</code>이 참 값이면
공간 절약을 위해
함수에 대한 디버그 정보를
이진 표현에 모두 포함시키지 않을 수도 있다.


<p>
upvalue가 있는 함수인 경우 upvalue 개수만 저장된다.
(재)적재 때
upvalue들이 <b>nil</b>을 담은 새 인스턴스를 받는다.
(디버그 라이브러리를 이용하면
원하는 방식으로 함수의 upvalue를
직렬화 및 재적재할 수 있다.)




<p>
<hr><h3><a name="pdf-string.find"><code>string.find (s, pattern [, init [, plain]])</code></a></h3>


<p>
문자열 <code>s</code>에서 <code>pattern</code>의 첫 번째 일치 열을 찾는다.
(<a href="#6.4.1">6.4.1절</a> 참고.)
일치하는 열을 발견하면 시작점과 끝점의
<code>s</code> 내 인덱스를 반환한다.
못 찾으면 <b>nil</b>을 반환한다.
세 번째의 선택적인 수 인자 <code>init</code>은
탐색을 시작할 위치를 지정한다.
기본값이 1이고 음수일 수 있다.
네 번째의 선택적 인자 <code>plain</code>에
<b>true</b> 값을 주면 패턴 검사 기능을 끈다.
그래서 <code>pattern</code> 내의 어떤 문자도 특수하게 취급하지 않고
단순한 "부분 문자열 찾기" 동작을 한다.
<code>plain</code>에 값을 주려면 <code>init</code>에도 주어야 한다는 점에 유의하라.


<p>
패턴에 포획이 있으면
일치 성공 시
두 인덱스 뒤에
포획한 값들을 함께 반환한다.




<p>
<hr><h3><a name="pdf-string.format"><code>string.format (formatstring, &middot;&middot;&middot;)</code></a></h3>


<p>
첫 번째 인자(문자열이어야 함)에 따라서
가변 개수 인자들로 서식을 적용해 만든 문자열을 반환한다.
서식 문자열은 ISO C 함수 <code>sprintf</code>와 같은 규칙을 따른다.
다만 옵션/수식자
<code>*</code>, <code>h</code>, <code>L</code>, <code>l</code>, <code>n</code>,
<code>p</code>를 지원하지 않으며
추가로 <code>q</code> 옵션이 있다.


<p>
<code>q</code> 옵션은 문자열을 큰따옴표 안에 넣으며
필요하면 이스케이프 열을 쓴다.
그래서 그 결과를 루아 인터프리터가 안전하게 읽을 수 있다.
예를 들어 다음과 같이 호출하면

<pre>
     string.format('%q', 'a string with "quotes" and \n new line')
</pre><p>
다음 문자열이 나온다.

<pre>
     "a string with \"quotes\" and \
      new line"
</pre>

<p>
옵션
<code>A</code>, <code>a</code>, <code>E</code>, <code>e</code>, <code>f</code>,
<code>G</code>, <code>g</code>는 모두 인자로 수를 요구한다.
옵션 <code>c</code>, <code>d</code>,
<code>i</code>, <code>o</code>, <code>u</code>, <code>X</code>, <code>x</code>는
정수를 요구한다.
C89 컴파일러로 루아를 컴파일 하는 경우에는
<code>A</code> 및 <code>a</code> 옵션(16진수 실수)에
어떤 수식자(플래그, 폭, 길이)도 지원하지 않는다.


<p>
옵션 <code>s</code>는 문자열을 요구한다.
인자가 문자열이 아니면
<a href="#pdf-tostring"><code>tostring</code></a>과 같은 규칙에 따라 문자열로 변환한다.
옵션에 수식자(플래그, 폭, 길이)가 있는 경우에는
문자열 인자에 0이 들어 있지 않아야 한다.




<p>
<hr><h3><a name="pdf-string.gmatch"><code>string.gmatch (s, pattern)</code></a></h3>
반복자 함수를 반환한다.
호출할 때마다 그 함수는
문자열 <code>s</code>에 대한 <code>pattern</code>의 다음 포획 값들을 반환한다.
(<a href="#6.4.1">6.4.1절</a> 참고.)
<code>pattern</code>에 포획을 지정하지 않으면
각 호출마다 일치 열 전체를 내놓는다.


<p>
예를 들어 다음 루프는
문자열 <code>s</code>의 단어를 모두 돌면서
한 줄에 하나씩 찍는다.

<pre>
     s = "hello world from Lua"
     for w in string.gmatch(s, "%a+") do
       print(w)
     end
</pre><p>
다음 예는 주어진 문자열에서 <code>key=value</code> 쌍을 모두 모아서
테이블에 넣는다.

<pre>
     t = {}
     s = "from=world, to=Lua"
     for k, v in string.gmatch(s, "(%w+)=(%w+)") do
       t[k] = v
     end
</pre>

<p>
이 함수에서는 패턴 시작의 '<code>^</code>'가 앵커 기능을 하지 않는다.
그러면 반복이 불가능해지기 때문이다.




<p>
<hr><h3><a name="pdf-string.gsub"><code>string.gsub (s, pattern, repl [, n])</code></a></h3>
<code>s</code>에서 모든 (또는 처음 <code>n</code>개)
<code>pattern</code>을 <code>repl</code>로 지정한 대체 문자열로 바꾼
사본을 반환한다. (<a href="#6.4.1">6.4.1절</a> 참고.)
<code>repl</code>은 문자열, 테이블, 함수일 수 있다.
<code>gsub</code>는 또한 두 번째 값으로 치환 횟수를 반환한다.
<code>gsub</code>라는 이름은 <em>Global SUBstitution(전역 치환)</em>에서 온 것이다.


<p>
<code>repl</code>이 문자열이면 그 값을 교체에 쓴다.
문자 <code>%</code>는 이스케이프 문자 기능을 하는데,
<code>repl</code> 내에 <code>%<em>d</em></code> 형태의 열이 있으면
(<em>d</em>는 1에서 9 사이)
<em>d</em> 번째로 포획한 부분 문자열의 값을 나타낸다.
<code>%0</code>은 일치 열 전체를 나타낸다.
<code>%%</code>은 <code>%</code> 한 개를 나타낸다.


<p>
<code>repl</code>이 테이블이면 일치가 있을 때마다
첫 번째 포획 값을 키로 해서 테이블에 질의한다.


<p>
<code>repl</code>이 함수이면 일치가 있을 때마다
포획한 부분 문자열 모두를 순서 대로 인자로 해서 그 함수를 호출한다.


<p>
어느 경우이든
패턴에 포획을 지정하지 않으면
패턴 전체가 포획 안에 있는 것처럼 동작한다.


<p>
테이블 질의나 함수 호출의 반환 값이
문자열이나 수이면
대체 문자열로 쓴다.
그렇지 않고 <b>false</b>나 <b>nil</b>이면
교체하지 않는 것이다.
(즉 문자열 내의 그 일치 열을 그대로 유지한다.)


<p>
몇 가지 예를 들면 다음과 같다.

<pre>
     x = string.gsub("hello world", "(%w+)", "%1 %1")
     --&gt; x="hello hello world world"
     
     x = string.gsub("hello world", "%w+", "%0 %0", 1)
     --&gt; x="hello hello world"
     
     x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
     --&gt; x="world hello Lua from"
     
     x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)
     --&gt; x="home = /home/roberto, user = roberto"
     
     x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
           return load(s)()
         end)
     --&gt; x="4+5 = 9"
     
     local t = {name="lua", version="5.3"}
     x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)
     --&gt; x="lua-5.3.tar.gz"
</pre>



<p>
<hr><h3><a name="pdf-string.len"><code>string.len (s)</code></a></h3>
문자열을 받아서 그 길이를 반환한다.
빈 문자열 <code>""</code>의 길이는 0이다.
문자열 내의 0도 길이에 산입한다.
따라서 <code>"a\000bc\000"</code>의 길이가 5이다.




<p>
<hr><h3><a name="pdf-string.lower"><code>string.lower (s)</code></a></h3>
문자열을 받아서 대문자 글자가 모두 소문자로 바뀐
문자열 사본을 반환한다.
다른 글자들은 바뀌지 않는다.
무엇이 대문자 글자인지에 대한 정의는 현재 로캘에 따라 정해진다.




<p>
<hr><h3><a name="pdf-string.match"><code>string.match (s, pattern [, init])</code></a></h3>
문자열 <code>s</code>에서 <code>pattern</code>의 첫 번째 <em>일치 열</em>을 찾는다.
(<a href="#6.4.1">6.4.1절</a> 참고.)
일치하는 열을 발견하면
패턴의 포획 값들을 반환한다.
못 찾으면 <b>nil</b>을 반환한다.
<code>pattern</code>에 포획을 지정하지 않으면
일치 열 전체를 반환한다.
세 번째의 선택적인 수 인자 <code>init</code>은
탐색을 시작할 위치를 지정한다.
기본값이 1이고 음수일 수 있다.




<p>
<hr><h3><a name="pdf-string.pack"><code>string.pack (fmt, v1, v2, &middot;&middot;&middot;)</code></a></h3>


<p>
값 <code>v1</code>, <code>v2</code> 등을
형식 문자열 <code>fmt</code>에 따라 포장해서 담은
(즉 이진 형태로 직렬화 한) 이진 문자열을 반환한다.
(<a href="#6.4.2">6.4.2절</a> 참고.)




<p>
<hr><h3><a name="pdf-string.packsize"><code>string.packsize (fmt)</code></a></h3>


<p>
지정한 형식으로 <a href="#pdf-string.pack"><code>string.pack</code></a> 하면
나오는 문자열의 크기를 반환한다.
형식 문자열에 가변 길이 옵션인 '<code>s</code>'나 '<code>z</code>'가
있을 수 없다. (<a href="#6.4.2">6.4.2절</a> 참고.)




<p>
<hr><h3><a name="pdf-string.rep"><code>string.rep (s, n [, sep])</code></a></h3>
문자열 <code>s</code>의 사본 <code>n</code>개를
문자열 <code>sep</code>를 구분자로 해서 이어 붙인 문자열을 반환한다.
<code>sep</code>의 기본값은 빈 문자열(즉 구분자 없음)이다.
<code>n</code>이 양수가 아니면 빈 문자열을 반환한다.


<p>
(이 함수 호출 한 번으로 머신의 메모리를 아주 쉽게
고갈시킬 수 있다는 점에 유의하라.)




<p>
<hr><h3><a name="pdf-string.reverse"><code>string.reverse (s)</code></a></h3>
문자열 <code>s</code>를 뒤집은 문자열을 반환한다.




<p>
<hr><h3><a name="pdf-string.sub"><code>string.sub (s, i [, j])</code></a></h3>
<code>i</code>에서 시작해서 <code>j</code>까지 이어지는
<code>s</code>의 부분 문자열을 반환한다.
<code>i</code>와 <code>j</code>가 음수일 수 있다.
<code>j</code>가 없으면 (문자열 길이와 같은) -1로 상정한다.
특히
<code>string.sub(s,1,j)</code> 호출은
길이 <code>j</code>인 <code>s</code>의 머리를 반환하고
<code>string.sub(s, -i)</code> (<code>i</code>는 양수) 호출은
길이 <code>i</code>인 <code>s</code>의 꼬리를 반환한다.


<p>
음수 인덱스 변환 후에,
<code>i</code>가 1보다 작으면
1로 정정한다.
<code>j</code>가 문자열 길이보다 크면
그 길이로 정정한다.
이런 정정 후에
<code>i</code>가 <code>j</code>보다 크면
빈 문자열을 반환한다.




<p>
<hr><h3><a name="pdf-string.unpack"><code>string.unpack (fmt, s [, pos])</code></a></h3>


<p>
형식 문자열 <code>fmt</code>에 따라 문자열 <code>s</code>에 포장된
(<a href="#pdf-string.pack"><code>string.pack</code></a> 참고) 값들을 반환한다.
(<a href="#6.4.2">6.4.2절</a> 참고.)
<code>pos</code>는 선택적이며 <code>s</code>의 어디부터
읽기를 시작할지 표시한다. (기본값은 1이다.)
읽은 값들 뒤에
<code>s</code>에서 읽지 않은 첫 바이트의 인덱스를 함께 반환한다.




<p>
<hr><h3><a name="pdf-string.upper"><code>string.upper (s)</code></a></h3>
문자열을 받아서 소문자 글자가 모두 대문자로 바뀐
문자열 사본을 반환한다.
다른 글자들은 바뀌지 않는다.
무엇이 소문자 글자인지에 대한 정의는 현재 로캘에 따라 정해진다.





<h3>6.4.1 &ndash; <a name="6.4.1">패턴</a></h3>

<p>
루아에서는 정규 문자열로 패턴을 기술한다.
그 문자열을 패턴 검사 함수
<a href="#pdf-string.find"><code>string.find</code></a>,
<a href="#pdf-string.gmatch"><code>string.gmatch</code></a>,
<a href="#pdf-string.gsub"><code>string.gsub</code></a>,
<a href="#pdf-string.match"><code>string.match</code></a>에서
패턴으로 해석한다.
이 절에서는 그 문자열의 문법과 의미(즉 무엇에 들어맞는지)를 설명한다.



<h4>문자 클래스:</h4><p>
<em>문자 클래스</em>를 사용해 문자들의 집합을 나타낸다.
다음 요소들로 문자 클래스를 기술할 수 있다.

<ul>

<li><b><em>x</em>: </b>
(<em>x</em>가
<em>특수 문자</em> <code>^$()%.[]*+-?</code> 중 하나가 아님)
문자 <em>x</em> 자체를 나타낸다.
</li>

<li><b><code>.</code>: </b> (마침표) 모든 문자를 나타낸다.</li>

<li><b><code>%a</code>: </b> 모든 알파벳 글자를 나타낸다.</li>

<li><b><code>%c</code>: </b> 모든 제어 문자를 나타낸다.</li>

<li><b><code>%d</code>: </b> 모든 숫자를 나타낸다.</li>

<li><b><code>%g</code>: </b> 공백을 제외한 모든 출력 가능 문자를 나타낸다.</li>

<li><b><code>%l</code>: </b> 모든 소문자 글자를 나타낸다.</li>

<li><b><code>%p</code>: </b> 모든 문장 부호 문자를 나타낸다.</li>

<li><b><code>%s</code>: </b> 모든 공백 문자를 나타낸다.</li>

<li><b><code>%u</code>: </b> 모든 대문자 글자를 나타낸다.</li>

<li><b><code>%w</code>: </b> 모든 알파벳 및 숫자를 나타낸다.</li>

<li><b><code>%x</code>: </b> 모든 16진수 숫자를 나타낸다.</li>

<li><b><code>%<em>x</em></code>: </b> (<em>x</em>가 알파벳/숫자 아닌 문자)
문자 <em>x</em>를 나타낸다.
특수 문자를 이스케이프 하는 표준 방식이다.
패턴에서 알파벳 및 숫자가 아닌 모든 문자
(특수 문자 여부 상관없이 모든 문장 부호 포함) 앞에
'<code>%</code>'를 붙여서 그 문자 자체를 나타낼 수 있다.
</li>

<li><b><code>[<em>set</em>]</code>: </b>
<em>set</em> 안의 모든 문자들의 합집합인
클래스를 나타낸다.
오름차순 범위의 끝 문자를 '<code>-</code>'로 붙여 써서
문자 범위를 지정할 수 있다.
그리고 위에서 설명한 <code>%</code><em>x</em> 형태 클래스들을 모두
<em>set</em>의 요소로 쓸 수 있다.
그 외의 문자들은 <em>set</em> 안에서 그 자체를 나타낸다.
예를 들어 <code>[%w_]</code> (또는 <code>[_%w]</code>) 패턴은
모든 알파벳/숫자 문자에 밑줄을 더한 것을 나타내고,
<code>[0-7]</code> 패턴은 8진수 숫자를 나타내며,
<code>[0-7%l%-]</code> 패턴은 8진수 숫자 더하기
소문자 글자 더하기 '<code>-</code>' 문자를 나타낸다.


<p>
닫는 대괄호를 집합에 넣으려면
집합 첫 번째 문자로 두면 된다.
하이픈을 집합에 넣으려면
집합 첫 번째 문자나 마지막 문자로 두면 된다.
(두 경우 모두 이스케이프를 쓸 수도 있다.)


<p>
범위와 클래스 간의 상호작용은 규정되어 있지 않다.
그러므로 <code>[%a-z]</code>나 <code>[a-%%]</code> 같은 패턴은
의미가 없다.
</li>

<li><b><code>[^<em>set</em>]</code>: </b>
<em>set</em>의 여집합을 나타낸다.
<em>set</em>은 위에서처럼 해석한다.
</li>

</ul><p>
한 글자로 나타내는 클래스 (<code>%a</code>, <code>%c</code> 등) 모두에 대해
대응하는 대문자 글자가 그 클래스의 여집합을 나타낸다.
예를 들어 <code>%S</code>는 공백이 아닌 모든 문자를 나타낸다.


<p>
글자, 공백, 기타 문자 그룹들의 정의는
현재 로캘에 따라 정해진다.
특히 클래스 <code>[a-z]</code>가 <code>%l</code>과 동등하지 않을 수도 있다.





<h4>패턴 항목:</h4><p>
다음이 <em>패턴 항목</em>이 될 수 있다.

<ul>

<li>
문자 클래스 하나.
클래스 내의 아무 문자 하나와 들어맞는다.
</li>

<li>
문자 클래스 하나 뒤에 '<code>*</code>'를 붙인 것.
클래스의 문자들이 0번 이상 반복되는 것에 들어맞는다.
이 반복 항목은 항상 가급적 긴 열에 일치하려 한다.
</li>

<li>
문자 클래스 하나 뒤에 '<code>+</code>'를 붙인 것.
클래스의 문자들이 1번 이상 반복되는 것에 들어맞는다.
이 반복 항목은 항상 가급적 긴 열에 일치하려 한다.
</li>

<li>
문자 클래스 하나 뒤에 '<code>-</code>'를 붙인 것.
클래스의 문자들이 0번 이상 반복되는 것에 들어맞는다.
'<code>*</code>'와 달리
항상 가급적 짧은 열에 일치하려 한다.
</li>

<li>
문자 클래스 하나 뒤에 '<code>?</code>'를 붙인 것.
클래스의 문자가 0번 또는 1번 등장하는 것에 들어맞는다.
가능한 경우 항상 1번 등장하는 것으로 일치한다.
</li>

<li>
<code>%<em>n</em></code>. <em>n</em>은 1에서 9까지이다.
이 항목은 <em>n</em> 번째 포획 문자열(아래 참고)과 같은 부분 문자열에 들어맞는다.
</li>

<li>
<code>%b<em>xy</em></code>. <em>x</em>와 <em>y</em>는 별개 문자이다.
이 항목은 <em>x</em>로 시작해서 <em>y</em>로 끝나고
<em>x</em>와 <em>y</em>가 <em>균형이 맞는(balanced)</em> 문자열에 들어맞는다.
균형이 맞는다는 것은 왼쪽에서 오른쪽으로 읽어 나가면서
<em>x</em>에서 <em>+1</em> 하고 <em>y</em>에서 <em>-1</em> 한다고 할 때
0이 되는 첫 번째 <em>y</em>가 끝내는 <em>y</em>가 된다는 뜻이다.
예를 들어 <code>%b()</code> 항목은 짝 맞는 괄호로 감싼 식에 들어맞는다.
</li>

<li>
<code>%f[<em>set</em>]</code>. <em>경계(frontier) 패턴</em>이다.
이 항목은 다음 문자는 <em>set</em>에 속하고
이전 문자는 <em>set</em>에 속하지 않는 위치의
빈 문자열에 들어맞는다.
집합 <em>set</em>은 앞서 설명한 대로 해석한다.
대상 문자열의 시작과 끝에
'<code>\0</code>' 문자가 있는 것처럼 처리한다.
</li>

</ul>




<h4>패턴:</h4><p>
<em>패턴</em>은 일련의 패턴 항목들이다.
패턴 시작의 캐럿 '<code>^</code>'은 일치 열을
대상 문자열 시작점에 고정시킨다.
패턴 끝의 '<code>$</code>'는 일치 열을
대상 문자열 끝점에 고정시킨다.
다른 위치에서는 '<code>^</code>'과 '<code>$</code>'가
특별한 의미 없이 그 자체를 나타낸다.





<h4>포획:</h4><p>
패턴 안에 괄호로 둘러싸인 하위 패턴이 있을 수 있으며
그것이 <em>포획(capture)</em>이다.
일치에 성공했을 때 포획 부분에 들어맞는 부분 문자열을
향후 사용을 위해 저장(<em>포획</em>)해 둔다.
왼쪽 괄호에 따라서 포획에 번호가 붙는다.
예를 들어 패턴 <code>"(a*(.)%w(%s*))"</code>가 있을 때,
대상 문자열에서 <code>"a*(.)%w(%s*)"</code>에 들어맞는 부분이
첫 번째 포획 값으로 저장되고 (그래서 1번이 되고),
"<code>.</code>"에 들어맞는 문자가 2번으로 포획되고,
"<code>%s*</code>"에 들어맞는 부분이 3번이 된다.


<p>
특별히 빈 포획 <code>()</code>는
현재 문자열 위치를 (수 값으로) 포획한다.
예를 들어 문자열 <code>"flaaap"</code>에 패턴 <code>"()aa()"</code>를 적용하면
포획 값이 3과 5가 된다.







<h3>6.4.2 &ndash; <a name="6.4.2">포장 형식 문자열</a></h3>

<p>
<a href="#pdf-string.pack"><code>string.pack</code></a>,
<a href="#pdf-string.packsize"><code>string.packsize</code></a>,
<a href="#pdf-string.unpack"><code>string.unpack</code></a>의
첫 번째 인자는 만들거나 읽으려는 구조의 레이아웃을 기술하는 형식 문자열이다.


<p>
형식 문자열은 일련의 변환 옵션들이다.
가능한 변환 옵션은 다음과 같다.

<ul>
<li><b><code>&lt;</code>: </b>리틀 엔디안 설정</li>
<li><b><code>&gt;</code>: </b>빅 엔디안 설정</li>
<li><b><code>=</code>: </b>시스템 기본 엔디안 설정</li>
<li><b><code>![<em>n</em>]</code>: </b>최대 정렬 크기를 <code>n</code>으로 설정
(생략 시 시스템 기본 정렬 크기)</li>
<li><b><code>b</code>: </b>부호 있는 바이트 (<code>char</code>)</li>
<li><b><code>B</code>: </b>부호 없는 바이트 (<code>char</code>)</li>
<li><b><code>h</code>: </b>부호 있는 <code>short</code> (시스템 기본 크기)</li>
<li><b><code>H</code>: </b>부호 없는 <code>short</code> (시스템 기본 크기)</li>
<li><b><code>l</code>: </b>부호 있는 <code>long</code> (시스템 기본 크기)</li>
<li><b><code>L</code>: </b>부호 없는 <code>long</code> (시스템 기본 크기)</li>
<li><b><code>j</code>: </b><code>lua_Integer</code></li>
<li><b><code>J</code>: </b><code>lua_Unsigned</code></li>
<li><b><code>T</code>: </b><code>size_t</code> (시스템 기본 크기)</li>
<li><b><code>i[<em>n</em>]</code>: </b>부호 있는 <code>n</code> 바이트 <code>int</code>
(생략 시 시스템 기본 크기)</li>
<li><b><code>I[<em>n</em>]</code>: </b>부호 없는 <code>n</code> 바이트 <code>int</code>
(생략 시 시스템 기본 크기)</li>
<li><b><code>f</code>: </b><code>float</code> (시스템 기본 크기)</li>
<li><b><code>d</code>: </b><code>double</code> (시스템 기본 크기)</li>
<li><b><code>n</code>: </b><code>lua_Number</code></li>
<li><b><code>c<em>n</em></code>: </b><code>n</code> 바이트 고정 크기 문자열</li>
<li><b><code>z</code>: </b>영 종료 문자열</li>
<li><b><code>s[<em>n</em>]</code>: </b><code>n</code> 바이트 부호 없는 정수로
표현한 길이가 앞에 붙은 문자열
(생략 시 <code>size_t</code>)</li>
<li><b><code>x</code>: </b>패딩 1바이트</li>
<li><b><code>X<em>op</em></code>: </b>옵션 <code>op</code>의 크기에 따라
정렬을 맞춘 빈 항목
(<code>op</code>는 크기만 얻고 무시)</li>
<li><b>'<code> </code>': </b>(공백) 무시됨</li>
</ul><p>
("<code>[<em>n</em>]</code>"은 선택적인 정수 숫자를 뜻한다.)
패딩, 공백, 설정을 (옵션 "<code>xX &lt;=&gt;!</code>를) 제외한
각 옵션은 (<a href="#pdf-string.pack"><code>string.pack</code></a>의) 인자 한 개 내지
(<a href="#pdf-string.unpack"><code>string.unpack</code></a>의) 결과 한 개에 대응한다.


<p>
옵션 "<code>!<em>n</em></code>", "<code>s<em>n</em></code>", "<code>i<em>n</em></code>", "<code>I<em>n</em></code>"에서
<code>n</code>에는 1에서 16까지 아무 정수나 가능하다.
모든 정수 옵션마다 오버플로우 검사를 한다.
즉, <a href="#pdf-string.pack"><code>string.pack</code></a>에서는 받은 값이 지정한 크기에 들어가는지 확인하며
<a href="#pdf-string.unpack"><code>string.unpack</code></a>에서는 읽은 값이 루아 정수에 들어가는지 확인한다.


<p>
모든 형식 문자열은 앞에 "<code>!1=</code>"가 붙은 것처럼,
즉 최대 정렬 크기 1(정렬 없음)과 시스템 기본 엔디안으로 시작한다.


<p>
정렬 방식을 설명하자면,
각 옵션에 대해
옵션 크기와 최대 정렬 크기 중 작은 값의 배수인
오프셋에서 데이터가 시작할 때까지 패딩을 추가한다.
그 작은 값은 2의 거듭제곱수여야 한다.
옵션 "<code>c</code>"와 "<code>z</code>"는 따로 정렬을 맞추지 않으며,
옵션 "<code>s</code>"는 앞머리 정수의 정렬을 따른다.


<p>
모든 패딩을 <a href="#pdf-string.pack"><code>string.pack</code></a>에서 0으로 채운다.
(그리고 <a href="#pdf-string.unpack"><code>string.unpack</code></a>에서 무시한다.)







<h2>6.5 &ndash; <a name="6.5">UTF-8 Support</a></h2>

<p>
This library provides basic support for UTF-8 encoding.
It provides all its functions inside the table <a name="pdf-utf8"><code>utf8</code></a>.
This library does not provide any support for Unicode other
than the handling of the encoding.
Any operation that needs the meaning of a character,
such as character classification, is outside its scope.


<p>
Unless stated otherwise,
all functions that expect a byte position as a parameter
assume that the given position is either the start of a byte sequence
or one plus the length of the subject string.
As in the string library,
negative indices count from the end of the string.


<p>
<hr><h3><a name="pdf-utf8.char"><code>utf8.char (&middot;&middot;&middot;)</code></a></h3>
Receives zero or more integers,
converts each one to its corresponding UTF-8 byte sequence
and returns a string with the concatenation of all these sequences.




<p>
<hr><h3><a name="pdf-utf8.charpattern"><code>utf8.charpattern</code></a></h3>
The pattern (a string, not a function) "<code>[\0-\x7F\xC2-\xF4][\x80-\xBF]*</code>"
(see <a href="#6.4.1">&sect;6.4.1</a>),
which matches exactly one UTF-8 byte sequence,
assuming that the subject is a valid UTF-8 string.




<p>
<hr><h3><a name="pdf-utf8.codes"><code>utf8.codes (s)</code></a></h3>


<p>
Returns values so that the construction

<pre>
     for p, c in utf8.codes(s) do <em>body</em> end
</pre><p>
will iterate over all characters in string <code>s</code>,
with <code>p</code> being the position (in bytes) and <code>c</code> the code point
of each character.
It raises an error if it meets any invalid byte sequence.




<p>
<hr><h3><a name="pdf-utf8.codepoint"><code>utf8.codepoint (s [, i [, j]])</code></a></h3>
Returns the codepoints (as integers) from all characters in <code>s</code>
that start between byte position <code>i</code> and <code>j</code> (both included).
The default for <code>i</code> is 1 and for <code>j</code> is <code>i</code>.
It raises an error if it meets any invalid byte sequence.




<p>
<hr><h3><a name="pdf-utf8.len"><code>utf8.len (s [, i [, j]])</code></a></h3>
Returns the number of UTF-8 characters in string <code>s</code>
that start between positions <code>i</code> and <code>j</code> (both inclusive).
The default for <code>i</code> is 1 and for <code>j</code> is -1.
If it finds any invalid byte sequence,
returns a false value plus the position of the first invalid byte.




<p>
<hr><h3><a name="pdf-utf8.offset"><code>utf8.offset (s, n [, i])</code></a></h3>
Returns the position (in bytes) where the encoding of the
<code>n</code>-th character of <code>s</code>
(counting from position <code>i</code>) starts.
A negative <code>n</code> gets characters before position <code>i</code>.
The default for <code>i</code> is 1 when <code>n</code> is non-negative
and <code>#s + 1</code> otherwise,
so that <code>utf8.offset(s, -n)</code> gets the offset of the
<code>n</code>-th character from the end of the string.
If the specified character is neither in the subject
nor right after its end,
the function returns <b>nil</b>.


<p>
As a special case,
when <code>n</code> is 0 the function returns the start of the encoding
of the character that contains the <code>i</code>-th byte of <code>s</code>.


<p>
This function assumes that <code>s</code> is a valid UTF-8 string.







<h2>6.6 &ndash; <a name="6.6">Table Manipulation</a></h2>

<p>
This library provides generic functions for table manipulation.
It provides all its functions inside the table <a name="pdf-table"><code>table</code></a>.


<p>
Remember that, whenever an operation needs the length of a table,
all caveats about the length operator apply (see <a href="#3.4.7">&sect;3.4.7</a>).
All functions ignore non-numeric keys
in the tables given as arguments.


<p>
<hr><h3><a name="pdf-table.concat"><code>table.concat (list [, sep [, i [, j]]])</code></a></h3>


<p>
Given a list where all elements are strings or numbers,
returns the string <code>list[i]..sep..list[i+1] &middot;&middot;&middot; sep..list[j]</code>.
The default value for <code>sep</code> is the empty string,
the default for <code>i</code> is 1,
and the default for <code>j</code> is <code>#list</code>.
If <code>i</code> is greater than <code>j</code>, returns the empty string.




<p>
<hr><h3><a name="pdf-table.insert"><code>table.insert (list, [pos,] value)</code></a></h3>


<p>
Inserts element <code>value</code> at position <code>pos</code> in <code>list</code>,
shifting up the elements
<code>list[pos], list[pos+1], &middot;&middot;&middot;, list[#list]</code>.
The default value for <code>pos</code> is <code>#list+1</code>,
so that a call <code>table.insert(t,x)</code> inserts <code>x</code> at the end
of list <code>t</code>.




<p>
<hr><h3><a name="pdf-table.move"><code>table.move (a1, f, e, t [,a2])</code></a></h3>


<p>
Moves elements from table <code>a1</code> to table <code>a2</code>,
performing the equivalent to the following
multiple assignment:
<code>a2[t],&middot;&middot;&middot; = a1[f],&middot;&middot;&middot;,a1[e]</code>.
The default for <code>a2</code> is <code>a1</code>.
The destination range can overlap with the source range.
The number of elements to be moved must fit in a Lua integer.


<p>
Returns the destination table <code>a2</code>.




<p>
<hr><h3><a name="pdf-table.pack"><code>table.pack (&middot;&middot;&middot;)</code></a></h3>


<p>
Returns a new table with all parameters stored into keys 1, 2, etc.
and with a field "<code>n</code>" with the total number of parameters.
Note that the resulting table may not be a sequence.




<p>
<hr><h3><a name="pdf-table.remove"><code>table.remove (list [, pos])</code></a></h3>


<p>
Removes from <code>list</code> the element at position <code>pos</code>,
returning the value of the removed element.
When <code>pos</code> is an integer between 1 and <code>#list</code>,
it shifts down the elements
<code>list[pos+1], list[pos+2], &middot;&middot;&middot;, list[#list]</code>
and erases element <code>list[#list]</code>;
The index <code>pos</code> can also be 0 when <code>#list</code> is 0,
or <code>#list + 1</code>;
in those cases, the function erases the element <code>list[pos]</code>.


<p>
The default value for <code>pos</code> is <code>#list</code>,
so that a call <code>table.remove(l)</code> removes the last element
of list <code>l</code>.




<p>
<hr><h3><a name="pdf-table.sort"><code>table.sort (list [, comp])</code></a></h3>


<p>
Sorts list elements in a given order, <em>in-place</em>,
from <code>list[1]</code> to <code>list[#list]</code>.
If <code>comp</code> is given,
then it must be a function that receives two list elements
and returns true when the first element must come
before the second in the final order
(so that, after the sort,
<code>i &lt; j</code> implies <code>not comp(list[j],list[i])</code>).
If <code>comp</code> is not given,
then the standard Lua operator <code>&lt;</code> is used instead.


<p>
Note that the <code>comp</code> function must define
a strict partial order over the elements in the list;
that is, it must be asymmetric and transitive.
Otherwise, no valid sort may be possible.


<p>
The sort algorithm is not stable:
elements considered equal by the given order
may have their relative positions changed by the sort.




<p>
<hr><h3><a name="pdf-table.unpack"><code>table.unpack (list [, i [, j]])</code></a></h3>


<p>
Returns the elements from the given list.
This function is equivalent to

<pre>
     return list[i], list[i+1], &middot;&middot;&middot;, list[j]
</pre><p>
By default, <code>i</code> is&nbsp;1 and <code>j</code> is <code>#list</code>.







<h2>6.7 &ndash; <a name="6.7">Mathematical Functions</a></h2>

<p>
This library provides basic mathematical functions.
It provides all its functions and constants inside the table <a name="pdf-math"><code>math</code></a>.
Functions with the annotation "<code>integer/float</code>" give
integer results for integer arguments
and float results for float (or mixed) arguments.
Rounding functions
(<a href="#pdf-math.ceil"><code>math.ceil</code></a>, <a href="#pdf-math.floor"><code>math.floor</code></a>, and <a href="#pdf-math.modf"><code>math.modf</code></a>)
return an integer when the result fits in the range of an integer,
or a float otherwise.


<p>
<hr><h3><a name="pdf-math.abs"><code>math.abs (x)</code></a></h3>


<p>
Returns the absolute value of <code>x</code>. (integer/float)




<p>
<hr><h3><a name="pdf-math.acos"><code>math.acos (x)</code></a></h3>


<p>
Returns the arc cosine of <code>x</code> (in radians).




<p>
<hr><h3><a name="pdf-math.asin"><code>math.asin (x)</code></a></h3>


<p>
Returns the arc sine of <code>x</code> (in radians).




<p>
<hr><h3><a name="pdf-math.atan"><code>math.atan (y [, x])</code></a></h3>


<p>

Returns the arc tangent of <code>y/x</code> (in radians),
but uses the signs of both parameters to find the
quadrant of the result.
(It also handles correctly the case of <code>x</code> being zero.)


<p>
The default value for <code>x</code> is 1,
so that the call <code>math.atan(y)</code>
returns the arc tangent of <code>y</code>.




<p>
<hr><h3><a name="pdf-math.ceil"><code>math.ceil (x)</code></a></h3>


<p>
Returns the smallest integral value larger than or equal to <code>x</code>.




<p>
<hr><h3><a name="pdf-math.cos"><code>math.cos (x)</code></a></h3>


<p>
Returns the cosine of <code>x</code> (assumed to be in radians).




<p>
<hr><h3><a name="pdf-math.deg"><code>math.deg (x)</code></a></h3>


<p>
Converts the angle <code>x</code> from radians to degrees.




<p>
<hr><h3><a name="pdf-math.exp"><code>math.exp (x)</code></a></h3>


<p>
Returns the value <em>e<sup>x</sup></em>
(where <code>e</code> is the base of natural logarithms).




<p>
<hr><h3><a name="pdf-math.floor"><code>math.floor (x)</code></a></h3>


<p>
Returns the largest integral value smaller than or equal to <code>x</code>.




<p>
<hr><h3><a name="pdf-math.fmod"><code>math.fmod (x, y)</code></a></h3>


<p>
Returns the remainder of the division of <code>x</code> by <code>y</code>
that rounds the quotient towards zero. (integer/float)




<p>
<hr><h3><a name="pdf-math.huge"><code>math.huge</code></a></h3>


<p>
The float value <code>HUGE_VAL</code>,
a value larger than any other numeric value.




<p>
<hr><h3><a name="pdf-math.log"><code>math.log (x [, base])</code></a></h3>


<p>
Returns the logarithm of <code>x</code> in the given base.
The default for <code>base</code> is <em>e</em>
(so that the function returns the natural logarithm of <code>x</code>).




<p>
<hr><h3><a name="pdf-math.max"><code>math.max (x, &middot;&middot;&middot;)</code></a></h3>


<p>
Returns the argument with the maximum value,
according to the Lua operator <code>&lt;</code>. (integer/float)




<p>
<hr><h3><a name="pdf-math.maxinteger"><code>math.maxinteger</code></a></h3>
An integer with the maximum value for an integer.




<p>
<hr><h3><a name="pdf-math.min"><code>math.min (x, &middot;&middot;&middot;)</code></a></h3>


<p>
Returns the argument with the minimum value,
according to the Lua operator <code>&lt;</code>. (integer/float)




<p>
<hr><h3><a name="pdf-math.mininteger"><code>math.mininteger</code></a></h3>
An integer with the minimum value for an integer.




<p>
<hr><h3><a name="pdf-math.modf"><code>math.modf (x)</code></a></h3>


<p>
Returns the integral part of <code>x</code> and the fractional part of <code>x</code>.
Its second result is always a float.




<p>
<hr><h3><a name="pdf-math.pi"><code>math.pi</code></a></h3>


<p>
The value of <em>&pi;</em>.




<p>
<hr><h3><a name="pdf-math.rad"><code>math.rad (x)</code></a></h3>


<p>
Converts the angle <code>x</code> from degrees to radians.




<p>
<hr><h3><a name="pdf-math.random"><code>math.random ([m [, n]])</code></a></h3>


<p>
When called without arguments,
returns a pseudo-random float with uniform distribution
in the range  <em>[0,1)</em>.  
When called with two integers <code>m</code> and <code>n</code>,
<code>math.random</code> returns a pseudo-random integer
with uniform distribution in the range <em>[m, n]</em>.
(The value <em>n-m</em> cannot be negative and must fit in a Lua integer.)
The call <code>math.random(n)</code> is equivalent to <code>math.random(1,n)</code>.


<p>
This function is an interface to the underling
pseudo-random generator function provided by C.




<p>
<hr><h3><a name="pdf-math.randomseed"><code>math.randomseed (x)</code></a></h3>


<p>
Sets <code>x</code> as the "seed"
for the pseudo-random generator:
equal seeds produce equal sequences of numbers.




<p>
<hr><h3><a name="pdf-math.sin"><code>math.sin (x)</code></a></h3>


<p>
Returns the sine of <code>x</code> (assumed to be in radians).




<p>
<hr><h3><a name="pdf-math.sqrt"><code>math.sqrt (x)</code></a></h3>


<p>
Returns the square root of <code>x</code>.
(You can also use the expression <code>x^0.5</code> to compute this value.)




<p>
<hr><h3><a name="pdf-math.tan"><code>math.tan (x)</code></a></h3>


<p>
Returns the tangent of <code>x</code> (assumed to be in radians).




<p>
<hr><h3><a name="pdf-math.tointeger"><code>math.tointeger (x)</code></a></h3>


<p>
If the value <code>x</code> is convertible to an integer,
returns that integer.
Otherwise, returns <b>nil</b>.




<p>
<hr><h3><a name="pdf-math.type"><code>math.type (x)</code></a></h3>


<p>
Returns "<code>integer</code>" if <code>x</code> is an integer,
"<code>float</code>" if it is a float,
or <b>nil</b> if <code>x</code> is not a number.




<p>
<hr><h3><a name="pdf-math.ult"><code>math.ult (m, n)</code></a></h3>


<p>
Returns a boolean,
true if and only if integer <code>m</code> is below integer <code>n</code> when
they are compared as unsigned integers.







<h2>6.8 &ndash; <a name="6.8">Input and Output Facilities</a></h2>

<p>
The I/O library provides two different styles for file manipulation.
The first one uses implicit file handles;
that is, there are operations to set a default input file and a
default output file,
and all input/output operations are over these default files.
The second style uses explicit file handles.


<p>
When using implicit file handles,
all operations are supplied by table <a name="pdf-io"><code>io</code></a>.
When using explicit file handles,
the operation <a href="#pdf-io.open"><code>io.open</code></a> returns a file handle
and then all operations are supplied as methods of the file handle.


<p>
The table <code>io</code> also provides
three predefined file handles with their usual meanings from C:
<a name="pdf-io.stdin"><code>io.stdin</code></a>, <a name="pdf-io.stdout"><code>io.stdout</code></a>, and <a name="pdf-io.stderr"><code>io.stderr</code></a>.
The I/O library never closes these files.


<p>
Unless otherwise stated,
all I/O functions return <b>nil</b> on failure
(plus an error message as a second result and
a system-dependent error code as a third result)
and some value different from <b>nil</b> on success.
On non-POSIX systems,
the computation of the error message and error code
in case of errors
may be not thread safe,
because they rely on the global C variable <code>errno</code>.


<p>
<hr><h3><a name="pdf-io.close"><code>io.close ([file])</code></a></h3>


<p>
Equivalent to <code>file:close()</code>.
Without a <code>file</code>, closes the default output file.




<p>
<hr><h3><a name="pdf-io.flush"><code>io.flush ()</code></a></h3>


<p>
Equivalent to <code>io.output():flush()</code>.




<p>
<hr><h3><a name="pdf-io.input"><code>io.input ([file])</code></a></h3>


<p>
When called with a file name, it opens the named file (in text mode),
and sets its handle as the default input file.
When called with a file handle,
it simply sets this file handle as the default input file.
When called without parameters,
it returns the current default input file.


<p>
In case of errors this function raises the error,
instead of returning an error code.




<p>
<hr><h3><a name="pdf-io.lines"><code>io.lines ([filename, &middot;&middot;&middot;])</code></a></h3>


<p>
Opens the given file name in read mode
and returns an iterator function that
works like <code>file:lines(&middot;&middot;&middot;)</code> over the opened file.
When the iterator function detects the end of file,
it returns no values (to finish the loop) and automatically closes the file.


<p>
The call <code>io.lines()</code> (with no file name) is equivalent
to <code>io.input():lines("*l")</code>;
that is, it iterates over the lines of the default input file.
In this case it does not close the file when the loop ends.


<p>
In case of errors this function raises the error,
instead of returning an error code.




<p>
<hr><h3><a name="pdf-io.open"><code>io.open (filename [, mode])</code></a></h3>


<p>
This function opens a file,
in the mode specified in the string <code>mode</code>.
In case of success,
it returns a new file handle.


<p>
The <code>mode</code> string can be any of the following:

<ul>
<li><b>"<code>r</code>": </b> read mode (the default);</li>
<li><b>"<code>w</code>": </b> write mode;</li>
<li><b>"<code>a</code>": </b> append mode;</li>
<li><b>"<code>r+</code>": </b> update mode, all previous data is preserved;</li>
<li><b>"<code>w+</code>": </b> update mode, all previous data is erased;</li>
<li><b>"<code>a+</code>": </b> append update mode, previous data is preserved,
  writing is only allowed at the end of file.</li>
</ul><p>
The <code>mode</code> string can also have a '<code>b</code>' at the end,
which is needed in some systems to open the file in binary mode.




<p>
<hr><h3><a name="pdf-io.output"><code>io.output ([file])</code></a></h3>


<p>
Similar to <a href="#pdf-io.input"><code>io.input</code></a>, but operates over the default output file.




<p>
<hr><h3><a name="pdf-io.popen"><code>io.popen (prog [, mode])</code></a></h3>


<p>
This function is system dependent and is not available
on all platforms.


<p>
Starts program <code>prog</code> in a separated process and returns
a file handle that you can use to read data from this program
(if <code>mode</code> is <code>"r"</code>, the default)
or to write data to this program
(if <code>mode</code> is <code>"w"</code>).




<p>
<hr><h3><a name="pdf-io.read"><code>io.read (&middot;&middot;&middot;)</code></a></h3>


<p>
Equivalent to <code>io.input():read(&middot;&middot;&middot;)</code>.




<p>
<hr><h3><a name="pdf-io.tmpfile"><code>io.tmpfile ()</code></a></h3>


<p>
In case of success,
returns a handle for a temporary file.
This file is opened in update mode
and it is automatically removed when the program ends.




<p>
<hr><h3><a name="pdf-io.type"><code>io.type (obj)</code></a></h3>


<p>
Checks whether <code>obj</code> is a valid file handle.
Returns the string <code>"file"</code> if <code>obj</code> is an open file handle,
<code>"closed file"</code> if <code>obj</code> is a closed file handle,
or <b>nil</b> if <code>obj</code> is not a file handle.




<p>
<hr><h3><a name="pdf-io.write"><code>io.write (&middot;&middot;&middot;)</code></a></h3>


<p>
Equivalent to <code>io.output():write(&middot;&middot;&middot;)</code>.




<p>
<hr><h3><a name="pdf-file:close"><code>file:close ()</code></a></h3>


<p>
Closes <code>file</code>.
Note that files are automatically closed when
their handles are garbage collected,
but that takes an unpredictable amount of time to happen.


<p>
When closing a file handle created with <a href="#pdf-io.popen"><code>io.popen</code></a>,
<a href="#pdf-file:close"><code>file:close</code></a> returns the same values
returned by <a href="#pdf-os.execute"><code>os.execute</code></a>.




<p>
<hr><h3><a name="pdf-file:flush"><code>file:flush ()</code></a></h3>


<p>
Saves any written data to <code>file</code>.




<p>
<hr><h3><a name="pdf-file:lines"><code>file:lines (&middot;&middot;&middot;)</code></a></h3>


<p>
Returns an iterator function that,
each time it is called,
reads the file according to the given formats.
When no format is given,
uses "<code>l</code>" as a default.
As an example, the construction

<pre>
     for c in file:lines(1) do <em>body</em> end
</pre><p>
will iterate over all characters of the file,
starting at the current position.
Unlike <a href="#pdf-io.lines"><code>io.lines</code></a>, this function does not close the file
when the loop ends.


<p>
In case of errors this function raises the error,
instead of returning an error code.




<p>
<hr><h3><a name="pdf-file:read"><code>file:read (&middot;&middot;&middot;)</code></a></h3>


<p>
Reads the file <code>file</code>,
according to the given formats, which specify what to read.
For each format,
the function returns a string or a number with the characters read,
or <b>nil</b> if it cannot read data with the specified format.
(In this latter case,
the function does not read subsequent formats.)
When called without formats,
it uses a default format that reads the next line
(see below).


<p>
The available formats are

<ul>

<li><b>"<code>n</code>": </b>
reads a numeral and returns it as a float or an integer,
following the lexical conventions of Lua.
(The numeral may have leading spaces and a sign.)
This format always reads the longest input sequence that
is a valid prefix for a numeral;
if that prefix does not form a valid numeral
(e.g., an empty string, "<code>0x</code>", or "<code>3.4e-</code>"),
it is discarded and the function returns <b>nil</b>.
</li>

<li><b>"<code>a</code>": </b>
reads the whole file, starting at the current position.
On end of file, it returns the empty string.
</li>

<li><b>"<code>l</code>": </b>
reads the next line skipping the end of line,
returning <b>nil</b> on end of file.
This is the default format.
</li>

<li><b>"<code>L</code>": </b>
reads the next line keeping the end-of-line character (if present),
returning <b>nil</b> on end of file.
</li>

<li><b><em>number</em>: </b>
reads a string with up to this number of bytes,
returning <b>nil</b> on end of file.
If <code>number</code> is zero,
it reads nothing and returns an empty string,
or <b>nil</b> on end of file.
</li>

</ul><p>
The formats "<code>l</code>" and "<code>L</code>" should be used only for text files.




<p>
<hr><h3><a name="pdf-file:seek"><code>file:seek ([whence [, offset]])</code></a></h3>


<p>
Sets and gets the file position,
measured from the beginning of the file,
to the position given by <code>offset</code> plus a base
specified by the string <code>whence</code>, as follows:

<ul>
<li><b>"<code>set</code>": </b> base is position 0 (beginning of the file);</li>
<li><b>"<code>cur</code>": </b> base is current position;</li>
<li><b>"<code>end</code>": </b> base is end of file;</li>
</ul><p>
In case of success, <code>seek</code> returns the final file position,
measured in bytes from the beginning of the file.
If <code>seek</code> fails, it returns <b>nil</b>,
plus a string describing the error.


<p>
The default value for <code>whence</code> is <code>"cur"</code>,
and for <code>offset</code> is 0.
Therefore, the call <code>file:seek()</code> returns the current
file position, without changing it;
the call <code>file:seek("set")</code> sets the position to the
beginning of the file (and returns 0);
and the call <code>file:seek("end")</code> sets the position to the
end of the file, and returns its size.




<p>
<hr><h3><a name="pdf-file:setvbuf"><code>file:setvbuf (mode [, size])</code></a></h3>


<p>
Sets the buffering mode for an output file.
There are three available modes:

<ul>

<li><b>"<code>no</code>": </b>
no buffering; the result of any output operation appears immediately.
</li>

<li><b>"<code>full</code>": </b>
full buffering; output operation is performed only
when the buffer is full or when
you explicitly <code>flush</code> the file (see <a href="#pdf-io.flush"><code>io.flush</code></a>).
</li>

<li><b>"<code>line</code>": </b>
line buffering; output is buffered until a newline is output
or there is any input from some special files
(such as a terminal device).
</li>

</ul><p>
For the last two cases, <code>size</code>
specifies the size of the buffer, in bytes.
The default is an appropriate size.




<p>
<hr><h3><a name="pdf-file:write"><code>file:write (&middot;&middot;&middot;)</code></a></h3>


<p>
Writes the value of each of its arguments to <code>file</code>.
The arguments must be strings or numbers.


<p>
In case of success, this function returns <code>file</code>.
Otherwise it returns <b>nil</b> plus a string describing the error.







<h2>6.9 &ndash; <a name="6.9">Operating System Facilities</a></h2>

<p>
This library is implemented through table <a name="pdf-os"><code>os</code></a>.


<p>
<hr><h3><a name="pdf-os.clock"><code>os.clock ()</code></a></h3>


<p>
Returns an approximation of the amount in seconds of CPU time
used by the program.




<p>
<hr><h3><a name="pdf-os.date"><code>os.date ([format [, time]])</code></a></h3>


<p>
Returns a string or a table containing date and time,
formatted according to the given string <code>format</code>.


<p>
If the <code>time</code> argument is present,
this is the time to be formatted
(see the <a href="#pdf-os.time"><code>os.time</code></a> function for a description of this value).
Otherwise, <code>date</code> formats the current time.


<p>
If <code>format</code> starts with '<code>!</code>',
then the date is formatted in Coordinated Universal Time.
After this optional character,
if <code>format</code> is the string "<code>*t</code>",
then <code>date</code> returns a table with the following fields:
<code>year</code>, <code>month</code> (1&ndash;12), <code>day</code> (1&ndash;31),
<code>hour</code> (0&ndash;23), <code>min</code> (0&ndash;59), <code>sec</code> (0&ndash;61),
<code>wday</code> (weekday, 1&ndash;7, Sunday is&nbsp;1),
<code>yday</code> (day of the year, 1&ndash;366),
and <code>isdst</code> (daylight saving flag, a boolean).
This last field may be absent
if the information is not available.


<p>
If <code>format</code> is not "<code>*t</code>",
then <code>date</code> returns the date as a string,
formatted according to the same rules as the ISO&nbsp;C function <code>strftime</code>.


<p>
When called without arguments,
<code>date</code> returns a reasonable date and time representation that depends on
the host system and on the current locale.
(More specifically, <code>os.date()</code> is equivalent to <code>os.date("%c")</code>.)


<p>
On non-POSIX systems,
this function may be not thread safe
because of its reliance on C&nbsp;function <code>gmtime</code> and C&nbsp;function <code>localtime</code>.




<p>
<hr><h3><a name="pdf-os.difftime"><code>os.difftime (t2, t1)</code></a></h3>


<p>
Returns the difference, in seconds,
from time <code>t1</code> to time <code>t2</code>
(where the times are values returned by <a href="#pdf-os.time"><code>os.time</code></a>).
In POSIX, Windows, and some other systems,
this value is exactly <code>t2</code><em>-</em><code>t1</code>.




<p>
<hr><h3><a name="pdf-os.execute"><code>os.execute ([command])</code></a></h3>


<p>
This function is equivalent to the ISO&nbsp;C function <code>system</code>.
It passes <code>command</code> to be executed by an operating system shell.
Its first result is <b>true</b>
if the command terminated successfully,
or <b>nil</b> otherwise.
After this first result
the function returns a string plus a number,
as follows:

<ul>

<li><b>"<code>exit</code>": </b>
the command terminated normally;
the following number is the exit status of the command.
</li>

<li><b>"<code>signal</code>": </b>
the command was terminated by a signal;
the following number is the signal that terminated the command.
</li>

</ul>

<p>
When called without a <code>command</code>,
<code>os.execute</code> returns a boolean that is true if a shell is available.




<p>
<hr><h3><a name="pdf-os.exit"><code>os.exit ([code [, close]])</code></a></h3>


<p>
Calls the ISO&nbsp;C function <code>exit</code> to terminate the host program.
If <code>code</code> is <b>true</b>,
the returned status is <code>EXIT_SUCCESS</code>;
if <code>code</code> is <b>false</b>,
the returned status is <code>EXIT_FAILURE</code>;
if <code>code</code> is a number,
the returned status is this number.
The default value for <code>code</code> is <b>true</b>.


<p>
If the optional second argument <code>close</code> is true,
closes the Lua state before exiting.




<p>
<hr><h3><a name="pdf-os.getenv"><code>os.getenv (varname)</code></a></h3>


<p>
Returns the value of the process environment variable <code>varname</code>,
or <b>nil</b> if the variable is not defined.




<p>
<hr><h3><a name="pdf-os.remove"><code>os.remove (filename)</code></a></h3>


<p>
Deletes the file (or empty directory, on POSIX systems)
with the given name.
If this function fails, it returns <b>nil</b>,
plus a string describing the error and the error code.
Otherwise, it returns true.




<p>
<hr><h3><a name="pdf-os.rename"><code>os.rename (oldname, newname)</code></a></h3>


<p>
Renames the file or directory named <code>oldname</code> to <code>newname</code>.
If this function fails, it returns <b>nil</b>,
plus a string describing the error and the error code.
Otherwise, it returns true.




<p>
<hr><h3><a name="pdf-os.setlocale"><code>os.setlocale (locale [, category])</code></a></h3>


<p>
Sets the current locale of the program.
<code>locale</code> is a system-dependent string specifying a locale;
<code>category</code> is an optional string describing which category to change:
<code>"all"</code>, <code>"collate"</code>, <code>"ctype"</code>,
<code>"monetary"</code>, <code>"numeric"</code>, or <code>"time"</code>;
the default category is <code>"all"</code>.
The function returns the name of the new locale,
or <b>nil</b> if the request cannot be honored.


<p>
If <code>locale</code> is the empty string,
the current locale is set to an implementation-defined native locale.
If <code>locale</code> is the string "<code>C</code>",
the current locale is set to the standard C locale.


<p>
When called with <b>nil</b> as the first argument,
this function only returns the name of the current locale
for the given category.


<p>
This function may be not thread safe
because of its reliance on C&nbsp;function <code>setlocale</code>.




<p>
<hr><h3><a name="pdf-os.time"><code>os.time ([table])</code></a></h3>


<p>
Returns the current time when called without arguments,
or a time representing the local date and time specified by the given table.
This table must have fields <code>year</code>, <code>month</code>, and <code>day</code>,
and may have fields
<code>hour</code> (default is 12),
<code>min</code> (default is 0),
<code>sec</code> (default is 0),
and <code>isdst</code> (default is <b>nil</b>).
Other fields are ignored.
For a description of these fields, see the <a href="#pdf-os.date"><code>os.date</code></a> function.


<p>
The values in these fields do not need to be inside their valid ranges.
For instance, if <code>sec</code> is -10,
it means -10 seconds from the time specified by the other fields;
if <code>hour</code> is 1000,
it means +1000 hours from the time specified by the other fields.


<p>
The returned value is a number, whose meaning depends on your system.
In POSIX, Windows, and some other systems,
this number counts the number
of seconds since some given start time (the "epoch").
In other systems, the meaning is not specified,
and the number returned by <code>time</code> can be used only as an argument to
<a href="#pdf-os.date"><code>os.date</code></a> and <a href="#pdf-os.difftime"><code>os.difftime</code></a>.




<p>
<hr><h3><a name="pdf-os.tmpname"><code>os.tmpname ()</code></a></h3>


<p>
Returns a string with a file name that can
be used for a temporary file.
The file must be explicitly opened before its use
and explicitly removed when no longer needed.


<p>
On POSIX systems,
this function also creates a file with that name,
to avoid security risks.
(Someone else might create the file with wrong permissions
in the time between getting the name and creating the file.)
You still have to open the file to use it
and to remove it (even if you do not use it).


<p>
When possible,
you may prefer to use <a href="#pdf-io.tmpfile"><code>io.tmpfile</code></a>,
which automatically removes the file when the program ends.







<h2>6.10 &ndash; <a name="6.10">The Debug Library</a></h2>

<p>
This library provides
the functionality of the debug interface (<a href="#4.9">&sect;4.9</a>) to Lua programs.
You should exert care when using this library.
Several of its functions
violate basic assumptions about Lua code
(e.g., that variables local to a function
cannot be accessed from outside;
that userdata metatables cannot be changed by Lua code;
that Lua programs do not crash)
and therefore can compromise otherwise secure code.
Moreover, some functions in this library may be slow.


<p>
All functions in this library are provided
inside the <a name="pdf-debug"><code>debug</code></a> table.
All functions that operate over a thread
have an optional first argument which is the
thread to operate over.
The default is always the current thread.


<p>
<hr><h3><a name="pdf-debug.debug"><code>debug.debug ()</code></a></h3>


<p>
Enters an interactive mode with the user,
running each string that the user enters.
Using simple commands and other debug facilities,
the user can inspect global and local variables,
change their values, evaluate expressions, and so on.
A line containing only the word <code>cont</code> finishes this function,
so that the caller continues its execution.


<p>
Note that commands for <code>debug.debug</code> are not lexically nested
within any function and so have no direct access to local variables.




<p>
<hr><h3><a name="pdf-debug.gethook"><code>debug.gethook ([thread])</code></a></h3>


<p>
Returns the current hook settings of the thread, as three values:
the current hook function, the current hook mask,
and the current hook count
(as set by the <a href="#pdf-debug.sethook"><code>debug.sethook</code></a> function).




<p>
<hr><h3><a name="pdf-debug.getinfo"><code>debug.getinfo ([thread,] f [, what])</code></a></h3>


<p>
Returns a table with information about a function.
You can give the function directly
or you can give a number as the value of <code>f</code>,
which means the function running at level <code>f</code> of the call stack
of the given thread:
level&nbsp;0 is the current function (<code>getinfo</code> itself);
level&nbsp;1 is the function that called <code>getinfo</code>
(except for tail calls, which do not count on the stack);
and so on.
If <code>f</code> is a number larger than the number of active functions,
then <code>getinfo</code> returns <b>nil</b>.


<p>
The returned table can contain all the fields returned by <a href="#lua_getinfo"><code>lua_getinfo</code></a>,
with the string <code>what</code> describing which fields to fill in.
The default for <code>what</code> is to get all information available,
except the table of valid lines.
If present,
the option '<code>f</code>'
adds a field named <code>func</code> with the function itself.
If present,
the option '<code>L</code>'
adds a field named <code>activelines</code> with the table of
valid lines.


<p>
For instance, the expression <code>debug.getinfo(1,"n").name</code> returns
a name for the current function,
if a reasonable name can be found,
and the expression <code>debug.getinfo(print)</code>
returns a table with all available information
about the <a href="#pdf-print"><code>print</code></a> function.




<p>
<hr><h3><a name="pdf-debug.getlocal"><code>debug.getlocal ([thread,] f, local)</code></a></h3>


<p>
This function returns the name and the value of the local variable
with index <code>local</code> of the function at level <code>f</code> of the stack.
This function accesses not only explicit local variables,
but also parameters, temporaries, etc.


<p>
The first parameter or local variable has index&nbsp;1, and so on,
following the order that they are declared in the code,
counting only the variables that are active
in the current scope of the function.
Negative indices refer to vararg parameters;
-1 is the first vararg parameter.
The function returns <b>nil</b> if there is no variable with the given index,
and raises an error when called with a level out of range.
(You can call <a href="#pdf-debug.getinfo"><code>debug.getinfo</code></a> to check whether the level is valid.)


<p>
Variable names starting with '<code>(</code>' (open parenthesis) 
represent variables with no known names
(internal variables such as loop control variables,
and variables from chunks saved without debug information).


<p>
The parameter <code>f</code> may also be a function.
In that case, <code>getlocal</code> returns only the name of function parameters.




<p>
<hr><h3><a name="pdf-debug.getmetatable"><code>debug.getmetatable (value)</code></a></h3>


<p>
Returns the metatable of the given <code>value</code>
or <b>nil</b> if it does not have a metatable.




<p>
<hr><h3><a name="pdf-debug.getregistry"><code>debug.getregistry ()</code></a></h3>


<p>
Returns the registry table (see <a href="#4.5">&sect;4.5</a>).




<p>
<hr><h3><a name="pdf-debug.getupvalue"><code>debug.getupvalue (f, up)</code></a></h3>


<p>
This function returns the name and the value of the upvalue
with index <code>up</code> of the function <code>f</code>.
The function returns <b>nil</b> if there is no upvalue with the given index.


<p>
Variable names starting with '<code>(</code>' (open parenthesis) 
represent variables with no known names
(variables from chunks saved without debug information).




<p>
<hr><h3><a name="pdf-debug.getuservalue"><code>debug.getuservalue (u)</code></a></h3>


<p>
Returns the Lua value associated to <code>u</code>.
If <code>u</code> is not a full userdata,
returns <b>nil</b>.




<p>
<hr><h3><a name="pdf-debug.sethook"><code>debug.sethook ([thread,] hook, mask [, count])</code></a></h3>


<p>
Sets the given function as a hook.
The string <code>mask</code> and the number <code>count</code> describe
when the hook will be called.
The string mask may have any combination of the following characters,
with the given meaning:

<ul>
<li><b>'<code>c</code>': </b> the hook is called every time Lua calls a function;</li>
<li><b>'<code>r</code>': </b> the hook is called every time Lua returns from a function;</li>
<li><b>'<code>l</code>': </b> the hook is called every time Lua enters a new line of code.</li>
</ul><p>
Moreover,
with a <code>count</code> different from zero,
the hook is called also after every <code>count</code> instructions.


<p>
When called without arguments,
<a href="#pdf-debug.sethook"><code>debug.sethook</code></a> turns off the hook.


<p>
When the hook is called, its first parameter is a string
describing the event that has triggered its call:
<code>"call"</code> (or <code>"tail call"</code>),
<code>"return"</code>,
<code>"line"</code>, and <code>"count"</code>.
For line events,
the hook also gets the new line number as its second parameter.
Inside a hook,
you can call <code>getinfo</code> with level&nbsp;2 to get more information about
the running function
(level&nbsp;0 is the <code>getinfo</code> function,
and level&nbsp;1 is the hook function).




<p>
<hr><h3><a name="pdf-debug.setlocal"><code>debug.setlocal ([thread,] level, local, value)</code></a></h3>


<p>
This function assigns the value <code>value</code> to the local variable
with index <code>local</code> of the function at level <code>level</code> of the stack.
The function returns <b>nil</b> if there is no local
variable with the given index,
and raises an error when called with a <code>level</code> out of range.
(You can call <code>getinfo</code> to check whether the level is valid.)
Otherwise, it returns the name of the local variable.


<p>
See <a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a> for more information about
variable indices and names.




<p>
<hr><h3><a name="pdf-debug.setmetatable"><code>debug.setmetatable (value, table)</code></a></h3>


<p>
Sets the metatable for the given <code>value</code> to the given <code>table</code>
(which can be <b>nil</b>).
Returns <code>value</code>.




<p>
<hr><h3><a name="pdf-debug.setupvalue"><code>debug.setupvalue (f, up, value)</code></a></h3>


<p>
This function assigns the value <code>value</code> to the upvalue
with index <code>up</code> of the function <code>f</code>.
The function returns <b>nil</b> if there is no upvalue
with the given index.
Otherwise, it returns the name of the upvalue.




<p>
<hr><h3><a name="pdf-debug.setuservalue"><code>debug.setuservalue (udata, value)</code></a></h3>


<p>
Sets the given <code>value</code> as
the Lua value associated to the given <code>udata</code>.
<code>udata</code> must be a full userdata.


<p>
Returns <code>udata</code>.




<p>
<hr><h3><a name="pdf-debug.traceback"><code>debug.traceback ([thread,] [message [, level]])</code></a></h3>


<p>
If <code>message</code> is present but is neither a string nor <b>nil</b>,
this function returns <code>message</code> without further processing.
Otherwise,
it returns a string with a traceback of the call stack.
The optional <code>message</code> string is appended
at the beginning of the traceback.
An optional <code>level</code> number tells at which level
to start the traceback
(default is 1, the function calling <code>traceback</code>).




<p>
<hr><h3><a name="pdf-debug.upvalueid"><code>debug.upvalueid (f, n)</code></a></h3>


<p>
Returns a unique identifier (as a light userdata)
for the upvalue numbered <code>n</code>
from the given function.


<p>
These unique identifiers allow a program to check whether different
closures share upvalues.
Lua closures that share an upvalue
(that is, that access a same external local variable)
will return identical ids for those upvalue indices.




<p>
<hr><h3><a name="pdf-debug.upvaluejoin"><code>debug.upvaluejoin (f1, n1, f2, n2)</code></a></h3>


<p>
Make the <code>n1</code>-th upvalue of the Lua closure <code>f1</code>
refer to the <code>n2</code>-th upvalue of the Lua closure <code>f2</code>.







<h1>7 &ndash; <a name="7">단독형 루아</a></h1>

<p>
루아는 호스트 C 프로그램에 내장되는 확장 언어로 설계되었지만
단독 언어로도 자주 쓰인다.
단독 언어 루아를 위한
<code>lua</code>라는 인터프리터가
표준 배포본에 딸려 있다.
단독 인터프리터에는
디버그 라이브러리를 포함해
모든 표준 라이브러리가 포함되어 있다.
사용법은 이렇다.

<pre>
     lua [options] [script [args]]
</pre><p>
옵션은 이렇다.

<ul>
<li><b><code>-e <em>stat</em></code>: </b> 문자열 <em>stat</em> 실행하기</li>
<li><b><code>-l <em>mod</em></code>: </b> <em>mod</em>를 "require" 하기</li>
<li><b><code>-i</code>: </b> <em>script</em> 실행 후 대화형 모드 들어가기</li>
<li><b><code>-v</code>: </b> 버전 정보 찍기</li>
<li><b><code>-E</code>: </b> 환경 변수 무시하기</li>
<li><b><code>--</code>: </b> 옵션 처리 멈추기</li>
<li><b><code>-</code>: </b> <code>stdin</code>을 파일처럼 실행하고 옵션 처리 멈추기</li>
</ul><p>
<code>lua</code>는 옵션들을 처리한 후 주어진 <em>script</em>를 실행한다.
<code>lua</code>를 인자 없이 호출하면
표준 입력(<code>stdin</code>)이 터미널일 때는 <code>lua -v -i</code>처럼 동작하고
아닐 때는 <code>lua -</code>처럼 동작한다.


<p>
<code>-E</code> 옵션 없이 호출 시
인터프리터는 인자 실행에 앞서
환경 변수 <a name="pdf-LUA_INIT_5_3"><code>LUA_INIT_5_3</code></a>을
(버전 붙은 이름이 정의되어 있지 않으면 <a name="pdf-LUA_INIT"><code>LUA_INIT</code></a>을) 확인한다.
변수 내용이 <code>@<em>파일명</em></code> 형식이면
<code>lua</code>가 그 파일을 실행한다.
그렇지 않으면 <code>lua</code>가 그 문자열 자체를 실행한다.


<p>
<code>-E</code> 옵션으로 호출 시
루아는 <code>LUA_INIT</code>과 더불어
<code>LUA_PATH</code>와 <code>LUA_CPATH</code>의 값도 무시하며,
<a href="#pdf-package.path"><code>package.path</code></a>와 <a href="#pdf-package.cpath"><code>package.cpath</code></a>의 값을
<code>luaconf.h</code>에 정의된 기본 경로로 설정한다.


<p>
<code>-i</code>와 <code>-E</code>를 제외한 모든 옵션들을 순서 대로 처리한다.
예를 들어 다음과 같이 호출 시,

<pre>
     $ lua -e'a=1' -e 'print(a)' script.lua
</pre><p>
먼저 <code>a</code>를 1로 설정하고, 다음으로 <code>a</code>의 값을 찍고,
마지막으로 인자 없이 <code>script.lua</code> 파일을 실행한다.
(여기서 <code>$</code>는 셸 프롬프트이다. 사용자마다 다를 수 있다.)


<p>
코드 실행 전에
<code>lua</code>는 모든 명령행 인자를
<code>arg</code>라는 전역 테이블에 모은다.
스크립트 이름이 0번 인덱스로 가고
스크립트 다음 첫 번째 인자가 1번 인덱스로 가고
하는 식이다.
그리고 스크립트 이름 앞의 인자들이
(즉 인터프리터 이름과 그 옵션들이)
음수 인덱스로 간다.
예를 들어 다음 호출에서,

<pre>
     $ lua -la b.lua t1 t2
</pre><p>
테이블이 다음과 같다.

<pre>
     arg = { [-2] = "lua", [-1] = "-la",
             [0] = "b.lua",
             [1] = "t1", [2] = "t2" }
</pre><p>
호출에 스크립트가 없으면
인터프리터가 0번 인덱스로 가고
다른 인자들이 뒤따른다.
예를 들어 다음 호출이

<pre>
     $ lua -e "print(arg[1])"
</pre><p>
"<code>-e</code>"를 찍는다.
스크립트가 있으면
매개변수 <code>arg[1]</code>, &middot;&middot;&middot;, <code>arg[#arg]</code>로
호출한다.
(루아의 여느 청크들처럼
스크립트를 vararg 함수로 컴파일 한다.)


<p>
대화형 모드에서
루아는 반복해서 프롬프트를 보이며 행 입력을 기다린다.
행을 읽은 후
루아는 먼저 식으로 해석하려고 시도한다.
성공하면 그 값을 찍는다.
아니면 그 행을 문으로 해석한다.
입력 받은 문이 불완전하면
인터프리터가 다른 프롬프트를 보이며
문 완결을 기다린다.


<p>
전역 변수 <a name="pdf-_PROMPT"><code>_PROMPT</code></a>가 문자열을 담고 있으면
그 값을 프롬프트로 쓴다.
마찬가지로 전역 변수 <a name="pdf-_PROMPT2"><code>_PROMPT2</code></a>가 문자열을 담고 있으면
그 값을
(문이 미완성인 동안 보이는)
보조 프롬프트로 쓴다.


<p>
스크립트에서 보호 안 된 오류가 발생하면
인터프리터가 그 오류를 표준 오류 스트림으로 알린다.
오류 객체가 문자열이 아니지만
메타메소드 <code>__tostring</code>을 가지고 있으면
인터프리터가 그 메타메소드를 호출해서 최종 메시지를 만든다.
그렇지 않으면 인터프리터가 오류 객체를 문자열로 변환하고
스택 트레이스백을 덧붙인다.


<p>
정상적으로 끝날 때
인터프리터에서 자기의 주 루아 상태를 닫는다.
(<a href="#lua_close"><code>lua_close</code></a> 참고.)
이 단계를 피하고 싶으면 스크립트에서
<a href="#pdf-os.exit"><code>os.exit</code></a> 호출로 종료하면 된다.


<p>
유닉스 시스템에서 루아를
스크립트 인터프리터로 쓸 수 있게 하기 위해
단독형 인터프리터는 청크 첫 행이 <code>#</code>로 시작하면
그 행을 건너뛴다.
그래서 <code>chmod +x</code> 하고 다음처럼 <code>#!</code> 형식을 쓰면
루아 스크립트를 실행 프로그램으로 만들 수 있다.

<pre>
     #!/usr/local/bin/lua
</pre><p>
(물론
루아 인터프리터 위치는 머신마다 다를 수 있다.
<code>PATH</code> 안에 <code>lua</code>가 있다면
다음이 더 이식성 높은 방법이다.)

<pre>
     #!/usr/bin/env lua
</pre><p>



<h1>8 &ndash; <a name="8">Incompatibilities with the Previous Version</a></h1>

<p>
Here we list the incompatibilities that you may find when moving a program
from Lua&nbsp;5.2 to Lua&nbsp;5.3.
You can avoid some incompatibilities by compiling Lua with
appropriate options (see file <code>luaconf.h</code>).
However,
all these compatibility options will be removed in the future.


<p>
Lua versions can always change the C API in ways that
do not imply source-code changes in a program,
such as the numeric values for constants
or the implementation of functions as macros.
Therefore,
you should not assume that binaries are compatible between
different Lua versions.
Always recompile clients of the Lua API when
using a new version.


<p>
Similarly, Lua versions can always change the internal representation
of precompiled chunks;
precompiled chunks are not compatible between different Lua versions.


<p>
The standard paths in the official distribution may
change between versions.



<h2>8.1 &ndash; <a name="8.1">Changes in the Language</a></h2>
<ul>

<li>
The main difference between Lua&nbsp;5.2 and Lua&nbsp;5.3 is the
introduction of an integer subtype for numbers.
Although this change should not affect "normal" computations,
some computations
(mainly those that involve some kind of overflow)
can give different results.


<p>
You can fix these differences by forcing a number to be a float
(in Lua&nbsp;5.2 all numbers were float),
in particular writing constants with an ending <code>.0</code>
or using <code>x = x + 0.0</code> to convert a variable.
(This recommendation is only for a quick fix
for an occasional incompatibility;
it is not a general guideline for good programming.
For good programming,
use floats where you need floats
and integers where you need integers.)
</li>

<li>
The conversion of a float to a string now adds a <code>.0</code> suffix
to the result if it looks like an integer.
(For instance, the float 2.0 will be printed as <code>2.0</code>,
not as <code>2</code>.)
You should always use an explicit format
when you need a specific format for numbers.


<p>
(Formally this is not an incompatibility,
because Lua does not specify how numbers are formatted as strings,
but some programs assumed a specific format.)
</li>

<li>
The generational mode for the garbage collector was removed.
(It was an experimental feature in Lua&nbsp;5.2.)
</li>

</ul>




<h2>8.2 &ndash; <a name="8.2">Changes in the Libraries</a></h2>
<ul>

<li>
The <code>bit32</code> library has been deprecated.
It is easy to require a compatible external library or,
better yet, to replace its functions with appropriate bitwise operations.
(Keep in mind that <code>bit32</code> operates on 32-bit integers,
while the bitwise operators in Lua&nbsp;5.3 operate on Lua integers,
which by default have 64&nbsp;bits.)
</li>

<li>
The Table library now respects metamethods
for setting and getting elements.
</li>

<li>
The <a href="#pdf-ipairs"><code>ipairs</code></a> iterator now respects metamethods and
its <code>__ipairs</code> metamethod has been deprecated.
</li>

<li>
Option names in <a href="#pdf-io.read"><code>io.read</code></a> do not have a starting '<code>*</code>' anymore.
For compatibility, Lua will continue to accept (and ignore) this character.
</li>

<li>
The following functions were deprecated in the mathematical library:
<code>atan2</code>, <code>cosh</code>, <code>sinh</code>, <code>tanh</code>, <code>pow</code>,
<code>frexp</code>, and <code>ldexp</code>.
You can replace <code>math.pow(x,y)</code> with <code>x^y</code>;
you can replace <code>math.atan2</code> with <code>math.atan</code>,
which now accepts one or two parameters;
you can replace <code>math.ldexp(x,exp)</code> with <code>x * 2.0^exp</code>.
For the other operations,
you can either use an external library or
implement them in Lua.
</li>

<li>
The searcher for C loaders used by <a href="#pdf-require"><code>require</code></a>
changed the way it handles versioned names.
Now, the version should come after the module name
(as is usual in most other tools).
For compatibility, that searcher still tries the old format
if it cannot find an open function according to the new style.
(Lua&nbsp;5.2 already worked that way,
but it did not document the change.)
</li>

<li>
The call <code>collectgarbage("count")</code> now returns only one result.
(You can compute that second result from the fractional part
of the first result.)
</li>

</ul>




<h2>8.3 &ndash; <a name="8.3">Changes in the API</a></h2>


<ul>

<li>
Continuation functions now receive as parameters what they needed
to get through <code>lua_getctx</code>,
so <code>lua_getctx</code> has been removed.
Adapt your code accordingly.
</li>

<li>
Function <a href="#lua_dump"><code>lua_dump</code></a> has an extra parameter, <code>strip</code>.
Use 0 as the value of this parameter to get the old behavior.
</li>

<li>
Functions to inject/project unsigned integers
(<code>lua_pushunsigned</code>, <code>lua_tounsigned</code>, <code>lua_tounsignedx</code>,
<code>luaL_checkunsigned</code>, <code>luaL_optunsigned</code>)
were deprecated.
Use their signed equivalents with a type cast.
</li>

<li>
Macros to project non-default integer types
(<code>luaL_checkint</code>, <code>luaL_optint</code>, <code>luaL_checklong</code>, <code>luaL_optlong</code>)
were deprecated.
Use their equivalent over <a href="#lua_Integer"><code>lua_Integer</code></a> with a type cast
(or, when possible, use <a href="#lua_Integer"><code>lua_Integer</code></a> in your code).
</li>

</ul>




<h1>9 &ndash; <a name="9">루아 전체 문법</a></h1>

<p>
다음은 확장 BNF로 된 루아의 전체 문법이다.
확장 BNF에서 늘 그렇듯
{A}는 0개 이상의 A를 뜻하고
[A]는 선택적인 A를 뜻한다.
(연산자 우선순위는 <a href="#3.4.8">3.4.8절</a> 참고.
말단 Name, Numeral, LiteralString에 대한 설명은
<a href="#3.1">3.1절</a> 참고.)




<pre>

	chunk ::= block

	block ::= {stat} [retstat]

	stat ::=  &lsquo;<b>;</b>&rsquo; | 
		 varlist &lsquo;<b>=</b>&rsquo; explist | 
		 functioncall | 
		 label | 
		 <b>break</b> | 
		 <b>goto</b> Name | 
		 <b>do</b> block <b>end</b> | 
		 <b>while</b> exp <b>do</b> block <b>end</b> | 
		 <b>repeat</b> block <b>until</b> exp | 
		 <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b> | 
		 <b>for</b> Name &lsquo;<b>=</b>&rsquo; exp &lsquo;<b>,</b>&rsquo; exp [&lsquo;<b>,</b>&rsquo; exp] <b>do</b> block <b>end</b> | 
		 <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b> | 
		 <b>function</b> funcname funcbody | 
		 <b>local</b> <b>function</b> Name funcbody | 
		 <b>local</b> namelist [&lsquo;<b>=</b>&rsquo; explist] 

	retstat ::= <b>return</b> [explist] [&lsquo;<b>;</b>&rsquo;]

	label ::= &lsquo;<b>::</b>&rsquo; Name &lsquo;<b>::</b>&rsquo;

	funcname ::= Name {&lsquo;<b>.</b>&rsquo; Name} [&lsquo;<b>:</b>&rsquo; Name]

	varlist ::= var {&lsquo;<b>,</b>&rsquo; var}

	var ::=  Name | prefixexp &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; | prefixexp &lsquo;<b>.</b>&rsquo; Name 

	namelist ::= Name {&lsquo;<b>,</b>&rsquo; Name}

	explist ::= exp {&lsquo;<b>,</b>&rsquo; exp}

	exp ::=  <b>nil</b> | <b>false</b> | <b>true</b> | Numeral | LiteralString | &lsquo;<b>...</b>&rsquo; | functiondef | 
		 prefixexp | tableconstructor | exp binop exp | unop exp 

	prefixexp ::= var | functioncall | &lsquo;<b>(</b>&rsquo; exp &lsquo;<b>)</b>&rsquo;

	functioncall ::=  prefixexp args | prefixexp &lsquo;<b>:</b>&rsquo; Name args 

	args ::=  &lsquo;<b>(</b>&rsquo; [explist] &lsquo;<b>)</b>&rsquo; | tableconstructor | LiteralString 

	functiondef ::= <b>function</b> funcbody

	funcbody ::= &lsquo;<b>(</b>&rsquo; [parlist] &lsquo;<b>)</b>&rsquo; block <b>end</b>

	parlist ::= namelist [&lsquo;<b>,</b>&rsquo; &lsquo;<b>...</b>&rsquo;] | &lsquo;<b>...</b>&rsquo;

	tableconstructor ::= &lsquo;<b>{</b>&rsquo; [fieldlist] &lsquo;<b>}</b>&rsquo;

	fieldlist ::= field {fieldsep field} [fieldsep]

	field ::= &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; &lsquo;<b>=</b>&rsquo; exp | Name &lsquo;<b>=</b>&rsquo; exp | exp

	fieldsep ::= &lsquo;<b>,</b>&rsquo; | &lsquo;<b>;</b>&rsquo;

	binop ::=  &lsquo;<b>+</b>&rsquo; | &lsquo;<b>-</b>&rsquo; | &lsquo;<b>*</b>&rsquo; | &lsquo;<b>/</b>&rsquo; | &lsquo;<b>//</b>&rsquo; | &lsquo;<b>^</b>&rsquo; | &lsquo;<b>%</b>&rsquo; | 
		 &lsquo;<b>&amp;</b>&rsquo; | &lsquo;<b>~</b>&rsquo; | &lsquo;<b>|</b>&rsquo; | &lsquo;<b>&gt;&gt;</b>&rsquo; | &lsquo;<b>&lt;&lt;</b>&rsquo; | &lsquo;<b>..</b>&rsquo; | 
		 &lsquo;<b>&lt;</b>&rsquo; | &lsquo;<b>&lt;=</b>&rsquo; | &lsquo;<b>&gt;</b>&rsquo; | &lsquo;<b>&gt;=</b>&rsquo; | &lsquo;<b>==</b>&rsquo; | &lsquo;<b>~=</b>&rsquo; | 
		 <b>and</b> | <b>or</b>

	unop ::= &lsquo;<b>-</b>&rsquo; | <b>not</b> | &lsquo;<b>#</b>&rsquo; | &lsquo;<b>~</b>&rsquo;

</pre>

<p>







<P CLASS="footer">
Last update:
Fri Feb  3 07:26:45 BRST 2017
</P>
<!--
Last change: revised for Lua 5.3.4
-->

</body></html>

